// Copyright (c) 2023, Marcus Rowe <undisbeliever@gmail.com>.
// Distributed under The MIT License, see the LICENSE file for more details.


import "audio-driver";


let MAX_PAN = 128;


namespace bytecode {

let MAX_NESTED_LOOPS = 3;

let N_NOTE_OCTAVES = 8;
let N_PLAY_NOTE_INSTRUCTIONS = N_NOTE_OCTAVES * 12 * 2;

let FIRST_INSTRUCTION_WITH_ARGUMENT_OPCODE = N_PLAY_NOTE_INSTRUCTIONS;
let FIRST_NO_ARGUMENT_INSTRUCTION_OPCODE = FIRST_INSTRUCTION_WITH_ARGUMENT_OPCODE + bytecode.INSTRUCTIONS_WITH_ARGUMENTS.len * 2;

// Last instruction is the `disable_channel` instruction
let DISABLE_CHANNEL_BYTECODE = 0xfe;



// OPCODES < N_PLAY_NOTE_INSTRUCTIONS are a two-byte play note instruction.
//
//  nnnnnnnO llllllll
//      nnnnnnn = note to play (number of semitones above c0)
//            O = key-off after note ends
//     llllllll = note length
//
//  NOTE: This instruction will wait an extra tick if the `key-off` bit is set.

// The remaining instructions have an opcode of `0xc0 + instruction_index * 2`


// Notes about rest/note length:
//   * A rest/note length of 0 will pause for 256 ticks
//   * A rest/note instruction will wait for an extra tick if the key-off bit is set.

// These bytecodes do have parameters
let INSTRUCTIONS_WITH_ARGUMENTS = [
    // parameters: vvvvvvvv llllllll nnnnnnnO
    //     vvvvvvvv = i8 velocity (signed PITCH change per tick)
    //     llllllll = note length
    //      nnnnnnn = note to target (number of semitones above c0)
    //            O = key-off after note ends
    //
    // NOTE: portamento does not emit a KON event
    portamento,


    set_instrument,


    // parameter = number of ticks to wait.
    // NOTE: Does not send a keyoff event after resting.
    rest,

    // parameter = number of ticks to wait.
    // Sends a keyoff event after resting (NOTE: waits an extra tick after keyoff).
    rest_keyoff,


    // parameter = subroutine ID (MAX: 127)
    //
    // NOTE: Only the lower 7 bits of the subroutine id are used.
    // NOTE: There is no bounds checking
    call_subroutine,


    // parameter = u8 number of times to loop
    start_loop_0,
    start_loop_1,
    start_loop_2,


    // Breaks a loop early if the loop is on the last cycle
    //  Used to implement the `:` token in a MML loop.
    //
    // ie. Allows for `[ abc : de ]3` loops, which will play `abc de abc de abc`.
    //
    // parameter = number of bytes in the bytecode to skip if loop counter == 1.
    skip_last_loop_0,
    skip_last_loop_1,
    skip_last_loop_2,


    // parameter = u16 value to send to the ADSR register
    set_adsr,

    // parameter = u8 value to send to the GAIN register
    // NOTE: Disables ADSR
    set_gain,


    // parameter = u8 volume (0-255)
    set_volume,

    // parameter = u8 volume to increment
    inc_volume,

    // parameter = u8 volume to decrement
    dec_volume,

    // parameter = pan (0-MAX_PAN, MAX_PAN/2 is centered)
    set_pan,

    // parameter = u8 pan to increment
    inc_pan,

    // parameter = u8 pan to decrement
    dec_pan,

    // parameter: pppppppp vvvvvvvv
    //      pppppppp = pan (0 - MAX_PAN, MAX_PAN/2 is centered)
    //      vvvvvvvv = volume
    set_pan_and_volume,
];


// These bytecodes do not have parameters
let NO_ARGUMENT_INSTRUCTIONS = [
    // End of channel bytecode.
    //
    // This instruction will either jump to the loop point or stop the channel
    // (depending `MusicChannelHeader.loop`)
    //
    // This instruction is not recommended for sound effects.
    // NOTE: `disable_channel` is slightly faster then `end`.
    end,


    // Return from a call instruction
    return_from_subroutine,


    // Jump to `start_loop_*` if `--loop_count != 0`
    end_loop_0,
    end_loop_1,
    end_loop_2,


    // padding
    disable_channel,
    disable_channel,
    disable_channel,
    disable_channel,
    disable_channel,
    disable_channel,
];

}


