// Copyright (c) 2023, Marcus Rowe <undisbeliever@gmail.com>.
// Distributed under The MIT License, see the LICENSE file for more details.


import "audio-driver";


let MAX_PAN = 128;


namespace bytecode {

let N_NOTE_OCTAVES = 8;
let N_PLAY_NOTE_INSTRUCTIONS = N_NOTE_OCTAVES * 12 * 2;

let FIRST_INSTRUCTION_WITH_ARGUMENT_OPCODE = N_PLAY_NOTE_INSTRUCTIONS;
let FIRST_NO_ARGUMENT_INSTRUCTION_OPCODE = FIRST_INSTRUCTION_WITH_ARGUMENT_OPCODE + bytecode.INSTRUCTIONS_WITH_ARGUMENTS.len * 2;

// Last instruction is the `disable_channel` instruction
let DISABLE_CHANNEL_BYTECODE = 0xfe;



// OPCODES < N_PLAY_NOTE_INSTRUCTIONS are a two-byte play note instruction.
//
//  nnnnnnnO llllllll
//      nnnnnnn = note to play (number of semitones above c0)
//            O = key-off after note ends
//     llllllll = note length
//
//  NOTE: This instruction will wait an extra tick if the `key-off` bit is set.

// The remaining instructions have an opcode of `0xc0 + instruction_index * 2`


// Notes about rest/note length:
//   * A rest/note length of 0 will pause for 256 ticks
//   * A rest/note instruction will wait for an extra tick if the key-off bit is set.

// These bytecodes do have parameters
let INSTRUCTIONS_WITH_ARGUMENTS = [
    set_instrument,


    // parameter = number of ticks to wait.
    // NOTE: Does not send a keyoff event after resting.
    rest,

    // parameter = number of ticks to wait.
    // Sends a keyoff event after resting (NOTE: waits an extra tick after keyoff).
    rest_keyoff,


    // parameter = subroutine ID (MAX: 127)
    //
    // NOTE: Only the lower 7 bits of the subroutine id are used.
    // NOTE: There is no bounds checking
    call_subroutine,

    // parameter = number of times to loop - 2
    end_loop_0,

    // parameter = number of times to loop - 2
    end_loop_1,


    // parameter = u16 value to send to the ADSR register
    set_adsr,

    // parameter = u8 value to send to the GAIN register
    // NOTE: Disables ADSR
    set_gain,


    // parameter = u8 volume (0-255)
    set_volume,

    // parameter = pan (0-MAX_PAN, MAX_PAN/2 is centered)
    set_pan,

    // parameter: pppppppp vvvvvvvv
    //      pppppppp = pan (0 - MAX_PAN, MAX_PAN/2 is centered)
    //      vvvvvvvv = volume
    set_pan_and_volume,
];


// These bytecodes do not have parameters
let NO_ARGUMENT_INSTRUCTIONS = [
    // End of channel bytecode.
    //
    // This instruction will either jump to the loop point or stop the channel
    // (depending `MusicChannelHeader.loop`)
    //
    // This instruction is not recommended for sound effects.
    // NOTE: `disable_channel` is slightly faster then `end`.
    end,


    // Return from a call instruction
    return_from_subroutine,

    start_loop_0,
    start_loop_1,


    // padding
    disable_channel,
    disable_channel,
    disable_channel,
    disable_channel,
    disable_channel,
    disable_channel,
    disable_channel,
    disable_channel,
    disable_channel,
    disable_channel,
    disable_channel,
    disable_channel,
    disable_channel,
    disable_channel,
    disable_channel,
    disable_channel,
];

}


