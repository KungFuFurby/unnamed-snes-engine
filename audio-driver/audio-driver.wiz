// Copyright (c) 2023, Marcus Rowe <undisbeliever@gmail.com>.
// Distributed under The MIT License, see the LICENSE file for more details.


import "registers";
import "common_memmap";

config {
    trim = true
}

bank code           @ CODE_ADDR : [constdata;   CODE_SIZE];


// Data Structures
// ===============

// The minimum timer value required to ensure Key-Off event completely silences the sample before
// the next note plays.
let MIN_TICK_CLOCK = 64;


// The tempo (timer register value) for the sound effects
// MUST BE >= MIN_TICK_CLOCK
let SFX_TICK_CLOCK = 64;


let N_CHANNELS = 8;
let N_MUSIC_CHANNELS = 6;
let N_SFX_CHANNELS = N_CHANNELS - N_MUSIC_CHANNELS;

let SONG_CHANNEL_MASK = (1 << N_MUSIC_CHANNELS) - 1;
let SFX_CHANNEL_MASK = SONG_CHANNEL_MASK ^ 0xff;


let N_BRR_SAMPLES   = 64;
let N_INSTRUMENTS   = 64;
let N_SOUND_EFFECTS = 128;


let INSTRUMENT_MASK = N_INSTRUMENTS - 1;
let SOUND_EFFECT_MASK = N_SOUND_EFFECTS - 1;


let STARTING_CHANNEL_VOLUME = 96;
let STARTING_OCTAVE = 3;
let STARTING_DEFAULT_NOTE_LENGTH = 96 / 4;


let SFX_BPM = 125;
let SFX_TEMPO = (TICKS_PER_SECOND * 60 * 0x100) / (SFX_BPM * 48);


struct DirItem {
    start : *const u8,
    loop  : *const u8
};

struct InstrumentsSoA {
    scrn            : [u8 ; N_INSTRUMENTS],
    adsr1           : [u8 ; N_INSTRUMENTS],
    adsr2           : [u8 ; N_INSTRUMENTS],
    gain            : [u8 ; N_INSTRUMENTS],

    // offset between note c0 and `ExternalData.pitchTable[0]`
    // (pitchOffset + note is allowed to overflow and underflow)
    pitchOffset    : [u8 ; N_INSTRUMENTS],
};

struct ExternalData {
    brrDirectory   : [DirItem ; N_BRR_SAMPLES],

    pitchTable_l   : [u8; 256],
    pitchTable_h   : [u8; 256],

    instruments    : InstrumentsSoA,

    // The address of the sound effect bytecode.
    soundEffects_l : [u8; N_SOUND_EFFECTS],
    soundEffects_h : [u8; N_SOUND_EFFECTS],
};


struct MusicChannelHeader {
    // The starting offset of the channel bytecode (relative to the start of the song data).
    //
    // If `starting+songPtr` overflows (ie, starting >= 0xff00), then the channel is disabled.
    starting : u16,

    // The loop point in the channel bytecode (relative to the start of the song data).
    //
    // If `loop+songPtr` overflows (ie, loop >= 0xff00), then the channel will not loop.
    loop: u16,
};

// Size MUST match `audio/driver_constants.py`
struct SongHeader {
    channels : [MusicChannelHeader ; N_MUSIC_CHANNELS],


    // Length of a tick in 1/8000 cycles (song tempo).
    //
    // MUST BE >= MIN_TICK_CLOCK
    tickTimer : u8,


    // Number of subroutines
    // NOTE: This variable has a maximum value of 128.
    // (This variable must be the last field in the SongHeader).
    nSubroutines : u8,

    // Immediately after this header is an array, [u16 ; nSubroutines], containing the location of each subroutine
    // (relative to the start of the song data).
    // The audio-engine will convert the locations into addresses before starting the event-loop.
};

extern const external_data @ COMMON_DATA_ADDR : ExternalData;



// MUST match `src/audio.wiz`
namespace IO {
    // The audio-driver MUST NOT use IO port 3 (without rewriting the loader).
    //
    // Port 3 is used by the loader to signal to the S-CPU that the loader is running.

    extern const command_id  @ &smp.io_port_in_0 : u8;
    extern writeonly command_id_ack @ &smp.io_port_out_0 : u8;

    extern const command @ &smp.io_port_in_1 : u8;
}


// MUST match `audio/src/audio-driver.wiz`
enum IoCommand : u8 {
    // commands 0-127: Play sound effect.

    // ::TODO add a few 'EXECUTE_LOADER' checks in the bytecode::
    // ::: Prevent an infinite loop in the bytecode from deadlocking the S-CPU code::
    EXECUTE_LOADER = 0x80 | 'L',
};



// Variables
// =========


in zeropage {
    // Temporary variables
    var zpTmp : u8;


    // The previous IO port command_id
    var previousCommandId : u8;


    // The table of subroutine addresses
    var subroutineTable : **const u8;

    // Maximum value of the timer counter_0 or counter_1 register.
    var maxTimerCounter : u8;


    // Shadow variables for KON and KOFF DSP registers
    var keyOffShadow : u8;
    var keyOnShadow : u8;


    // `keyOnShadow` mask.
    //
    // Each bit determines the KON/KOFF state of each channel.
    //  * If set - the next play note instruction will set `keyOnShadow`.
    //  * If clear - the channel is playing something and the play note instruction will
    //               leave `keyOnShadow` unchanged (slurring the note).
    //
    // The bits are set on `KON` and cleared on `KOFF`, at the start of `process_event_loop()`.
    //
    // (8x bitfield)
    var keyOnMask : u8;


    // Only valid inside bytecode instructions
    var instructionPtr : *const u8;

    // Index into channelSoA for the current channel.
    // Used to restore X index inside bytecode instructions.
    // Only valid inside bytecode instructions
    // MUST ONLY be set by `process_bytecode__inline()`.
    var currentChannelIndex : u8;


    // The one-past-the-end index when looping through the channels.
    //
    // Used to deduplicate code when processing music and sound effects.
    //
    // MUST ONLY BE USED IN `process_event_loop__inline()`
    var channelIndexEndLoop : u8;


    namespace channelSoA {
        // If non-zero, the channel is disabled.
        // (Used to determine which channel to play a sound effect on)
        var disabled : [u8 ; N_CHANNELS];

        // Counter (in ticks) until the event
        var countdownTimer : [u8 ; N_CHANNELS];

        // If non-zero, the next event is a key-off event
        // If zero, the next event will process bytecode
        var nextEventIsKeyOff : [u8 ; N_CHANNELS];


        // Default note length (in ticks)
        var defaultNoteLength : [u8 ; N_CHANNELS];


        // The address of the next bytecode to execute
        var instructionPtr_l : [u8 ; N_CHANNELS];
        var instructionPtr_h : [u8 ; N_CHANNELS];

        // Bytecode address to loop to when the channel encounters and `end` instruction.
        // If `instructionPtrAfterEnd_h` is 0, the channel does not loop and will instead stop.
        var instructionPtrAfterEnd_l : [u8 ; N_CHANNELS];
        var instructionPtrAfterEnd_h : [u8 ; N_CHANNELS];


        // Address to return to in a `return_from_subroutine` bytecode
        var returnInstPtr_l : [u8 ; N_CHANNELS];
        var returnInstPtr_h : [u8 ; N_CHANNELS];


        struct LoopState {
            counter : [u8 ; N_CHANNELS],

            // Instruction pointer at the start of the loop.
            loopPoint_l : [u8 ; N_CHANNELS],
            loopPoint_h : [u8 ; N_CHANNELS],
        };
        var loopState : [LoopState ; 2];


        // NOTE: Pitch table variable MUST NOT be modified directly.
        // Use the `__set_pt_offset()` and `__add_to_pt_offset()` to edit the offset variables.

        // Offset between the `u4` note to play and the pitch table.
        //
        // Equal to `instPitchOffset + octaveOffset + transposeOffset` (wrapping on overflow).
        //
        // NOTE: Adding `pitchTableOffset` to the note to play is allowed to an can overflow.
        var pitchTableOffset : [u8 ; N_CHANNELS];

        // Offset between the note to play and the pitch table.
        //
        // NOTE: Adding `instPitchOffset` to the note to play is allowed to an can overflow.
        var instPitchOffset : [u8 ; N_CHANNELS];

        // Offset (in semitones) between the note to play and the current octave.
        //
        // Equal to `octave * 12`
        var octaveOffset : [u8 ; N_CHANNELS];

        // Offset (in semitones) to add to the current note.
        //
        // NOTE: This is a `i8` variable.
        // Using u8 here so I can use this variable with `__set_pt_offset()` and `__add_to_pt_offset().
        var semitoneOffset : [u8 ; N_CHANNELS];
    }

    // Used for testing sound effects
    var _countdownToNextSfx : u16;
    var _sfxToPlay : u8;
}



// Macros
// ======

// KEEP: a, x, y
inline func write_dsp(addr : GlobalDspAddr in a, data : u8 in y) {
    smp.dsp_addr_and_data = ya;
}



// Set a semitone offset variable and update the pitchTableOffset.
//
// KEEP: X
//
// MUST NOT USE `zpTmp`
inline func __set_pt_offset(channelIndex : u8 in x, st_offset : u8 in a, let SOA_VAR : [u8 ; N_CHANNELS]) {
    y = a;

    channelSoA.pitchTableOffset[x] = a = a + channelSoA.pitchTableOffset[x] - SOA_VAR[x];
    SOA_VAR[x] = y;
}



// Add an `i8` semitone offset to an offset variable and the pitchTableOffset.
//
// KEEP: X
inline func __add_to_pt_offset(channelIndex : u8 in x, st_offset : i8 in a, let SOA_VAR : [u8 ; N_CHANNELS]) {
    y = a;

    channelSoA.pitchTableOffset[x] = a = a + channelSoA.pitchTableOffset[x];

    SOA_VAR[x] = a = y + SOA_VAR[x];
}



// Code
// ====

in code {

// MUST be the first thing in the `code` bank (so the starting address is consistent across builds).
func main() {
var _loopEnd : u8 in zpTmp;


    sp = x = 0xff;

    // Reset the DSP
    write_dsp(GlobalDspAddr.FLG,    dsp.FLG__SOFT_RESET | dsp.FLG__MUTE_ALL | dsp.FLG__ECHO_DISABLE);

    write_dsp(GlobalDspAddr.KOFF,   0xff);  // all keys off

    y = 0;
    write_dsp(GlobalDspAddr.EFB,    y);     // No echo feedback
    write_dsp(GlobalDspAddr.PMON,   y);     // No pitch modulation
    write_dsp(GlobalDspAddr.NON,    y);     // No noise
    write_dsp(GlobalDspAddr.EON,    y);     // No echo


    // Set main volume to full volume
    y = 0x7f;
    write_dsp(GlobalDspAddr.MVOL_L, y);
    write_dsp(GlobalDspAddr.MVOL_R, y);

    y = 0;
    write_dsp(GlobalDspAddr.EVOL_L, y);
    write_dsp(GlobalDspAddr.EVOL_R, y);



    // Set directory table
    write_dsp(GlobalDspAddr.DIR, >:&external_data.brrDirectory[0]);


    // Unmute the audio (keep echo disabled)
    write_dsp(GlobalDspAddr.FLG,    dsp.FLG__ECHO_DISABLE);


    // Clear all zero-page variables before `songPtr`.
    // Assumes `songPtr` is AFTER `zeropage` bank.
    a = 0;
    x = &songPtr as u8;
    do {
        x--;
        (0 as *u8)[x] = a;
    } while !zero;


    // Disable SFX channels
    a = <:&ChannelDisabledBytecode;
    y = >:&ChannelDisabledBytecode;
    inline for let i in N_MUSIC_CHANNELS..7 {
        channelSoA.instructionPtr_l[i] = a;
        channelSoA.instructionPtr_h[i] = y;

        // y is non-zero
        channelSoA.disabled[i] = y;
    }


    // Calculate the subroutineTable address.
    a = sizeof(SongHeader);
    y = 0;
    ya += songPtr as u16;
    subroutineTable = ya as **const u8;

    // Add songPtr to each element in the subroutine table, turning an offset into an address.
    y = offsetof(SongHeader, nSubroutines);
    a = songPtr[y];
    if !zero {
        _loopEnd = a = a << 1;
        y = 0;
        do {
            (subroutineTable as *u8)[y] = a = (subroutineTable as *u8)[y] + <:songPtr;
            y++;
            (subroutineTable as *u8)[y] = a = (subroutineTable as *u8)[y] +# >:songPtr;
            y++;
        } while y != _loopEnd;
    }


    // Reset all music channels
    x = N_MUSIC_CHANNELS - 1;
    do {
        __reset_channel(x);

        // ASSUMES offsetof(SongHeader, channels) == 0
        // ASSUMES sizeof(MusicChannelHeader) == 4
        y = a = x <<< 2;

        // Calculate instructionPtr (and setting it to `ChannelDisabledBytecode` if the addition overflows)
        channelSoA.instructionPtr_l[x] = a = songPtr[y] + <:songPtr;
        y++;
        a = songPtr[y] +# >:songPtr;
        if carry {
            channelSoA.instructionPtr_l[x] = a = <:&ChannelDisabledBytecode;
            a = >:&ChannelDisabledBytecode;
        }
        channelSoA.instructionPtr_h[x] = a;
        y++;

        // Calculate endInstPtr (and set the high byte to 0 (no looping) if the addition overflows)
        channelSoA.instructionPtrAfterEnd_l[x] = a = songPtr[y] + <:songPtr;
        y++;
        a = songPtr[y] +# >:songPtr;
        if carry {
            a = 0;
        }
        channelSoA.instructionPtrAfterEnd_h[x] = a;

        x--;
    } while !negative;


    init_io_ports__inline();


    // Setup and enable the timers
    y = offsetof(SongHeader, tickTimer);
    smp.timer_0 = a = songPtr[y];

    smp.timer_1 = SFX_TICK_CLOCK;
    smp.control = smp.CONTROL__ENABLE_TIMER_0 | smp.CONTROL__ENABLE_TIMER_1;

    // Reset counters to ensure `maxTimerCounter` is accurate
    a = smp.counter_0;
    a = smp.counter_1;

    ^while true {
        process_event_loop__inline();
    }
}



inline func process_event_loop__inline() {
    // Loop until a timer has ticked
    ^while true {
        // Song tick timer
        a = smp.counter_0;
        if !zero {
            if a >= maxTimerCounter {
                maxTimerCounter = a;
            }

            __update_kon_koff__inline(SONG_CHANNEL_MASK);

            x = 0;
            y = N_MUSIC_CHANNELS;

            break;
        }

        // SFX tick timer
        a = smp.counter_1;
        if !zero {
            if a >= maxTimerCounter {
                maxTimerCounter = a;
            }

            __update_kon_koff__inline(SFX_CHANNEL_MASK);

            x = N_MUSIC_CHANNELS;
            y = N_CHANNELS;

            break;
        }
    }


    // X = starting channelIndex
    // Y = channelIndex end (starting channelIndex + number of channels)

    channelIndexEndLoop = y;
    do {
        process_channel__inline(x);
        x++;
    } while x < channelIndexEndLoop;


    process_io_ports__inline();
}



// Set the KON/KOFF/keyOnMask bits for the music or sound effects (depending on MASK value).
//
// This code is a bit messy, but it satisfies all of my requirements:
//
//  * KON/KOFF set immediately after timer has ticked (NOT after process_channel loop)
//    to reduce jitter in the KON/KOFF timings
//
//  * Music and Sound effects send KON and KOFF according to two different timer clocks.
//
//  * Separates the music and sfx channel bits in `keyOnShadow` and `keyOffShadow` while still
//    still reusing the process_channel loop and bytecode instruction code for music and sfx.
//
//  * Separates music and sfx channel bits without adding a music/sfc conditional to the end of
//    the process_channel loop or bytecode instructions.
inline func __update_kon_koff__inline(let MASK : u8) {
    a = keyOffShadow & MASK;
    // Enable KON in play-note instructions
    test_and_set(a, keyOnMask);

    // Send KOFF events
    y = a;
    write_dsp(GlobalDspAddr.KOFF, y);


    a = keyOnShadow & MASK;
    // Disable KON in play-note instructions (slur the note)
    test_and_clear(a, keyOnMask);

    // Send KON events
    y = a;
    write_dsp(GlobalDspAddr.KON, y);


    // Clear keyOnShadow and keyOffShadow
    keyOnShadow &= (0xff ^ MASK);
    keyOffShadow &= (0xff ^ MASK);
}


// IO Ports
// ========

inline func init_io_ports__inline() {
    // Wait until CPU ready
    do {
        a = IO.command_id;
    } while !zero;

    IO.command_id_ack = a;
    previousCommandId = a;
}


inline func process_io_ports__inline() {
    // Test if `IO.command_id` has changed.
    // If S-CPU writes to `command_id` at the same time S-SMP reads `command_id`, `command_id` will contain invalid data.
    // We do not care about the value of `command_id` at this point in time, we only care if it has changed.
    x = IO.command_id;
    if x != previousCommandId {
        // There is a new command from the S-CPU

        // Get command from S-CPU
        a = IO.command;

        // Acknowledge command
        // Read `IO.command_id` a second time to ensure the correct value is read.
        // This should be safe.  The S-CPU will not write to `IO.command_id` until it has been acknowledged.
        // ::TODO stress test `command_id`::
        x = IO.command_id;
        IO.command_id_ack = x;
        previousCommandId = x;

        // Assumes N_SOUND_EFFECTS == 128
        y = a;
        if negative {
            if a == IoCommand.EXECUTE_LOADER as u8 {
                ^goto (LOADER_ADDR as func);
            }
        }
        else {
            // Play sound effect command
            play_sound_effect__inline(a);
        }
    }
}


// ASSUMES: sfx_id < N_SOUND_EFFECTS (128)
inline func play_sound_effect__inline(sfx_id : u8 in x) {
    y = a = external_data.soundEffects_h[x];
    if !zero {
        a = external_data.soundEffects_l[x];

        inline for let i in N_MUSIC_CHANNELS..7 {
            x = channelSoA.disabled[i];
            if !zero {
                x = i;
                __play_sfx_on_channel(x, ya);
                return;
            }
        }
    }
}


// KEEP: X
#[fallthrough]
func __play_sfx_on_channel(channelIndex : u8 in x, sfxBytecode : u16 in ya) {
    channelSoA.instructionPtr_l[x] = a;
    channelSoA.instructionPtr_h[x] = y;

// Fallthrough
}

// NOTE: Does not set:
//  * channelSoA.instructionPtr
//
// NOTE: Also disables looping.
//
// KEEP: X
func __reset_channel(channelIndex : u8 in x) {
    // Immediately process the next event
    channelSoA.countdownTimer[x] = a = 1;

    // A = 0
    a = 0;
    channelSoA.instructionPtrAfterEnd_h[x] = a;     // don't loop SFX

    channelSoA.disabled[x] = a;
    channelSoA.nextEventIsKeyOff[x] = a;
    channelSoA.instPitchOffset[x] = a;
    channelSoA.semitoneOffset[x] = a;

    a = STARTING_OCTAVE * 12;
    channelSoA.octaveOffset[x] = a;
    channelSoA.pitchTableOffset[x] = a;

    channelSoA.defaultNoteLength[x] = a = STARTING_DEFAULT_NOTE_LENGTH;


    // Set keyOnMask.  The next play-note instruction will queue a KON event.
    a = ChannelVoiceBit[x];
    test_and_set(a, keyOnMask);


    // Reset channel volume
    y = STARTING_CHANNEL_VOLUME;

    // ASSUMES VoiceDspAddr.VOL_L == 0
    smp.dsp_addr = a = ChannelVoiceOffset[x];
    smp.dsp_data = y;

    smp.dsp_addr++;
    smp.dsp_data = y;
}



// Process Channels
// ================


// KEEP: X
inline func process_channel__inline(channelIndex : u8 in x) {

    channelSoA.countdownTimer[x]--;
    if zero {
        // Check if a KEY_OFF is required
        a = channelSoA.nextEventIsKeyOff[x];
        if !zero {
            a = ChannelVoiceBit[x];
            test_and_set(a, keyOffShadow);

            // schedule a bytecode event
            channelSoA.nextEventIsKeyOff[x] = a = 0;

            // Previous countdownTimer value was 0
            channelSoA.countdownTimer[x]++;
        }
        else {
            currentChannelIndex = x;

            a = channelSoA.instructionPtr_l[x];
            y = channelSoA.instructionPtr_h[x];

            process_bytecode(x, ya);

            x = currentChannelIndex;

            ya = instructionPtr as u16;
            channelSoA.instructionPtr_l[x] = a;
            channelSoA.instructionPtr_h[x] = y;
        }
    }
}


// Process Bytecode
// ================


// Set the bytecode `instructionPtr` and execute the next bytecode instruction.
// KEEP: X
#[fallthrough]
func process_bytecode(channelIndex : u8 in x, addr : u16 in ya) {
    instructionPtr = ya as *const u8;

// Fallthrough
}


// Execute the next bytecode instruction
//
// KEEP: X
func process_next_bytecode(channelIndex : u8 in x) {
    y = 0;
    a = instructionPtr[y];
    instructionPtr++;

    if a < sizeof(typeof(bytecode.ByteInstructions_l)) {
        y = a;
        // Set address of the instruction using self-modifying code
        // (If I used the `JMP [!abs+X]` it would have clobbered `X` and cost be ~80 bytes to do a `x = _currentChannelIndex` on every instruction).
        (&JumpInstruction as *u8)[1] = a = bytecode.ByteInstructions_l[y];
        (&JumpInstruction as *u8)[2] = a = bytecode.ByteInstructions_h[y];

        if y < bytecode.N_SINGLE_ARGUMENT_INSTRUCTIONS {
            // Instruction has a parameter
            y = 0;
            a = instructionPtr[y];
            instructionPtr++;
        }

        // Have to use `^goto` here, `^return` outputs a `BRA` instruction.
    JumpInstruction:
        ^goto bytecode.null_instruction;
    }
    else {
        x = a;

        a &= 0b11100000;
        swap_digits(a);
        y = a;

        // Y = instruction_index * 2

        // Set address of the instruction using self-modifying code
        (&JumpInstruction as *u8)[1] = a = (&<:bytecode.InlineArgumentInstructions[0] as *const u8)[unaligned y];
        (&JumpInstruction as *u8)[2] = a = (&>:bytecode.InlineArgumentInstructions[0] as *const u8)[unaligned y];

        a = x & bytecode.INLINE_ARGUMENT_MASK;
        x = currentChannelIndex;

        // Have to use `^goto` here, `^return` outputs a `BRA` instruction.
    JumpInstruction:
        ^goto bytecode.null_instruction;
    }
}



// NOTE: BYTECODE INSTRUCTIONS MUST KEEP X
//
// Bytecode instruction must either:
//    * Return after setting `channelSoA.nextEvent_*` (to start sleeping)
//    * Jump to `process_next_bytecode` to execute the next bytecode instruction
//    * Jump to `process_bytecode` to change the bytecode instruction pointer and execute it.
//
namespace bytecode {

const ByteInstructions_l : [ u8 ; 1 << 5 ] = [ <:&f for let f in SINGLE_ARGUMENT_INSTRUCTIONS ]
                                           ~ [ <:&f for let f in NO_PARAMETER_INSTRUCTIONS ];

const ByteInstructions_h : [ u8 ; 1 << 5 ] = [ >:&f for let f in SINGLE_ARGUMENT_INSTRUCTIONS ]
                                           ~ [ >:&f for let f in NO_PARAMETER_INSTRUCTIONS ];

const InlineArgumentInstructions : [ func(u8 in x, u8 in y) ; 1 << 3 ] = INLINE_ARGUMENT_INSTRUCTIONS;


let null_instruction = disable_channel as func(u8 in x, u8 in a);



// KEEP: X
func disable_channel(channelIndex : u8 in x) {
    // countdownTimer value of 0 means wait 256 ticks
    channelSoA.countdownTimer[x] = a = 0;

    channelSoA.disabled[x] = a = 1;

    a = <:&ChannelDisabledBytecode;
    y = >:&ChannelDisabledBytecode;
    instructionPtr = ya as *const u8;

    // return (do not execute the next bytecode and sleep)
    return;
}


// KEEP: X
func end(channelIndex : u8 in x) {
    y = channelSoA.instructionPtrAfterEnd_h[x];
    goto disable_channel if zero;

    a = channelSoA.instructionPtrAfterEnd_l[x];

    ^return process_bytecode(x, ya);
}


// KEEP: X
func call_subroutine(channelIndex : u8 in x, subroutineId : u8 in a) {
var _subroutineId : u8 in zpTmp;

    _subroutineId = a;

    // Save return address
    ya = instructionPtr as u16;
    channelSoA.returnInstPtr_l[x] = a;
    channelSoA.returnInstPtr_h[x] = y;

    y = a = _subroutineId <<< 1;

    <:instructionPtr = a = (subroutineTable as *u8)[y];
    y++;
    >:instructionPtr = a = (subroutineTable as *u8)[y];

    ^return process_next_bytecode(x);
}


// KEEP: X
func return_from_subroutine(channelIndex : u8 in x) {
    a = channelSoA.returnInstPtr_l[x];
    y = channelSoA.returnInstPtr_h[x];

    ^return process_bytecode(x, ya);
}


// KEEP: X
inline func __start_loop(channelIndex : u8 in x, let LOOP_ID : u8) {
    ya = instructionPtr as u16;

    channelSoA.loopState[LOOP_ID].loopPoint_l[x] = a;
    channelSoA.loopState[LOOP_ID].loopPoint_h[x] = y;

    channelSoA.loopState[LOOP_ID].counter[x] = a = 0;

    ^return process_next_bytecode(x);
}


// KEEP: X
inline func __end_loop(channelIndex : u8 in x, loopCount : u8 in a, let LOOP_ID : u8) {
    if a >= channelSoA.loopState[LOOP_ID].counter[x] {
        channelSoA.loopState[LOOP_ID].counter[x]++;

        a = channelSoA.loopState[LOOP_ID].loopPoint_l[x];
        y = channelSoA.loopState[LOOP_ID].loopPoint_h[x];

        ^return process_bytecode(x, ya);
    }
    ^return process_next_bytecode(x);
}


// KEEP: X
func start_loop_0(channelIndex : u8 in x) {
    return __start_loop(x, 0);
}

// KEEP: X
func start_loop_1(channelIndex : u8 in x) {
    return __start_loop(x, 1);
}


// KEEP: X
func end_loop_0(channelIndex : u8 in x, loopCount : u8 in a) {
    return __end_loop(x, a, 0);
}

// KEEP: X
func end_loop_1(channelIndex : u8 in x, loopCount : u8 in a) {
    return __end_loop(x, a, 1);
}



func set_instrument(channelIndex : u8 in x, instrumentId : u8 in a) {
    // Using addr,y addressing mode for `channels`, 1 cycle faster then transferring y to x.

    y = a = a & INSTRUMENT_MASK;

    smp.dsp_addr = a = ChannelVoiceOffset[x] | VoiceDspAddr.SCRN as u8;
    smp.dsp_data = a = external_data.instruments.scrn[y];

    smp.dsp_addr++;
    smp.dsp_data = a = external_data.instruments.adsr1[y];

    smp.dsp_addr++;
    smp.dsp_data = a = external_data.instruments.adsr2[y];

    smp.dsp_addr++;
    smp.dsp_data = a = external_data.instruments.gain[y];

    a = external_data.instruments.pitchOffset[y];
    __set_pt_offset(x, a, channelSoA.instPitchOffset);

    ^return process_next_bytecode(x);
}



// ASSUMES: parameter is 5 bits
// KEEP: X
func change_octave(channelIndex : u8 in x, parameter : u8 in a) {
    y = a = a >>>= 1;
    if carry {
        // relative octave change

        a = OctaveTable[y] as u8;
        __add_to_pt_offset(x, a as i8, channelSoA.octaveOffset);

        ^return process_next_bytecode(x);
    }
    else {
        // Set octave

        a = OctaveTable[y] as u8;
        __set_pt_offset(x, a, channelSoA.octaveOffset);

        ^return process_next_bytecode(x);
    }
}

const OctaveTable : [i8 ; 16] = [i * 12 for let i in -6..9];



// KEEP: X
func set_semitone_offset(channelIndex : u8 in x, parameter : i8 in a) {
    __set_pt_offset(x, a, channelSoA.semitoneOffset);

    ^return process_next_bytecode(x);
}



// KEEP: X
func relative_semitone_offset(channelIndex : u8 in x, parameter : i8 in a) {
    __add_to_pt_offset(x, a as i8, channelSoA.semitoneOffset);

    ^return process_next_bytecode(x);
}



// KEEP: X
func set_channel_volume(channelIndex : u8 in x, volume : u8 in a) {
    y = a;

    // ASSUMES VoiceDspAddr.VOL_L == 0
    smp.dsp_addr = a = ChannelVoiceOffset[x];
    smp.dsp_data = y;

    smp.dsp_addr++;
    smp.dsp_data = y;

    ^return process_next_bytecode(x);
}



// KEEP: X
func set_adsr(channelIndex: u8 in x, adsr1 : u8 in a) {
    y = a;

    smp.dsp_addr = a = ChannelVoiceOffset[x] | VoiceDspAddr.ADSR1 as u8;
    smp.dsp_data = y;

    y = 0;
    a = instructionPtr[y];

    // Set ADSR2
    smp.dsp_addr++;
    smp.dsp_data = a;

    instructionPtr++;

    ^return process_next_bytecode(x);
}



// KEEP: X
func set_gain(channelIndex: u8 in x, gain : u8 in a) {
    y = a;

    smp.dsp_addr = a = ChannelVoiceOffset[x] | VoiceDspAddr.GAIN as u8;
    smp.dsp_data = y;

    // clear ADSR1 enable bit
    // ASSUMES: VoiceDspAddr.GAIN - VoiceDspAddr.ADSR1 == 1 << 1
    smp.dsp_addr $ 1 = false;
    smp.dsp_data $ dsp.ADSR1_ENABLE_BIT = false;

    ^return process_next_bytecode(x);
}



// KEEP: x
func play_specific_note(channelIndex : u8 in x, noteAndKeyOffBit : u8 in a) {
    // carry = key-off after note ends bit
    a >>>= 1;

    // Set MSB of nextEventIsKeyOff to carry
    channelSoA.nextEventIsKeyOff[x] >>>>#= 1;

    // Calculate pitch table index
    a += channelSoA.instPitchOffset[x];

    ^return __play_pitch(x, a);
}



// KEEP: x
#[fallthrough]
func play_note(channelIndex : u8 in x, noteAndKeyOffBit : u8 in a) {
    // carry = key-off after note ends bit
    a >>>= 1;

    // Set MSB of nextEventIsKeyOff to carry
    channelSoA.nextEventIsKeyOff[x] >>>>#= 1;

    // calculate pitch table index
    a = a + channelSoA.pitchTableOffset[x];

// Fallthrough
}


// KEEP: x
func __play_pitch(channelIndex : u8 in x, pitchTableIndex : u8 in a) {

    y = a;

    // Set voice pitch
    smp.dsp_addr = a = ChannelVoiceOffset[x] | VoiceDspAddr.PITCH_L as u8;
    smp.dsp_data = a = external_data.pitchTable_l[y];

    smp.dsp_addr++;
    smp.dsp_data = a = external_data.pitchTable_h[y];


    // queue KON if the previous note has been KOFFed
    a = ChannelVoiceBit[x] & keyOnMask;
    test_and_set(a, keyOnShadow);


    a = channelSoA.defaultNoteLength[x];

    // Subtract the key-off delay from countdownTimer if the `key-off` bit is set.
    y = channelSoA.nextEventIsKeyOff[x];
    if negative {
        a--;
    }
    channelSoA.countdownTimer[x] = a;

    // return (do not execute the next bytecode and sleep)
    return;
}



// KEEP: x
func play_specific_note_length(channelIndex : u8 in x, noteAndKeyOffBit : u8 in a) {
    // carry = key-off after note ends bit
    a >>>= 1;

    // Set MSB of nextEventIsKeyOff to carry
    channelSoA.nextEventIsKeyOff[x] >>>>#= 1;

    // calculate pitch table index
    a += channelSoA.instPitchOffset[x];

    ^return __play_pitch_length(x, a);
}



// KEEP: x
#[fallthrough]
func play_note_length(channelIndex : u8 in x, noteAndKeyOffBit : u8 in a) {
    // carry = key-off after note ends bit
    a >>>= 1;

    // Set MSB of nextEventIsKeyOff to carry
    channelSoA.nextEventIsKeyOff[x] >>>>#= 1;

    a += channelSoA.pitchTableOffset[x];

// Fallthrough
}


// KEEP: X
#[fallthrough]
func __play_pitch_length(channelIndex : u8 in x, pitchTableIndex : u8 in a) {
    y = a;

    // Set voice pitch
    smp.dsp_addr = a = ChannelVoiceOffset[x] | VoiceDspAddr.PITCH_L as u8;
    smp.dsp_data = a = external_data.pitchTable_l[y];

    smp.dsp_addr++;
    smp.dsp_data = a = external_data.pitchTable_h[y];


    // queue KON if the previous note has been KOFFed
    a = ChannelVoiceBit[x] & keyOnMask;
    test_and_set(a, keyOnShadow);


    // Get note length from the next byte in the instructionPtr
    y = 0;
    a = instructionPtr[y];
    instructionPtr++;

// Fallthrough
}



// KEEP: x
func rest(channelIndex : u8 in x, length: u8 in a) {
    channelSoA.countdownTimer[x] = a;

    // return (do not execute the next bytecode and sleep)
    return;
}

}

}



// Data Tables
// ===========

// Using the `code` bank so the data is included in `audio-driver.bin`
in code {
    // The bit used for global DSP registers (KON, KOFF, NON, EON, etc)
    const ChannelVoiceBit : [u8; 8] = [1 << i for let i in 0..7];

    // The offset into the Voice DSP registers
    const ChannelVoiceOffset : [u8; 8] = [i * 0x10 for let i in 0..7];


    // This is the bytecode used by a disabled channel.
    const ChannelDisabledBytecode : [ u8; 1 ] = [ bytecode.DISABLE_CHANNEL_BYTECODE ];
}

import "bytecode";

