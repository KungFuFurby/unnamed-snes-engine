// Copyright (c) 2023, Marcus Rowe <undisbeliever@gmail.com>.
// Distributed under The MIT License, see the LICENSE file for more details.


// The minimum timer value required to ensure Key-Off event completely silences the sample before
// the next note plays.
let MIN_TICK_CLOCK = 64;


// The tempo (timer register value) for the sound effects
// MUST BE >= MIN_TICK_CLOCK
let SFX_TICK_CLOCK = 64;


let N_CHANNELS = 8;
let N_MUSIC_CHANNELS = 6;
let N_SFX_CHANNELS = N_CHANNELS - N_MUSIC_CHANNELS;

let SONG_CHANNEL_MASK = (1 << N_MUSIC_CHANNELS) - 1;
let SFX_CHANNEL_MASK = SONG_CHANNEL_MASK ^ 0xff;


let N_BRR_SAMPLES   = 64;
let N_INSTRUMENTS   = 64;
let N_SOUND_EFFECTS = 128;


let INSTRUMENT_MASK = N_INSTRUMENTS - 1;
let SOUND_EFFECT_MASK = N_SOUND_EFFECTS - 1;


let STARTING_VOLUME = 96;



// Common Data
// ===========

struct DirItem {
    start : *const u8,
    loop  : *const u8
};

struct InstrumentsSoA {
    scrn            : [u8 ; N_INSTRUMENTS],
    adsr1           : [u8 ; N_INSTRUMENTS],

    // This variable is either:
    //   * ADSR2 if bit 7 of `adsr1` is set
    //   * GAIN if bit 7 of `adsr1` is clear
    adsr2OrGain     : [u8 ; N_INSTRUMENTS],

    // offset between note c0 and `ExternalData.pitchTable[0]`
    // (pitchOffset + note is allowed to overflow and underflow)
    pitchOffset    : [u8 ; N_INSTRUMENTS],
};

struct ExternalData {
    brrDirectory   : [DirItem ; N_BRR_SAMPLES],

    pitchTable_l   : [u8; 256],
    pitchTable_h   : [u8; 256],

    instruments    : InstrumentsSoA,

    // The address of the sound effect bytecode.
    soundEffects_l : [u8; N_SOUND_EFFECTS],
    soundEffects_h : [u8; N_SOUND_EFFECTS],
};



// Song Data
// =========

struct MusicChannelHeader {
    // The starting offset of the channel bytecode (relative to the start of the song data).
    //
    // If `starting+songPtr` overflows (ie, starting >= 0xff00), then the channel is disabled.
    starting : u16,

    // The loop point in the channel bytecode (relative to the start of the song data).
    //
    // If `loop+songPtr` overflows (ie, loop >= 0xff00), then the channel will not loop.
    loop: u16,
};

struct EchoBufferSettings {

    // 4-bit echo buffer size.
    //
    // The echo buffer is `2048 * edl` bytes in size and `16ms * edl` in length.
    //
    // NOTE: An edl value of 0 allocates 2048 bytes of RAM to the echo buffer.
    //
    // NOTE: There is no echo buffer overflow checking.
    //       The echo buffer may clobber song/sample/sfx data if `edl` is too large.
    edl : u8,

    // FIR filter.  Written to the `C0`-`C7` S-DSP registers.
    firFilter : [i8 ; 8],

    // Echo feedback.  Written to the `EFB` S-DSP register.
    echoFeedback : i8,

    // Echo volume.  Written to the `EVOL_L` and `EVOL_R` S-DSP registers.
    echoVolume : i8,
}

// Size MUST match `audio/driver_constants.py`
struct SongHeader {
    channels : [MusicChannelHeader ; N_MUSIC_CHANNELS],


    echo: EchoBufferSettings,


    // Length of a tick in 1/8000 cycles (song tempo).
    //
    // MUST BE >= MIN_TICK_CLOCK
    tickTimer : u8,

    // Number of subroutines
    // NOTE: This variable has a maximum value of 128.
    // (This variable must be the last field in the SongHeader).
    nSubroutines : u8,

    // Immediately after this header is an array, [u16 ; nSubroutines], containing the location of each subroutine
    // (relative to the start of the song data).
    // The audio-engine will convert the locations into addresses before starting the event-loop.
};


