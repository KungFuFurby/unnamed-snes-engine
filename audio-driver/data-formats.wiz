// Copyright (c) 2023, Marcus Rowe <undisbeliever@gmail.com>.
// Distributed under The MIT License, see the LICENSE file for more details.


// The minimum timer value required to ensure Key-Off event completely silences the sample before
// the next note plays.
let MIN_TICK_CLOCK = 64;


// The tempo (timer register value) for the sound effects
// MUST BE >= MIN_TICK_CLOCK
let SFX_TICK_CLOCK = 64;


let N_CHANNELS = 8;
let N_MUSIC_CHANNELS = 6;
let N_SFX_CHANNELS = N_CHANNELS - N_MUSIC_CHANNELS;

let SONG_CHANNEL_MASK = (1 << N_MUSIC_CHANNELS) - 1;
let SFX_CHANNEL_MASK = SONG_CHANNEL_MASK ^ 0xff;

let STARTING_VOLUME = 96;

// The first valid SCRN value
let STARTING_SCRN = 1;

let MAX_DIR_ITEMS = 0x100 - STARTING_SCRN;
let MAX_INSTRUMENTS = 0x100;
let MAX_SOUND_EFFECTS = 192;



// Common Data
// ===========

struct DirItem {
    start : *const u8,
    loop  : *const u8
};

struct CommonDataHeader {
    pitchTable_l   : [u8; 256],
    pitchTable_h   : [u8; 256],

    // MUST BE <= MAX_DIR_ITEMS
    nDirItems      : u8,

    nInstruments   : u8,

    // MUST BE <= MAX_SOUND_EFFECTS
    nSoundEffects  : u8,

    _padding       : u8,


    // After the header is common data.

    //  BRR Directory:  [DirItem ; nDirItems]
    //
    //      NOTE: The first valid SCRN value is 1.
    //          SCRN value 0 is invalid.

    //  Instruments SoA
    //      instrument_scrn        : [u8 ; nInstruments]
    //
    //      instrument_pitchOffset : [u8 ; nInstruments]
    //          This variable is either:
    //              * ADSR2 if bit 7 of `adsr1` is set
    //              * GAIN if bit 7 of `adsr1` is clear
    //
    //          instrument_adsr1       : [u8 ; nInstruments]
    //
    //          instrument_adsr2OrGain ; [u8 ; nInstruments]
    //              offset between note c0 and `CommonDataHeader.pitchTable[0]`
    //              (pitchOffset + note is allowed to overflow and underflow)

    //  Sound Effects SoA
    //      soundEffects_l : [u8 ; nSoundEffects]
    //      soundEffects_h : [u8 ; nSoundEffects]
    //          The address of the sound effect bytecode.
};



// Song Data
// =========

struct MusicChannelHeader {
    // The starting offset of the channel bytecode (relative to the start of the song data).
    //
    // If `starting+songPtr` overflows (ie, starting >= 0xff00), then the channel is disabled.
    starting : u16,

    // The loop point in the channel bytecode (relative to the start of the song data).
    //
    // If `loop+songPtr` overflows (ie, loop >= 0xff00), then the channel will not loop.
    loop: u16,
};

struct EchoBufferSettings {

    // 4-bit echo buffer size.
    //
    // The echo buffer is `2048 * edl` bytes in size and `16ms * edl` in length.
    //
    // NOTE: An edl value of 0 allocates 2048 bytes of RAM to the echo buffer.
    //
    // NOTE: There is no echo buffer overflow checking.
    //       The echo buffer may clobber song/sample/sfx data if `edl` is too large.
    edl : u8,

    // FIR filter.  Written to the `C0`-`C7` S-DSP registers.
    firFilter : [i8 ; 8],

    // Echo feedback.  Written to the `EFB` S-DSP register.
    echoFeedback : i8,

    // Echo volume.  Written to the `EVOL_L` and `EVOL_R` S-DSP registers.
    echoVolume : i8,
}

// Size MUST match `audio/driver_constants.py`
struct SongHeader {
    channels : [MusicChannelHeader ; N_MUSIC_CHANNELS],


    echo: EchoBufferSettings,


    // Length of a tick in 1/8000 cycles (song tempo).
    //
    // MUST BE >= MIN_TICK_CLOCK
    tickTimer : u8,

    // Number of subroutines
    // NOTE: This variable has a maximum value of 128.
    // (This variable must be the last field in the SongHeader).
    nSubroutines : u8,

    // Immediately after this header is an array, [u16 ; nSubroutines], containing the location of each subroutine
    // (relative to the start of the song data).
    // The audio-engine will convert the locations into addresses before starting the event-loop.
};


