# -*- coding: utf-8 -*-
# vim: set fenc=utf-8 ai ts=4 sw=4 sts=4 et:

from .json_formats import Name, Callback, CallbackDict, CallbackParameter, Mappings, RoomEvent, SecondLayerCallback

from io import StringIO

from typing import Callable, Final, NamedTuple, Optional


# Mapping of parameter types to wiz types
PARAM_TYPES: Final = {
    "bool": "u8",
    "u8": "u8",
    "u8pos": "U8Position",
    "u16": "u16",
    "sQ4_12": "i16",
    "gamestate_flag": "u8",
    "locked_door": "u8",
    "open_door": "u8",
    "optional_open_door": "u8",
}

# Size of each parameter type in bytes
PARAM_SIZE: Final = {
    "bool": 1,
    "u8": 1,
    "u8pos": 2,
    "u16": 2,
    "sQ4_12": 2,
    "gamestate_flag": 1,
    "locked_door": 1,
    "open_door": 1,
    "optional_open_door": 1,
}


AUTOGENERATED_PARAMETERS: Final = frozenset(
    {
        "locked_door",
        "open_door",
        "optional_open_door",
    }
)


class CallbackType(NamedTuple):
    human_name: str
    parameter_array: str
    parameter_size: int
    get_parameters: Callable[[Callback], Optional[list[CallbackParameter]]]


ROOM_CALLBACK: Final = CallbackType(
    "room event", "room.roomEventParameters", 4, lambda c: c.parameters if isinstance(c, RoomEvent) else None
)

SL_CALLBACK_PARAMETERS: Final = CallbackType(
    "sl parameters", "second_layer.sl_parameters", 8, lambda c: c.sl_parameters if isinstance(c, SecondLayerCallback) else None
)

SL_ROOM_PARAMETERS: Final = CallbackType(
    "sl room parameters", "room.sl_parameters", 2, lambda c: c.room_parameters if isinstance(c, SecondLayerCallback) else None
)


def parse_bool(value: str, error_list: list[str]) -> int:
    v = BOOL_VALUES.get(value)

    if v is None:
        error_list.append("Unknown bool value: {value}")
        return 0
    elif v:
        return 0xFF
    else:
        return 0


BOOL_VALUES: Final[dict[str, bool]] = {
    "": False,
    "0": False,
    "1": True,
    "false": False,
    "true": True,
}


def parse_int(value: str, max_value: int, error_list: list[str]) -> int:
    try:
        int_value = int(value)
    except ValueError as e:
        error_list.append(str(e))
        return 0

    if int_value > max_value:
        error_list.append(f"Parameter is too large: got { int_value }, max: { max_value }")
        return 0

    return int_value


def parse_u8pos(value: str, error_list: list[str]) -> tuple[int, int]:
    v = value.split()
    if len(v) != 2:
        error_list.append("u8pos parameter does not contain two ints: { value }")
        return 0, 0

    try:
        xPos = int(v[0], 0)
        yPos = int(v[1], 0)
    except ValueError as e:
        error_list.append(str(e))
        return 0, 0

    if xPos < 0 or xPos >= 256:
        error_list.append(f"Parameter is not a u8: { value }")

    if yPos < 0 or yPos >= 256:
        error_list.append(f"Parameter is not a u8: { value }")

    return xPos, yPos


def parse_sq4_12(value: str, error_list: list[str]) -> int:
    try:
        fv = float(value)
    except ValueError as e:
        error_list.append(str(e))
        return 0

    v = int(fv * (1 << 12))
    if v >= 0x8000 or v < -0x8000:
        error_list.append(f"sQ4.12 value out of bounds (range -8 to +7.9999): {value}")

    return v & 0xFFFF


class RoomDoors:
    def __init__(self, map_data: bytes, locked_door_tiles: tuple[int, ...], open_door_tiles: tuple[int, ...]):
        self._remaining_locked_doors: Final = [i for i, t in enumerate(map_data) if t in locked_door_tiles]
        self._remaining_open_doors: Final = [i for i, t in enumerate(map_data) if t in open_door_tiles]
        self._uses_open_doors: bool = False

    def get_locked_door(self) -> Optional[int]:
        try:
            return self._remaining_locked_doors.pop(0)
        except IndexError:
            return None

    def get_open_door(self) -> Optional[int]:
        self._uses_open_doors = True
        try:
            return self._remaining_open_doors.pop(0)
        except IndexError:
            return None

    def has_unused_locked_door(self) -> bool:
        return bool(self._remaining_locked_doors)

    def has_unused_open_door(self) -> bool:
        return self._uses_open_doors and bool(self._remaining_open_doors)


def parse_callback_parameters(
    callback_type: CallbackType,
    callback: Callback,
    parameters: dict[Name, str],
    mapping: Mappings,
    room_doors: Optional[RoomDoors],
    error_list: list[str],
) -> bytes:
    old_n_errors = len(error_list)

    out = bytearray()

    callback_parameters: Final = callback_type.get_parameters(callback)
    if callback_parameters is None:
        raise RuntimeError(f"parse_callback_parameters({callback_type.human_name}) is called with the wrong Callback type")

    for p in callback_parameters:
        value = parameters.get(p.name, p.default_value)

        if p.type in AUTOGENERATED_PARAMETERS:
            if value:
                error_list.append(f"{ callback_type.human_name } parameter { p.name } is auto-generated and must not have a value")

            elif room_doors is None:
                error_list.append(f"{ callback_type.human_name } parameter { p.name } is auto-generated and there is no map data")

            elif p.type == "locked_door":
                door_location = room_doors.get_locked_door()
                if door_location is not None:
                    out.append(door_location)
                else:
                    error_list.append(f"{ callback_type.human_name } parameter {p.name}: Cannot find a locked door")

            elif p.type == "open_door" or p.type == "optional_open_door":
                room_doors._uses_open_doors = True
                if len(room_doors._remaining_open_doors) > 0:
                    door_location = room_doors._remaining_open_doors.pop(0)
                elif p.type == "optional_open_door":
                    door_location = 0
                else:
                    error_list.append(f"{ callback_type.human_name } parameter {p.name}: Cannot find a locked door")
                    door_location = 0
                out.append(door_location)

            else:
                error_list.append(f"Unknown { callback_type.human_name } parameter type: {p.type}")
        else:
            if not value:
                error_list.append(f"{ callback_type.human_name } {callback.name}: Missing parameter {p.name}")
            elif p.type == "bool":
                out.append(parse_bool(value, error_list))
            elif p.type == "u8":
                out.append(parse_int(value, 0xFF, error_list))
            elif p.type == "u8pos":
                out += bytes(parse_u8pos(value, error_list))
            elif p.type == "u16":
                v = parse_int(value, 0xFFFF, error_list)
                out.append(v & 0xFF)
                out.append(v >> 8)
            elif p.type == "sQ4_12":
                v = parse_sq4_12(value, error_list)
                out.append(v & 0xFF)
                out.append(v >> 8)
            elif p.type == "gamestate_flag":
                try:
                    flag_index = mapping.gamestate_flags.index(value)
                    out.append(flag_index)
                except ValueError:
                    error_list.append(f"{ callback_type.human_name } parameter {p.name}: Cannot find gamestate flag: {value}")
            else:
                error_list.append(f"Unknown { callback_type.human_name } parameter type: {p.type}")

    if room_doors:
        # room_doors are only used by room events
        assert callback_type == ROOM_CALLBACK

        if room_doors.has_unused_locked_door():
            error_list.append("There are locked_doors that are unused by the room event")

        if room_doors.has_unused_open_door():
            error_list.append(
                "There are too many open doors in the map (and the room event has an open_door/optional_open_door parameter)"
            )

    if len(out) < callback_type.parameter_size:
        out += bytes(callback_type.parameter_size - len(out))

    if len(out) != callback_type.parameter_size:
        if len(error_list) == old_n_errors:
            # No errors with callback parameters, but out has the wrong size
            error_list.append("CRITICAL ERROR: { callback_type.human_name } data is too large")
        return bytes(callback_type.parameter_size)
    else:
        return out


def write_callback_parameters_wiz(out: StringIO, callbacks: CallbackDict, *callback_types: CallbackType) -> None:
    for e in callbacks.values():
        for callback_type in callback_types:
            e_parameters = callback_type.get_parameters(e)
            if e_parameters:
                i = 0

                out.write(f"namespace {e.name} {{\n")

                for p in e_parameters:
                    if i != 0:
                        out.write("\n")

                    ptype = PARAM_TYPES.get(p.type)
                    if not ptype:
                        raise ValueError(f"Unknown { callback_type.human_name } parameter type: {p.type}")

                    if p.comment:
                        p_comment = p.comment.replace("\n", "\n  // ")
                        out.write(f"  // { p_comment }\n")
                    out.write(f"  // ({ p.type })\n")
                    out.write(f"  const parameter__{ p.name } @ &{ callback_type.parameter_array }[{ i }] : { ptype };\n")

                    i += PARAM_SIZE[p.type]

                out.write("}\n\n")

                if i > callback_type.parameter_size:
                    raise ValueError(f"{ callback_type.human_name } has too many parameters: {e.name}")
