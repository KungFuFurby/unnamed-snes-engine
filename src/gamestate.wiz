// Gamestate variables
//
// Copyright (c) 2022, Marcus Rowe <undisbeliever@gmail.com>.
// Distributed under The MIT License, see the LICENSE file for more details.


import "memmap";

import "metasprites";
import "resources";
import "ui";


in lowram {
    // Number of frames processed.
    // (incremented every `WaitFrame` call)
    //
    // MUST be in the `lowram` bank to work correctly.
    //
    // (u32)
    var frameCounter : u32;

        var frameCounter_lobyte @ &<:frameCounter : u8;

        var frameCounter_loword @ &frameCounter              : u16;
        var frameCounter_hiword @ (&frameCounter as u16 + 2) : u16;
}


namespace gamestate {

struct GameStateData {
    // The location of the current room
    currentRoom : u8,

    // The player's starting position when they entered the room.
    // (u8 position)
    playerStartingX : u8,
    playerStartingY : u8,


    // The room to load in a non-scrolling room transition.
    //
    // Is not used by scrolling room transition.
    //
    // Will only be read by the ROOM_TRANSITION_FADEOUT and LOAD_ROOM_FADEIN transitions.
    roomToLoad : u8,

    // The location to place the player in a non-scrolling room transition.
    //
    // NOTE: This value is unused by the scrolling room transitions.
    // (u8 position)
    roomToLoad_xPos : u8,
    roomToLoad_yPos : u8,


    // Game State flags
    // (256 bit bitfield)
    gameFlags : [ u8 ; 256 / 8 ],

    // Number of keys held by the player
    //
    // NOTE: This function should not be modified by game code
    _keyCount : u8,
};


in wram7e_roomstate {
    var __fardata : GameStateData;
        var data @ &__fardata : GameStateData;
}


in code {

// Initialize the gamestate
//
// DB = 0x7e
#[mem8, idx8]
inline func init() {
    a = resources.rooms.STARTING_ROOM;
    data.currentRoom = a;
    data.roomToLoad = a;

    a = DISPLAY_WIDTH / 2;
    data.playerStartingX = a;
    data.roomToLoad_xPos = a;

    a = DISPLAY_HEIGHT / 2;
    data.playerStartingY = a;
    data.roomToLoad_yPos = a;


    // Clear all the game flags
    x = sizeof(typeof(data.gameFlags)) - 1;
    do {
        data.gameFlags[x] = 0;
        x--;
    } while !negative;

    data._keyCount = 0;
}



// Returns true if the game flag is clear
//
// DB = 0x7e
#[mem8, idx8]
func is_flag_clear(flag_id : u8 in x) : bool in zero {
    y = a = x >>> 3;
    x = a = x & 7;

    a = data.gameFlags[y] & _BitTable[x];
    return zero;
}


// Returns true if the game flag is clear (without clobbering the Y register)
//
// KEEP: y
//
// DB = 0x7e
#[mem8, idx8]
func is_flag_clear__keep_y(flag_id : u8 in x) : bool in zero {
var _tmp : u8 in zpTmp_byte_0;

    _tmp = y;

    y = a = x >>> 3;
    x = a = x & 7;

    a = data.gameFlags[y];

    y = _tmp;

    a &= _BitTable[x];
    return zero;
}


// DB = 0x7e
#[mem8, idx8]
func set_game_flag(flag_id : u8 in x) {
    y = a = x >>> 3;
    x = a = x & 7;

    data.gameFlags[y] = a = data.gameFlags[y] | _BitTable[x];
}



// KEEP: Y
//
// DB = 0x7e
#[mem8, idx8]
func set_game_flag__keep_y(flag_id : u8 in x) {
var _tmp : u8 in zpTmp_byte_0;

    _tmp = y;

    y = a = x >>> 3;
    x = a = x & 7;

    data.gameFlags[y] = a = data.gameFlags[y] | _BitTable[x];

    y = _tmp;
}



// Increment the key counter
// DB = 0x7e
#[mem8, idx8]
func increment_key_count() {
    x = data._keyCount;
    x++;
    if negative {
        x = 127;
    }
    data._keyCount = x;

    return ui.draw_key_bar(x);
}



// Decrement the key counter.
//
// Return true if there was a key to decrement.
//
// DB = 0x7e
#[mem8, idx8]
func test_and_decrement_key_count() : bool in carry{
    x = data._keyCount;
    if !zero {
        x--;
        data._keyCount = x;

        ui.draw_key_bar(x);
        return true;
    }
    return false;
}


}


in rodata0 {

const __BitTable : [ u8 ; 8 ] = [ 1 << i for let i in 0..7 ];

let _BitTable = far &__BitTable as far *u8;

}

}

