// Copyright (c) 2022, Marcus Rowe <undisbeliever@gmail.com>.
// Distributed under The MIT License, see the LICENSE file for more details.

import "../memmap";

import "_common";
import "../room";
import "../metatiles";
import "../gamestate";
import "../interactive-tiles";

import "gen/room-events";


namespace room_events {
namespace locked_door {

// This allows me to read the state variable using the `bit` instruction.
enum State : u8{
    WAITING_FOR_KEY,
    UNLOCKING_DOOR,
    DOOR_UNLOCKED,
};

in wram7e_roomstate {
    var state : State in <:state_0;
}


in code {

// DB = 0x7e
#[mem8, idx8]
func init() {
    metatiles.interactive_tiles.locked_door.playerTouchedLockedDoor = 0;

    zero = gamestate.is_flag_clear(parameter__flag);
    if !zero {
        // The door has already been unlocked.
        // Change the map tiles to an unlocked door before the room transition starts.

        // Get the top-left door tile.
        // The unlocked door tiles are 2 tiles to the right of the locked door tile.
        y = parameter__doorLocation;
        a = metatiles.map[y] + 2;

        // Set map tiles to the unlocked door tiles
        (&room.map[0x00])[y] = a;
        a++;
        (&room.map[0x01])[y] = a;
        a += 0x10 - 1;
        (&room.map[0x10])[y] = a;
        a++;
        (&room.map[0x11])[y] = a;


        // Do not check door/key state in process()
        a = State.DOOR_UNLOCKED as u8;
        state = a as State;
    }

    // state has been reset to 0

    ^return spawn_room_entities();
}


// DB = 0x7e
#[mem8, idx8]
func process() {
    a = state as u8;
    if zero {
        // state == State.WAITING_FOR_KEY

        a = metatiles.interactive_tiles.locked_door.playerTouchedLockedDoor;
        if !zero {
            metatiles.interactive_tiles.locked_door.playerTouchedLockedDoor = 0;

            carry = gamestate.test_and_decrement_key_count();
            if carry {
                // key was consumed, set flag and unlocked door
                gamestate.set_game_flag(parameter__flag);
                return _unlock_door();
            }
        }
    }
    else if a == State.UNLOCKING_DOOR as u8 {
        return _unlock_door();
    }
}


// DB = 0x7e
#[mem8, idx8]
func _unlock_door() {
    // Get the top-left door tile.
    // The unlocked door tiles are 2 tiles to the right of the locked door tile.
    y = parameter__doorLocation;
    a = metatiles.map[y] + 2;

    carry = metatiles.set_2x2_tiles(y, a);
    if carry {
        // Door successfully unlocked.

        // ::TODO play door unlocked SFX::

        a = State.DOOR_UNLOCKED as u8;
        state = a as State;
    }
    else {
        // Cannot unlock the door on this frame, try again on the next frame.
        a = State.DOOR_UNLOCKED as u8;
        state = a as State;
    }
}

}

}
}

