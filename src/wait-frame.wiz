// Copyright (c) 2021, Marcus Rowe <undisbeliever@gmail.com>.
// Distributed under The MIT License, see the LICENSE file for more details.

import "memmap";
import "joypad";
import "metasprites";
import "metatiles";
import "ui";
import "rng";
import "interrupts";
import "gamestate";
import "../wiz/common/snes/snes";


let FRAMES_PER_SECOND = 60;


in shadow {
    // A shadow of the INIDISP register
    var _brightness_buffer : u8;


    // A shadow of the BG1 scroll registers.
    //
    // (2x u16 words)
    var bg1_scrollX : u16;
    var bg1_scrollY : u16;
}


in code {



// Pause the game for a second
//
// DB = 0x7e
#[mem8, idx8]
func wait_one_second() {

    a = FRAMES_PER_SECOND;

    do {
        push8(a);

        wait_frame();

        a = pop8();
        a--;
    } while !zero;
}



// Wait until the end of the current frame, process VBlank routines.
//
// REQUIRES: NMI enabled, IRQs disabled
//
// DB access shadow RAM
func wait_frame() {

    push8(p);
    push8(data_bank);

    push8(program_bank);
    data_bank = pop8();
// DB = 0x80


    mem16_idx16();
    #[mem16, idx16] {
        rng.increment_rng();
    }
    mem8();
    #[mem8, idx16] {
        a = _brightness_buffer | snes.ppu.BRIGHTNESS_FORCE_BLANK;

        wait_until_interrupt();

        // Force-blank screen to prevent corrupt graphics on VBlank overrun
        snes.ppu.brightness = a;


        metasprites.update_oam__vblank();

        metatiles.transitions.transfer_buffer__vblank();

        ui.transfer_buffer__vblank();


        // Update scroll registers

        snes.ppu.bg1_scroll_x = a = *(&<:bg1_scrollX as *u8);
        snes.ppu.bg1_scroll_x = a = *(&>:bg1_scrollX as *u8);
        snes.ppu.bg1_scroll_y = a = *(&<:bg1_scrollY as *u8);
        snes.ppu.bg1_scroll_y = a = *(&>:bg1_scrollY as *u8);


        snes.ppu.brightness = a = _brightness_buffer;
    }

    idx8();
    mem16();
    #[mem16, idx8] {
        metatiles.process_draw_tile_buffer__vblank();
    }

    mem16_idx16();
    #[mem16, idx16] {
        aa = *(&nmiCounter as *u16) & 0xff;

        frameCounter_loword = aa = aa + frameCounter_loword;
        if zero {
            frameCounter_hiword++;
        }
    }

    mem8_idx8();
    #[mem8, idx8] {
        nmiCounter = 0;

        joypad.update_state__inline();
    }


    data_bank = pop8();
    p = pop8();

// DB = unknown
}



// Change the brightness of the display.
//
// NOTE: Will also wait until the end of the current frame
//
// DB access shadow RAM
#[mem8]
func wait_frame_and_change_brightness(new_brightness : u8 in a) {
    _brightness_buffer = a;

    ^return wait_frame();
}


}

