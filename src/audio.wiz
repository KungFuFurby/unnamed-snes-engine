// Copyright (c) 2023, Marcus Rowe <undisbeliever@gmail.com>.
// Distributed under The MIT License, see the LICENSE file for more details.

import "memmap";
import "resources";
import "gen/resources";

import "../wiz/common/snes/snes";


namespace audio {


// Address to store the AudioDriver (in Audio-RAM)
// Address (in Audio-RAM) to execute after loading the AudioDriver.
let AUDIO_DRIVER_ARAM_ADDR = 0x200;


// MUST match `audio/src/audio-driver.wiz`
namespace IO {
    extern writeonly command_id @ &snes.apu.output0 : u8;
    extern const command_id_ack @ &snes.apu.input0 : u8;

    extern writeonly command @ &snes.apu.output1 : u8;
}


// MUST match `audio/src/audio-driver.wiz`
enum IoCommand : u8 {
    // commands 0-127: Play sound effect.
};


in rodata0 {
    const AudioDriver = embed "../audio/audio-driver.bin";
}


in zeropage {
    // The sound effect to play next.
    //
    // NOTE: If sfxQueue > N_SOUND_EFFECTS.  No sound effect will be played.
    var sfxQueue : u8;

    // The `command_id` of the previous command send to the S-SMP audio driver.
    var previousCommandId : u8;
}


in code {


// REQUIRES: S-SMP reset
//
// This function MUST only be called once.
//
// DB = 0x80
#[mem8, idx16]
func setup() {
var _res : resources.ResourceEntry in resources.res;

    // ::TODO add a first-call check::


    // ::TODO add audio driver and music data to resources::
    *(&_res.farPtr as *u16) = xx = &AudioDriver as u16;
    #:_res.farPtr = a = #:far &AudioDriver;
    _res.size = yy = sizeof(typeof(AudioDriver));

    __initialise_ipl();
    _transfer_data_to_aram(_res, AUDIO_DRIVER_ARAM_ADDR);

    // ::TODO transfer common data::

    __execute_audio_driver();


    // Reset the SFX queue
    sfxQueue = a = 0xff;

    // Start audio driver.
    IO.command_id = 0;
    previousCommandId = 0;
}



// Queue the next sound effect to play.
//
// NOTE: Only 1 sound effect can be played at a time
// NOTE: Lower sound effect IDs take priority over higher sound effect IDs.
//
// DB access zero-page
#[mem8, idx8]
func queue_sound_effect(effect_id : sound_effects in a) {
    if a < sfxQueue {
        sfxQueue = a;
    }
}



// Process sound effects
//
// MUST be called once per frame.
//
// DB = 0x80
#[mem8, idx8]
inline func process_sfx_queue__inline() {
    // Assumes N_SOUND_EFFECTS <= 128
    a = sfxQueue;
    if !negative {
        x = previousCommandId;
        if x == IO.command_id_ack {
            // The previous command executed successfully.
            // Send a new command.

            IO.command = a;

            x++;
            IO.command_id = x;
            previousCommandId = x;

            // Reset the SFX queue
            sfxQueue = a = 0xff;
        }
    }
}



// REQUIRES: S-SMP reset and no data has been written to it yet
//
// This function MUST only be called once.
//
// DB = 0x80
#[mem8, idx16]
func __initialise_ipl() {
    // Initialize the transfer
    yy = 0xbbaa;
    snes.apu.output10 = yy;

    // Wait for a response from the IPL
    do {
    } while yy != snes.apu.input10;
}



// REQUIRES: S-SMP is running the IPL and `__initialise_ipl()` has been called.
//
// DB = 0x80
#[mem8, idx16]
func _transfer_data_to_aram(_res : resources.ResourceEntry in resources.res, aramAddr : u16 in xx) {

    // ::TODO add a 'running IPL' check::


    // A transfer data command occurs when `APUIO0` is incremented by more than 2 and non-zero.
    // However the first transfer command requires an `APUIO0` of 0xcc.
    //
    // Since the IPL sets `APUIO0` to 0xaa, we can increment `APUIO0` by 0x22 and use the same
    // code on the first and subsequent data transfers.
    //
    // Source: SNESdev wiki: https://snes.nesdev.org/wiki/Booting_the_SPC700

    a = snes.apu.input0;
    a += 0x22;
    if zero {
        a++;
    }

    snes.apu.output32 = xx;     // destination ARAM address
    snes.apu.output1 = a;       // non-zero = write data to address
    snes.apu.output0 = a;       // New data command (non-zero and APUIO0 + more than 2, or 0xcc on the first transfer)


    // Wait for a response form the IPL
    do {
    } while a != snes.apu.input0;


    // Transfer the data
    yy = 0;
    do {
        // Send the next byte to the IPL
        snes.apu.output1 = a = _res.farPtr[unaligned yy];

        // Increase output0 by 1 (starting at 0)
        // Tell the IPL the next data is ready
        snes.apu.output0 = a = y;

        // Increment yy here, while the IPL is busy
        yy++;

        // Wait for a response from the IPL
        do {
        } while a != snes.apu.input0;

    } while yy < _res.size;
}



// REQUIRES: S-SMP is running the IPL and the driver has been transferred to the A-RAM
//
// DB = 0x80
#[mem8, idx16]
func __execute_audio_driver() {

    a = snes.apu.input0;
    a++;
    a++;
    if zero {
        a++;
    }

    snes.apu.output32 = xx = AUDIO_DRIVER_ARAM_ADDR;    // A-RAM address
    snes.apu.output1 = 0;                               // zero = execute program at A-RAM address
    snes.apu.output0 = a;                               // New data command (non-zero and APUIO0 + more than 2, or 0xcc on the first transfer)
}

}

}

