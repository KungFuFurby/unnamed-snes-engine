// Copyright (c) 2023, Marcus Rowe <undisbeliever@gmail.com>.
// Distributed under The MIT License, see the LICENSE file for more details.

import "memmap";
import "resources";
import "gen/resources";

import "../wiz/common/snes/snes";


namespace audio {


// Address to store the loader (in Audio-RAM).
// Address (in Audio-RAM) to execute after loading the Loader.
// MUST match LOADER_ADDR in `audio/src/common_memmap.wiz`
let LOADER_ARAM_ADDR = 0x160;


// MUST match `audio/src/audio-driver.wiz`
namespace IO {
    extern writeonly command_id @ &snes.apu.output0 : u8;
    extern const command_id_ack @ &snes.apu.input0 : u8;

    extern writeonly command @ &snes.apu.output1 : u8;
}

// MUST match `audio/src/loader.wiz`
enum LoaderDataType : u8 {
    // These values cannot be 0 or negative.
    CODE        = 'C',
    COMMON_DATA = 'D',
    SONG_DATA   = 'S',
};


// MUST match `audio/src/audio-driver.wiz`
enum IoCommand : u8 {
    // commands 0-127: Play sound effect.

    EXECUTE_LOADER = 0x80 | 'L',
};


in rodata0 {
    const __Loader = embed "../audio/loader.bin";

    let Loader = far &__Loader as far * const u8;
    let LOADER_SIZE = sizeof(typeof(__Loader));

    const AudioDriver = embed "../audio/audio-driver.bin";
}


in zeropage {
    // The sound effect to play next.
    //
    // NOTE: If sfxQueue > MAX_N_SOUND_EFFECTS.  No sound effect will be played.
    var sfxQueue : u8;

    // The `command_id` of the previous command send to the S-SMP audio driver.
    var previousCommandId : u8;
}


in code {


// REQUIRES: S-SMP reset
//
// This function MUST only be called once.
//
// DB = 0x80
#[mem8, idx16]
func setup() {
var _res : resources.ResourceEntry in resources.res;

    // ::TODO add a first-call check::

    __transfer_loader_via_ipl__inline();


    *(&_res.farPtr as *u16) = xx = &AudioDriver as u16;
    #:_res.farPtr = a = #:far &AudioDriver;
    _res.size = yy = sizeof(typeof(AudioDriver));

    __transfer_data_to_loader(_res, LoaderDataType.CODE);


    _res = resources.load_songs_resource(resources.songs.__null__common_data__);
    __transfer_data_to_loader(_res, LoaderDataType.COMMON_DATA);
}



// DB access low-ram
#[mem8]
inline func _reset_sfx_queue__inline() {
    // Reset the SFX queue
    sfxQueue = a = 0xff;

    // Start audio driver.
    IO.command_id = 0;
    previousCommandId = 0;
}



// Queue the next sound effect to play.
//
// NOTE: Only 1 sound effect can be played at a time
// NOTE: Lower sound effect IDs take priority over higher sound effect IDs.
//
// DB access zero-page
#[mem8, idx8]
func queue_sound_effect(effect_id : sound_effects in a) {
    // MUST NOT modify zpTmp variables.

    if a < sfxQueue {
        sfxQueue = a;
    }
}



// Process sound effects
//
// MUST be called once per frame.
//
// DB = 0x80
#[mem8, idx8]
inline func process_sfx_queue__inline() {
    // Assumes MAX_N_SOUND_EFFECTS == 128
    a = sfxQueue;
    if !negative {
        x = previousCommandId;
        if x == IO.command_id_ack {
            // The previous command executed successfully.
            // Send a new command.

            IO.command = a;

            x++;
            IO.command_id = x;
            previousCommandId = x;

            // Reset the SFX queue
            sfxQueue = a = 0xff;
        }
    }
}



// Send a command to the audio-driver
//
// DB = 0x80
#[mem8, idx16]
func __send_command(command : IoCommand in a) {
    idx8();
    #[idx8] {
        x = previousCommandId;

        // Wait until the previous command has been acknowledged
        do {
        } while x != IO.command_id_ack;
        x++;

        IO.command = a;
        IO.command_id = x;

        previousCommandId = x;
    }
    idx16();
}



// Transfer song data to the audio driver
//
// ASSUMES: Common data is already loaded into the console
//
// DB = 0x80
#[mem8, idx16]
func _transfer_song_data(_res : resources.ResourceEntry in resources.res) {
    // ::TODO silence or fadeout the current song before loading the next one::

    __send_command(IoCommand.EXECUTE_LOADER);

    __transfer_data_to_loader(_res, LoaderDataType.SONG_DATA);
}



// Transfer data to the audio loader
//
// NOTE: This function may read one byte past the end of `_res`.
//
// DB = 0x80
#[mem8, idx16]
func __transfer_data_to_loader(_res : resources.ResourceEntry in resources.res, type : LoaderDataType in a) {

    // Wait until loader is ready
    xx = ('R' as u16) | ('D' as u16 << 8);
    do {
    } while xx != snes.apu.input32;


    // Send the ready signal and the LoaderDataType.
    snes.apu.output0 = a;
    snes.apu.output2 = a = 'R';
    snes.apu.output3 = a = 'D';


    // Calculate the number of words to transfer
    // ASSUMES _res.size >= 2.
    mem16();
    #[mem16] {
        aa = _res.size;
        aa++;
        xx = aa = aa >>> 1;
    }
    mem8();


    // Wait for acknowledgement from the LoaderDataType
    do {
        a = snes.apu.input2;
    } while !zero;

    yy = 0;
    do {
        snes.apu.output0 = a = _res.farPtr[yy];
        yy++;
        snes.apu.output1 = a = _res.farPtr[yy];

        // Tell S-SMP the data is ready
        // `snes.apu.output3` cannot be negative.  A negative value on port-3 means end-of-data.
        // Also cannot be 'D'.
        a = y & 0xf;
        snes.apu.output3 = a;

        yy++;

        do {
        } while a != snes.apu.input3;

        xx--;
    } while !zero;


    // End of data transfer
    snes.apu.output3 = a = 0xff;

    // Must wait for the end of the input as `_reset_sfx_queue__inline()` writes to IO port 0.
    do {
    } while a != snes.apu.input3;

    _reset_sfx_queue__inline();
}



// REQUIRES: S-SMP reset and no data has been written to it yet
//
// This function MUST only be called once.
//
// DB = 0x80
#[mem8, idx16]
inline func __transfer_loader_via_ipl__inline() {
    // ::TODO add a 'running IPL' check::

    // Initialize the transfer
    yy = 0xbbaa;
    snes.apu.output10 = yy;

    // Wait for a response from the IPL
    do {
    } while yy != snes.apu.input10;

    xx = LOADER_ARAM_ADDR;
    a = 0xcc;
    snes.apu.output32 = xx;     // destination ARAM address
    snes.apu.output1 = a;       // non-zero = write data to address
    snes.apu.output0 = a;       // New data command (non-zero and APUIO0 + more than 2, or 0xcc on the first transfer)


    // Wait for a response form the IPL
    do {
    } while a != snes.apu.input0;


    // Transfer the data
    idx8();
    #[idx8] {
        x = 0;
        do {
            // Send the next byte to the IPL
            snes.apu.output1 = a = Loader[x];

            // Tell the IPL the next data is ready
            snes.apu.output0 = x;

            // Wait for a response from the IPL
            do {
            } while x != snes.apu.input0;

            x++;
        } while x < LOADER_SIZE;
    }
    idx16();

    snes.apu.output32 = xx = LOADER_ARAM_ADDR;  // A-RAM address
    snes.apu.output1 = 0;                       // zero = execute program at A-RAM address
    snes.apu.output0 = a = LOADER_SIZE + 2;     // New data command (must be at least +2 the previous snes.apu.output0 write)
}

}

}

