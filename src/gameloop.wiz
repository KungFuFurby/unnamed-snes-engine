// Copyright (c) 2021, Marcus Rowe <undisbeliever@gmail.com>.
// Distributed under The MIT License, see the LICENSE file for more details.

import "memmap";
import "../wiz/common/snes/snes";

import "metatiles";
import "metasprites";
import "resources";
import "wait-frame";
import "common/reset";
import "entities/_variables";
import "entities/_common";
import "entities/player";


namespace gameloop {


let DISPLAY_WIDTH = 256;
let DISPLAY_HEIGHT = 224;


let ENTITIES_IN_MAP = 8;

// Map data format
struct RoomData {
    map         : [u8 ; metatiles.MAP_WIDTH * metatiles.MAP_HEIGHT],

    tileset     : u8,

    // Entities in the map
    // (Structure of Arrays)
    // If the entity does not spawn then the array elements MUST be 0xff;
    entity_xPos : [u8 ; ENTITIES_IN_MAP ],
    entity_yPos : [u8 ; ENTITIES_IN_MAP ],
    entity_type : [u8 ; ENTITIES_IN_MAP ],
};



in zeropage {

}

in wram7e {

    // This hack is required to access room via addr addressing.
    #[align(256)]
    var __far_room : RoomData;
    let room = *(&__far_room as *RoomData);


    // The location of the current room
    var currentRoom : u8;

}



in code {

// Initialize the game loop
//
// DB = 0x7e
#[mem8, idx8]
inline func init() {

    entities.player.init();

    currentRoom = a = resources.rooms.STARTING_ROOM;


    _load_room();

    metatiles.populate_map_tile_properties();

    _spawn_room_entities();
}



// Load a room into memory
//
// DB = 0x7e
#[mem8, idx8]
func _load_room() {
let _tmp = <:dpTmp0;
let _roomPtr = dpTmp_farPtr;

    x = currentRoom;
    a = resources.rooms.room_table[x];

    a--;
    if a >= resources.rooms.N_ROOMS {
        a = 0;
    }
    x = a;

    <:_roomPtr = a = resources.rooms.room_list_l[x];
    >:_roomPtr = a = resources.rooms.room_list_h[x];
    #:_roomPtr = a = resources.rooms.room_list_bank;


    y = sizeof(typeof(room)) - 1;
    do {
        (&room as *u8)[y] = a = _roomPtr[y];
        y--;
    } while !zero;

    (&room as *u8)[0] = a = *_roomPtr;
}



// Spawn entity in the room
//
// DB = 0x7e
#[mem8, idx8]
func _spawn_room_entities() {
    entities.init();


    x = ENTITIES_IN_MAP - 1;
    do {
        push8(x);

        entities.spawn_entity(a = room.entity_xPos[x],
                              a = room.entity_yPos[x],
                              a = room.entity_type[x]);

        x = pop8();

        x--;
    } while !negative;

}



// Setup PPU, reset graphics subsystems and draw graphics to the screen.
//
// This function will restore the following subsystems to a known good state:
//  * PPU
//  * MetaTiles
//  * MetaSprite
//
// ASSUMES: room and entities are loaded into memory
//
// NOTE: Enables Force-Blank
//
// DB = 0x7e
#[mem8, idx8]
func setup_ppu_and_reset_graphics_subsystems() {

    wait_frame_and_change_brightness(snes.ppu.BRIGHTNESS_FORCE_BLANK | snes.ppu.BRIGHTNESS_MASK);


    push8(program_bank);
    data_bank = pop8();
// DB = 0x80
    {
        // Setup PPU registers

        reset_registers();

        snes.ppu.bg_mode = a = 1 | snes.ppu.BG_MODE_MODE1_BG3_PRIORITY;
        snes.ppu.bg1_tilemap = a = (VRAM_BG1_MAP_WADDR >> snes.ppu.BG_TILESET_ADDRESS_BIT_ALIGN << snes.ppu.BG_TILEMAP_ADDRESS_SHIFT_LEFT) | snes.ppu.BG_TILEMAP_MIRROR_X;

        snes.ppu.bg12_tileset = a = (VRAM_BG1_TILES_WADDR >> snes.ppu.BG_TILESET_ADDRESS_BIT_ALIGN << snes.ppu.BG12_TILESET_ADDRESS_BG1_SHIFT);


        snes.ppu.screen_enable_mask = a = snes.ppu.SCREEN_ENABLE_BG1 | snes.ppu.SCREEN_ENABLE_OBJ;



        // Load Graphics to PPU

        idx16();
        #[idx16] {
            metatiles.load_tileset__forceblank(room.tileset);

            metasprites.setup__fblank();

            // ::TODO get spritesheet_id from somewhere::
            metasprites.load_ppu_data__fblank(0);
        }
        idx8();
    }
    push8(a = 0x7e);
    data_bank = pop8();
// DB = 0x7e


    metatiles.draw_map__forceblank();

    draw_entities();


    // ::TODO fadein::

    wait_frame_and_change_brightness(0xf);
}



// Process the game loop
//
// DB = 0x7e
#[mem8, idx8]
func run_game() {

    setup_ppu_and_reset_graphics_subsystems();


    ^while true {
        // Always process player entity first
        x = 0;
        entities.SoA.process_function[unaligned x](x);


        entities.process_active_entities();

        draw_entities();



        // Check for a room transition
        a = entities.player.yPos.px;
        if zero {
            _change_room_north();
        }
        else if a >= DISPLAY_HEIGHT - 1 {
            _change_room_south();
        }

        a = entities.player.xPos.px;
        if zero {
            _change_room_west();
        }
        else if a >= DISPLAY_WIDTH - 1 {
            _change_room_east();
        }

        wait_frame();
    }
}



// Process the game loop
//
// DB = 0x7e
#[mem8, idx8]
func draw_entities() {
    idx16();
    #[idx16] {
        metasprites.draw_shadows();
    }
    idx8();

    entities.draw_active_entities();

    idx16();
    #[idx16] {
        metasprites.finalize_buffer();
    }
    idx8();
}



// The player has reached the top of the screen and wants to enter the room above the `currentRoom`.
//
// DB = 0x7e
#[mem8, idx8]
inline func _change_room_north() {

    a = currentRoom - 0x10;
    if carry {
        currentRoom = a;

        entities.player.yPos.px = a = DISPLAY_HEIGHT - 2;
        entities.player.yPos.sx = 0;

        _room_transition__blank();
    }
}



// The player has reached the bottom of the screen and wants to enter the room below the `currentRoom`.
//
// DB = 0x7e
#[mem8, idx8]
inline func _change_room_south() {

    a = currentRoom + 0x10;
    if !carry {
        currentRoom = a;

        entities.player.yPos.px = a = 1;
        entities.player.yPos.sx = 0;

        _room_transition__blank();
    }
}



// The player has reached the right edge of the screen and wants to enter the room right of `currentRoom`.
//
// DB = 0x7e
#[mem8, idx8]
inline func _change_room_east() {

    a = (currentRoom & 0x0f) + 1;
    if !carry {
        // Can move eastward
        currentRoom++;

        entities.player.xPos.px = a = 1;
        entities.player.xPos.sx = 0;

        _room_transition__blank();
    }
}



// The player has reached the left edge of the screen and wants to enter the room left of `currentRoom`.
//
// DB = 0x7e
#[mem8, idx8]
inline func _change_room_west() {

    a = (currentRoom & 0x0f) - 1;
    if carry {
        // Can move westward
        currentRoom--;

        entities.player.xPos.px = a = DISPLAY_WIDTH - 2;
        entities.player.xPos.sx = 0;

        _room_transition__blank();
    }
}



// Blank the screen, then load the next room and resources.
//
// DB = 0x7e
#[mem8, idx8]
func _room_transition__blank() {

    wait_frame_and_change_brightness(0x08);

    _load_room();
    metatiles.populate_map_tile_properties();
    _spawn_room_entities();


    setup_ppu_and_reset_graphics_subsystems();
}




}

}

