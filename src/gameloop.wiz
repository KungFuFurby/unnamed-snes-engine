// Copyright (c) 2021, Marcus Rowe <undisbeliever@gmail.com>.
// Distributed under The MIT License, see the LICENSE file for more details.

import "memmap";
import "../wiz/common/snes/snes";

import "gamemodes";
import "metatiles";
import "metasprites";
import "resources";
import "wait-frame";
import "common/reset";
import "entities/_variables";
import "entities/_common";
import "entities/player";


namespace gameloop {


let DISPLAY_WIDTH = 256;
let DISPLAY_HEIGHT = 224;


let FRAMES_PER_SECOND = 60;


let PLAYER_MAP_TRANSITION_END_POS = 3;

// Value MUST BE odd
let H_TRANSITION_FRAMES_BEFORE_SOLID_CHECK = 13;
let V_TRANSITION_FRAMES_BEFORE_SOLID_CHECK = 11;



let ENTITIES_IN_MAP = 8;

// Map data format
struct RoomData {
    map         : [u8 ; metatiles.MAP_WIDTH * metatiles.MAP_HEIGHT],

    tileset     : u8,

    // Entities in the map
    // (Structure of Arrays)
    // If the entity does not spawn then the array elements MUST be 0xff;
    entity_xPos      : [u8 ; ENTITIES_IN_MAP],
    entity_yPos      : [u8 ; ENTITIES_IN_MAP],
    entity_type      : [u8 ; ENTITIES_IN_MAP],
    entity_parameter : [u8 ; ENTITIES_IN_MAP],
};



in zeropage {

}

in wram7e {

    // This hack is required to access room via addr addressing.
    #[align(256)]
    var __far_room : RoomData;
    let room = *(&__far_room as *RoomData);


    // The location of the current room
    var currentRoom : u8;

}



in code {

// Initialize the game loop
//
// DB = 0x7e
#[mem8, idx8]
inline func init() {

    entities.player.init();

    currentRoom = a = resources.rooms.STARTING_ROOM;


    a = GameModes.LOAD_ROOM_FADEIN as u8;
    gameMode = a as GameModes;
}



// Load the room into memory
//
// ASSUMES: roomListIndex is valid
//
// DB = 0x7e
#[mem8, idx8]
func __copy_room_into_memory(roomListIndex : u8 in x) {
let _roomPtr = dpTmp_farPtr;

    if x >= resources.rooms.N_ROOMS {
        x = 0;
    }

    <:_roomPtr = a = resources.rooms.room_list_l[x];
    >:_roomPtr = a = resources.rooms.room_list_h[x];
    #:_roomPtr = a = resources.rooms.room_list_bank;


    idx16();
    #[idx16] {
        yy = sizeof(typeof(room)) - 1;
        do {
            (&room as *u8)[yy] = a = _roomPtr[yy];
            yy--;
        } while !negative;
    }
    mem8_idx8();
}



// Clear room memory
//
// DB = 0x7e
#[mem8, idx8]
func __clear_room_memory() {

    idx16();
    #[idx16] {
        xx = sizeof(typeof(room)) - 1;
        do {
            (&room as *u8)[xx] = 0;
            xx--;
        } while !negative;
    }
    idx8();
}



// Return true if the currentRoom points to a valid room.
//
// DB = 0x7e
#[mem8, idx8]
func _check_room_exists() : bool in carry {
    x = currentRoom;
    a = resources.rooms.room_table[x];
    if !zero && a < resources.rooms.N_ROOMS + 1 {
        return true;
    }

    return false;
}



// Load the room into memory and check if the MetaTile tileset has changed.
//
// Returns zero set if it is OK to preform a scroll transition into the next room without glitches.
//
// DB = 0x7e
#[mem8, idx8]
func _load_room_and_check_if_ok_to_scroll() : bool in zero {

    x = currentRoom;
    x = a = resources.rooms.room_table[x];
    if !zero && x < resources.rooms.N_ROOMS + 1 {
        // room is valid

        x--;

        push8(a = room.tileset);
        {
            __copy_room_into_memory(x);

            metatiles.populate_map_tile_properties();
            _spawn_room_entities();
        }
        a = pop8();

        cmp(a, room.tileset);
        return zero;
    }
    else {
        // room is missing from map - create an empty dummy map
        //
        // `metatiles.populate_map_tile_properties()` will fill the dummy
        // room's `mapTileProperties` with solid tiles.  This ensures any
        // scrolling room transition into a missing room will always be rolled
        // back.

        __clear_room_memory();

        // Reset entity subsystem
        entities.init();

        metatiles.populate_map_tile_properties();

        // return true
        a = 0;
        return zero;
    }
}



// Spawn entity in the room
//
// DB = 0x7e
#[mem8, idx8]
func _spawn_room_entities() {
    entities.init();


    x = ENTITIES_IN_MAP - 1;
    do {
        push8(x);

        entities.spawn_entity(a = room.entity_xPos[x],
                              a = room.entity_yPos[x],
                              a = room.entity_type[x],
                              y = room.entity_parameter[x]);

        x = pop8();

        x--;
    } while !negative;

}



// Setup PPU, reset graphics subsystems and draw graphics to the screen.
//
// This function will restore the following subsystems to a known good state:
//  * PPU
//  * MetaTiles
//  * MetaSprite
//
// ASSUMES: room and entities are loaded into memory
//
// NOTE: Enables Force-Blank.
// NOTE: MUST ONLY BE CALLED ONCE IN THE CODE
//
// DB = 0x7e
#[mem8, idx8]
inline func _setup_ppu_and_reset_graphics_subsystems() {

    wait_frame_and_change_brightness(snes.ppu.BRIGHTNESS_FORCE_BLANK | snes.ppu.BRIGHTNESS_MASK);


    push8(program_bank);
    data_bank = pop8();
// DB = 0x80
    {
        // Setup PPU registers

        reset_registers();

        snes.ppu.bg_mode = a = 1 | snes.ppu.BG_MODE_MODE1_BG3_PRIORITY;
        snes.ppu.bg1_tilemap = a = (VRAM_BG1_MAP_WADDR >> snes.ppu.BG_TILESET_ADDRESS_BIT_ALIGN << snes.ppu.BG_TILEMAP_ADDRESS_SHIFT_LEFT) | snes.ppu.BG_TILEMAP_MIRROR_X;

        snes.ppu.bg12_tileset = a = (VRAM_BG1_TILES_WADDR >> snes.ppu.BG_TILESET_ADDRESS_BIT_ALIGN << snes.ppu.BG12_TILESET_ADDRESS_BG1_SHIFT);


        snes.ppu.screen_enable_mask = a = snes.ppu.SCREEN_ENABLE_BG1 | snes.ppu.SCREEN_ENABLE_OBJ;



        // Load Graphics to PPU

        idx16();
        #[idx16] {
            metatiles.load_tileset__forceblank(room.tileset);

            metasprites.setup__fblank();

            // ::TODO get spritesheet_id from somewhere::
            metasprites.load_ppu_data__fblank(0);
        }
        idx8();
    }
    push8(a = 0x7e);
    data_bank = pop8();
// DB = 0x7e


    // Tileset may have changed - Need to repopulate map_tile properties
    metatiles.populate_map_tile_properties();

    metatiles.draw_map__forceblank();

    draw_entities();
}



// Process the game loop
//
// ASSUMES: PPU setup and screen enabled
//
// DB = 0x7e
#[mem8, idx8]
func run_game {

    ^do {
        // Always process player entity first
        x = 0;
        entities.currentEntityId = 0;
        entities.SoA.process_function[unaligned x](x);


        entities.process_active_entities();

        entities.sort_active_entities();

        draw_entities();


        _check_for_room_transition();


        wait_frame();


        // loop until gameMode changes

        // ASSERT: GameModes.RUN_GAME == 0
        a = gameMode as u8;
    } while zero;
}



// Process the game loop
//
// DB = 0x7e
#[mem8, idx8]
func draw_entities() {
    idx16();
    #[idx16] {
        metasprites.draw_shadows();
    }
    idx8();

    entities.draw_active_entities();

    idx16();
    #[idx16] {
        metasprites.finalize_buffer();
    }
    idx8();
}



// Check for a room transition and preform them as required.
//
// DB = 0x7e
#[mem8, idx8]
inline func _check_for_room_transition() {

    a = entities.player.yPos.px;
    if zero {
        // Check if there is a room above this one
        a = currentRoom - 0x10;
        if carry {
            a = GameModes.ROOM_TRANSITION_SCROLL_UP as u8;
            gameMode = a as GameModes;
        }

        // Do not check x axis after loading next room
        return;
    }
    else if a >= DISPLAY_HEIGHT - 1 {
        // Check if there is a room below this one
        a = currentRoom + 0x10;
        if !carry {
            a = GameModes.ROOM_TRANSITION_SCROLL_DOWN as u8;
            gameMode = a as GameModes;
        }

        // Do not check x axis after loading next room
        return;
    }

    a = entities.player.xPos.px;
    if zero {
        // Check if there is a room to the left of this one
        a = currentRoom & 0x0f;
        if !zero {
            a = GameModes.ROOM_TRANSITION_SCROLL_LEFT as u8;
            gameMode = a as GameModes;
        }
    }
    else if a >= DISPLAY_WIDTH - 1 {
        // Check if there is a room to the right of this one
        a = currentRoom & 0x0f;
        if a != 0x0f {
            a = GameModes.ROOM_TRANSITION_SCROLL_RIGHT as u8;
            gameMode = a as GameModes;
        }
    }
}



// Pause the game for a second
//
// DB = 0x7e
#[mem8, idx8]
func wait_one_second() {

    a = FRAMES_PER_SECOND;

    do {
        push8(a);

        wait_frame();

        a = pop8();
        a--;
    } while !zero;
}



// Load the room, fade in the screen
//
// ASSUMES: in Force-Blank
//
// DB = 0x7e
#[mem8, idx8]
func load_room__fadein() {

    _load_room_and_check_if_ok_to_scroll();

    return _room_transition__fadein__room_in_memory();
}



// Blank the screen, load graphics to PPU, fade in the screen, set gameMode to RUN_GAME.
//
// ASSUMES: room is loaded in memory
//
// DB = 0x7e
#[mem8, idx8]
func _room_transition__fadein__room_in_memory() {

    _setup_ppu_and_reset_graphics_subsystems();


    // Fade in
    {
        a = 0 as u8;
        do {
            push8(a);
            wait_frame_and_change_brightness(a);

            a = pop8();
            a++;
        } while a != 16;
    }


    // ::TODO how do I handle a fadein to an invalid room::


    // ::TODO check if player is on a non-solid tile::
    // ::: must be done AFTER tileset is loaded into memory::
    // ::: ::
    // ::: How do I handle this case? ::


    gameMode = GameModes.RUN_GAME;
}



// Blank the screen, then load the next room and resources.
//
// INPUT: currentRoom is set to room to load
//
// DB = 0x7e
#[mem8, idx8]
func room_transition__fadeout() {
    _load_room_and_check_if_ok_to_scroll();

    return _room_transition__fadeout__room_in_memory();
}



// Blank the screen, then load the next room and resources.
//
// ASSUMES: next room is loaded in memory
//
// DB = 0x7e
#[mem8, idx8]
func _room_transition__fadeout__room_in_memory() {

    // Fadeout
    a = 15;
    do {
        push8(a);
        wait_frame_and_change_brightness(a);

        a = pop8();
        a--;
    } while !negative;


    _room_transition__fadein__room_in_memory();


    // ::TODO how do I handle a fadein to an invalid room::


    // ::TODO check if player is on a non-solid tile::
    // ::: must be done AFTER tileset is loaded into memory::
    // ::: ::
    // ::: How do I handle this case? ::
}



// Scroll right room transition.
//
// ASSUMES: There is a room to the right of this one.
//
// DB = 0x7e
#[mem8, idx8]
func room_transition__scroll_right() {

    entities.player.xPos.sx = 0;
    entities.player.xPos.px = a = DISPLAY_WIDTH - 1;


    currentRoom++;

    zero = _load_room_and_check_if_ok_to_scroll();
    if !zero {
        entities.player.xPos.px = a = PLAYER_MAP_TRANSITION_END_POS;

        return _room_transition__fadeout__room_in_memory();
    }


    metatiles.transitions.scroll_right__setup();

    do {
        wait_frame();

        a = entities.player.xPos.px;
        if a == DISPLAY_WIDTH - 1 - H_TRANSITION_FRAMES_BEFORE_SOLID_CHECK * metatiles.transitions.TRANSITION_SPEED {
            negative = metatiles.check_tile_solid(0, entities.player.yPos.px);
            if negative {
                // Tile is solid - cannot place player here
                wait_one_second();

                // Move left one room
                currentRoom--;

                // Rewind room transition
                _load_room_and_check_if_ok_to_scroll();
                return _rollback_room_transition__scroll_right();
            }
        }

        a = entities.player.xPos.px - metatiles.transitions.TRANSITION_SPEED;
        if !carry { a = PLAYER_MAP_TRANSITION_END_POS; }
        entities.player.xPos.px = a;


        draw_entities();


        carry = metatiles.transitions.scroll_right__process();
    }
    while !carry;


    gameMode = GameModes.RUN_GAME;
}



// Rollback a partially completed scroll right room transition.
//
// DB = 0x7e
#[mem8, idx8]
func _rollback_room_transition__scroll_right() {

    do {
        wait_frame();

        a = entities.player.xPos.px + metatiles.transitions.TRANSITION_SPEED;
        if carry { a = DISPLAY_WIDTH - 1 - PLAYER_MAP_TRANSITION_END_POS; }
        entities.player.xPos.px = a;


        draw_entities();


        zero = metatiles.transitions.scroll_right__rollback();
    } while !zero;


    entities.player.xPos.px = a = DISPLAY_WIDTH - 1 - PLAYER_MAP_TRANSITION_END_POS;


    gameMode = GameModes.RUN_GAME;
}



// Scroll left room transition.
//
// ASSUMES: There is a room to the left of this one.
//
// DB = 0x7e
#[mem8, idx8]
func room_transition__scroll_left() {

    entities.player.xPos.sx = 0;
    entities.player.xPos.px = 0;


    currentRoom--;

    zero = _load_room_and_check_if_ok_to_scroll();
    if !zero {
        entities.player.xPos.px = a = DISPLAY_WIDTH - 1 - PLAYER_MAP_TRANSITION_END_POS;

        ^return _room_transition__fadeout__room_in_memory();
    }


    metatiles.transitions.scroll_left__setup();

    do {
        wait_frame();


        a = entities.player.xPos.px;
        if a == H_TRANSITION_FRAMES_BEFORE_SOLID_CHECK * metatiles.transitions.TRANSITION_SPEED {
            negative = metatiles.check_tile_solid(0xff, entities.player.yPos.px);
            if negative {
                // Tile is solid - cannot place player here
                wait_one_second();

                // Move right one room
                currentRoom++;

                // Rewind room transition
                _load_room_and_check_if_ok_to_scroll();
                return _rollback_room_transition__scroll_left();
            }
        }



        a = entities.player.xPos.px + metatiles.transitions.TRANSITION_SPEED;
        if carry { a = DISPLAY_WIDTH - 1 - PLAYER_MAP_TRANSITION_END_POS; }
        entities.player.xPos.px = a;


        draw_entities();


        carry = metatiles.transitions.scroll_left__process();
    }
    while !carry;


    gameMode = GameModes.RUN_GAME;
}



// Rollback a partially completed scroll left room transition.
//
// DB = 0x7e
#[mem8, idx8]
func _rollback_room_transition__scroll_left() {

    do {
        wait_frame();

        a = entities.player.xPos.px - metatiles.transitions.TRANSITION_SPEED;
        if !carry { a = PLAYER_MAP_TRANSITION_END_POS; }
        entities.player.xPos.px = a;


        draw_entities();


        zero = metatiles.transitions.scroll_left__rollback();
    } while !zero;


    entities.player.xPos.px = a = PLAYER_MAP_TRANSITION_END_POS;


    gameMode = GameModes.RUN_GAME;
}



// Scroll down room transition.
//
// ASSUMES: There is a room below this one.
//
// DB = 0x7e
#[mem8, idx8]
func room_transition__scroll_down() {

    entities.player.yPos.sx = 0;
    entities.player.yPos.px = a = DISPLAY_HEIGHT - 1;


    currentRoom = a = currentRoom + 0x10;

    zero = _load_room_and_check_if_ok_to_scroll();
    if !zero {
        entities.player.yPos.px = a = PLAYER_MAP_TRANSITION_END_POS;

        ^return _room_transition__fadeout__room_in_memory();
    }


    metatiles.transitions.scroll_down__setup();

    _room_transition__scroll_down__loop();


    gameMode = GameModes.RUN_GAME;
}



// Process a scroll down room transition (or rollback a scroll up room transition)
//
// ASSUMES: `metatiles.transitions.scroll_down__setup()` or `metatiles.transitions.scroll_up__setup()` has been called.
//
// DB = 0x7e
#[mem8, idx8]
func _room_transition__scroll_down__loop() {
    do {
        wait_frame();

        a = entities.player.yPos.px;
        if a == DISPLAY_HEIGHT - 1 - V_TRANSITION_FRAMES_BEFORE_SOLID_CHECK * metatiles.transitions.TRANSITION_SPEED {
            negative = metatiles.check_tile_solid(entities.player.xPos.px, 0);
            if negative {
                // Tile is solid - cannot place player here
                wait_one_second();

                // Move up one room
                currentRoom = a = currentRoom - 0x10;

                // Rewind down transition
                _load_room_and_check_if_ok_to_scroll();
                return _room_transition__scroll_up__loop();
            }
        }

        a = entities.player.yPos.px - metatiles.transitions.TRANSITION_SPEED;
        if !carry { a = PLAYER_MAP_TRANSITION_END_POS; }
        entities.player.yPos.px = a;


        draw_entities();


        carry = metatiles.transitions.scroll_down__process();
    }
    while !carry;


    entities.player.yPos.px = a = PLAYER_MAP_TRANSITION_END_POS;
}



// Scroll up room transition.
//
// ASSUMES: There is a room above this one.
//
// DB = 0x7e
#[mem8, idx8]
func room_transition__scroll_up() {

    entities.player.yPos.sx = 0;
    entities.player.yPos.px = 0;


    currentRoom = a = currentRoom - 0x10;

    zero = _load_room_and_check_if_ok_to_scroll();
    if !zero {
        entities.player.yPos.px = a = DISPLAY_HEIGHT - 1 - PLAYER_MAP_TRANSITION_END_POS;

        ^return _room_transition__fadeout__room_in_memory();
    }


    metatiles.transitions.scroll_up__setup();

    _room_transition__scroll_up__loop();


    gameMode = GameModes.RUN_GAME;
}



// Process a scroll up room transition (or rollback a scroll down room transition)
//
// ASSUMES: `metatiles.transitions.scroll_down__setup()` or `metatiles.transitions.scroll_up__setup()` has been called.
//
// DB = 0x7e
#[mem8, idx8]
func _room_transition__scroll_up__loop() {

let MAX_PLAYER_YPOS = DISPLAY_HEIGHT - 1 - PLAYER_MAP_TRANSITION_END_POS;

    do {
        wait_frame();

        a = entities.player.yPos.px;
        if a == V_TRANSITION_FRAMES_BEFORE_SOLID_CHECK * metatiles.transitions.TRANSITION_SPEED {
            negative = metatiles.check_tile_solid(entities.player.xPos.px, DISPLAY_HEIGHT - 1);
            if negative {
                // Tile is solid - cannot place player here
                wait_one_second();

                // Move down one room
                currentRoom = a = currentRoom + 0x10;

                // Rewind up transition
                _load_room_and_check_if_ok_to_scroll();
                ^return _room_transition__scroll_down__loop();
            }
        }


        a = entities.player.yPos.px + metatiles.transitions.TRANSITION_SPEED;
        if a >= MAX_PLAYER_YPOS + 1 { a = MAX_PLAYER_YPOS; }
        entities.player.yPos.px = a;

        draw_entities();


        carry = metatiles.transitions.scroll_up__process();
    }
    while !carry;


    entities.player.yPos.px = a = MAX_PLAYER_YPOS;
}


}

}

