// Copyright (c) 2021, Marcus Rowe <undisbeliever@gmail.com>.
// Distributed under The MIT License, see the LICENSE file for more details.

import "memmap";
import "room";
import "common/dma";

import "gen/resources";

import "../wiz/common/snes/snes";


namespace resources {

// order MUST match `RESOURCE_TYPES` in `tools/generate-resources-wiz.py`
//        and match `RESOURCE_TYPES` in `tools/insert-resources.py`
enum ResourceType : u8 {
  mt_tileset,
  ms_spritesheet,
  tiles,
};


struct ResourceEntry {
    // ::TODO indicate compressed data::

    farPtr  : far *u8,
    size    : u16,
};


// Hack to provide access into `resourceEntries` fields by `unaligned xx` addressing.
//
// ASSUMES `radata0` is in bank 0xc1.
namespace _RE {
    let addr        = 0xc10000 as far *u16;
    let addrBank    = 0xc10002 as far *u8;
    let size        = 0xc10003 as far *u16;
};


in rodata0 {
    let N_RESOURCE_TYPES = resources.n_resources_per_type.len;

    // Number of resources for each resource resource type.
    // (byte ROM table)
    const __NResourcesPerTypeTable : [ u8 ] = [ i for let i in resources.n_resources_per_type ];
    let NResourcesPerTypeTable = far &__NResourcesPerTypeTable as far *u8;

    // resource entry = ResourceEntryTable[type][resourceId]
    const __ResourceEntryTable : [ *const u8 ] = [
        @[ 0u8 ; sizeof(ResourceEntry) * i ] for let i in resources.n_resources_per_type
    ];
    let ResourceEntryTable = far &__ResourceEntryTable as far * const *ResourceEntry;


    let INVALID_ROOM_ADDR = 0xffff;

    // Table of room addresses.
    //
    // If a room address is `INVALID_ROOM_ADDR` the room does not exist.
    //
    // (256 word address, pointing to RoomData)
    const __RoomsTable : [ *const RoomData ; 0x100 ] = [ INVALID_ROOM_ADDR as *const RoomData ; 0x100 ];
    let RoomsTable = far &__RoomsTable as far * const * RoomData;
}


in zeropage {
    var res : ResourceEntry;
}



in code {


// Load a MetaTile tileset resource.
//
// DB unknown
#[mem8, idx16]
func load_mt_tileset(resourceId : u8 in a) : ResourceEntry in res {
    return __load_resource(ResourceType.mt_tileset as u16, a);
}



// Load a MetaSprite spritesheet resource.
//
// DB unknown
#[mem8, idx16]
func load_ms_spritesheet(resourceId : u8 in a) : ResourceEntry in res {
    return __load_resource(ResourceType.ms_spritesheet as u16, a);
}



// Load a tiles resource.
//
// DB unknown
#[mem8, idx16]
func load_tiles_resource(resourceId : u8 in a) : ResourceEntry in res {
    return __load_resource(ResourceType.tiles as u16, a);
}



// Load a resource
//
// ASSUMES: type is always valid
//
// DB unknown
#[mem8, idx16]
func __load_resource(type : u16 in xx, resourceId : u8 in a) : ResourceEntry in res {

    // This function MUST ONLY use zeropage variables

    if a >= NResourcesPerTypeTable[xx] {
        a = 0;
    }

    // Remove high bytes of index registers
    idx8();
    #[idx8] {
        y = a;
    }

    mem16_idx16();
    #[mem16] {
        // No need to mask high byte of `xx`, it is always 0
        xx = aa = xx << 1;

        // Multiply yy by 5
        // No need to mask high byte of `yy`, it is always 0
        // Reuse res.size as temporary variable, ensure all zeropage variables are unused
        // +# is safe: carry always clear
        res.size = aa = yy;
        aa = (aa << 2) +# res.size;

        xx = aa = aa + ResourceEntryTable[unaligned xx] as u16;

        // X = address of ResourceEntry

        res.size = aa = _RE.size[unaligned xx];

        *(&res.farPtr as *u16) = aa = _RE.addr[unaligned xx];

        aa = (_RE.addrBank as far *u16)[unaligned xx];
    }
    mem8();

    #:res.farPtr = a;

    return res;
}



// Load a room into memory
//
// DB = 0x7e
#[mem8, idx8]
func load_room(roomId : u8 in a) : bool in carry {

    debug_break();

    mem16_idx16();
    #[mem16, idx16] {
        xx = aa = (aa & 0xff) << 1;

        aa = RoomsTable[unaligned xx] as u16;
        if aa == INVALID_ROOM_ADDR {
            mem8_idx8();
            return false;
        }

        *(&res.farPtr as *u16) = aa;
    }
    mem8();

    #[idx16] {
        #:res.farPtr = a = ROOM_DATA_BANK;

        // Copy room into memory.
        yy = sizeof(typeof(room)) - 1;
        do {
            (&room as *u8)[yy] = a = res.farPtr[yy];
            yy--;
        } while !negative;
    }
    mem8_idx8();

    return true;
}



// Load a tiles resource into VRAM.
//
// REQUIRES: Force-Blank
// Uses DMA Channel 0
//
// DB = 0x80
#[mem8, idx16]
func load_tiles_resource_into_vram(resourceId : resources.tiles in a, vramWordAddr : u16 in xx) {

    snes.ppu.vram_address_hl = xx;

    res = __load_resource(ResourceType.tiles as u16, a);

    ^return dma.transfer_to_vram__forceblank(#:res.farPtr, *(&res.farPtr as *u16), res.size);
}


let load_tiles_resource_into_vram_a = load_tiles_resource_into_vram as func(u8 in a, u16 in xx);




// Transfer the first `size` bytes of resource data into Work-RAM bank 0x7e.
//
// ASSUMES: resource size > size
// Uses DMA channel 0
//
// DB = 0x80
#[mem8, idx16]
func transfer_resource_header_to_wram7e(_resourceData : ResourceEntry in res, ptr : u16 in xx, size : u16 in yy)
{
    // Assumes res.farPtr is not Work-RAM.
    // ::TODO slow path if `res.farPtr` bank is a Work-RAM address::

    snes.wram.address_hl = xx;
    snes.wram.address_bank = a = 0x7e;

    snes.dma0.control = a = snes.dma.CONTROL_MODE_A;
    snes.dma0.mdma_dest = a = <:&snes.wram.data;
    snes.dma0.mdma_size_hl = yy;

    snes.dma0.src_address_hl = xx = *(&res.farPtr as *u16);
    snes.dma0.src_address_bank = a = #:res.farPtr;

    snes.dma.mdma_enable = a = snes.dma.ENABLE_0;
}



// Transfer palette data from resource data into CGRAM.
//
// NOTE: The size and location of the palette data is fixed.
//
// ASSUMES: _resourceData.size >= offset + size
//
// REQUIRES: Force-Blank
// REQUIRES: `snes.ppu.cgram_address` set
// Uses DMA channel 0
//
// DB = 0x80
#[mem8, idx16]
inline func transfer_resource_palette__forceblank(_resourceData : ResourceEntry in res,
                                                  let offset : u16, let size : u16) {
    mem16();
    #[mem16] {
        xx = aa = *(&res.farPtr as *u16) + offset;
    }
    mem8();

    dma.transfer_to_cgram__forceblank(#:res.farPtr, xx, size);
}



// Transfer the tail-end of the resource data to VRAM, starting at `offset`.
//
// NOTE: The number of bytes to transfer is determined by the resource data size (`_resourceData.size - offset`
//
// ASSUMES: _resourceData.size > offset.
//
// REQUIRES: Force-Blank
// REQUIRES: `snes.ppu.vram_address_hl` set
// Uses DMA Channel 0
//
// DB = 0x80
#[mem8, idx16]
inline func transfer_resource_tail_to_vram__forceblank(_resourceData : ResourceEntry in res, let offset : u16)
{
    mem16();
    #[mem16] {
        // addr
        xx = aa = *(&res.farPtr as *u16) + offset;

        // size
        yy = aa = res.size - offset;
    }
    mem8();

    dma.transfer_to_vram__forceblank(#:res.farPtr, xx, yy);
}


}



// Rooms
// =====

namespace rooms {
    let STARTING_ROOM = _STARTING_ROOM;
}

}

