// Copyright (c) 2021, Marcus Rowe <undisbeliever@gmail.com>.
// Distributed under The MIT License, see the LICENSE file for more details.

import "memmap";
import "room";
import "common/dma";

import "gen/resources";

import "../wiz/common/snes/snes";


namespace resources {

// order MUST match `RESOURCE_TYPES` in `tools/generate-resources-wiz.py`
//        and match `RESOURCE_TYPES` in `tools/insert-resources.py`
enum ResourceType : u8 {
  mt_tileset,
  ms_spritesheet,
  tiles,
};


struct ResourceEntry {
    // ::TODO indicate compressed data::

    farPtr  : far *u8,
    size    : u16,
};


// Hack to provide access into `resourceEntries` fields by `unaligned xx` addressing.
//
// ASSUMES `radata0` is in bank 0xc1.
namespace _RE {
    let addr        = 0xc10000 as far *u16;
    let addrBank    = 0xc10002 as far *u8;
    let size        = 0xc10003 as far *u16;
};


in rodata0 {
    let N_RESOURCE_TYPES = resources.n_resources_per_type.len;

    // Number of resources for each resource resource type.
    // (byte ROM table)
    const __NResourcesPerTypeTable : [ u8 ] = [ i for let i in resources.n_resources_per_type ];
    let NResourcesPerTypeTable = far &__NResourcesPerTypeTable as far *u8;

    // resource entry = ResourceEntryTable[type][resourceId]
    const __ResourceEntryTable : [ *const u8 ] = [
        @[ 0u8 ; sizeof(ResourceEntry) * i ] for let i in resources.n_resources_per_type
    ];
    let ResourceEntryTable = far &__ResourceEntryTable as far * const *ResourceEntry;


    let INVALID_ROOM_ADDR = 0xffff;

    // Table of room addresses.
    //
    // If a room address is `INVALID_ROOM_ADDR` the room does not exist.
    //
    // (256 word address, pointing to RoomData)
    const __RoomsTable : [ *const RoomData ; 0x100 ] = [ INVALID_ROOM_ADDR as *const RoomData ; 0x100 ];
    let RoomsTable = far &__RoomsTable as far * const * RoomData;
}


in zeropage {
    var res : ResourceEntry;
}



in code {


// Load a resource
//
// ASSUMES: type is always valid
//
// DB unknown
#[mem8, idx8]
func load_resource(type : ResourceType in x, resourceId : u8 in a) : ResourceEntry in res {

    // This function MUST ONLY use zeropage variables

    if a >= NResourcesPerTypeTable[x] {
        a = 0;
    }
    y = a;

    mem16_idx16();
    #[mem16, idx16] {
        // No need to mask high byte of `xx`, it is always 0
        xx = aa = xx << 1;

        // Multiply yy by 5
        // No need to mask high byte of `yy`, it is always 0
        // Reuse res.size as temporary variable, ensure all zeropage variables are unused
        // +# is safe: carry always clear
        res.size = aa = yy;
        aa = (aa << 2) +# res.size;

        xx = aa = aa + ResourceEntryTable[unaligned xx] as u16;

        // X = address of ResourceEntry

        res.size = aa = _RE.size[unaligned xx];

        *(&res.farPtr as *u16) = aa = _RE.addr[unaligned xx];

        aa = (_RE.addrBank as far *u16)[unaligned xx];
    }
    mem8_idx8();

    #:res.farPtr = a;

    return res;
}



// Load a room into memory
//
// DB = 0x7e
#[mem8, idx8]
func load_room(roomId : u8 in a) : bool in carry {

    debug_break();

    mem16_idx16();
    #[mem16, idx16] {
        xx = aa = (aa & 0xff) << 1;

        aa = RoomsTable[unaligned xx] as u16;
        if aa == INVALID_ROOM_ADDR {
            mem8_idx8();
            return false;
        }

        *(&res.farPtr as *u16) = aa;
    }
    mem8();

    #[idx16] {
        #:res.farPtr = a = ROOM_DATA_BANK;

        // Copy room into memory.
        yy = sizeof(typeof(room)) - 1;
        do {
            (&room as *u8)[yy] = a = res.farPtr[yy];
            yy--;
        } while !negative;
    }
    mem8_idx8();

    return true;
}



// Load a tiles resource into VRAM.
//
// REQUIRES: Force-Blank
//
// DB = 0x80
#[mem8, idx16]
func load_tiles_resource_into_vram(resourceId : resources.tiles in a, vramWordAddr : u16 in xx) {

    snes.ppu.vram_address_hl = xx;

    mem8_idx8();
    #[mem8, idx8] {
        res = load_resource(ResourceType.tiles, a);
    }
    idx16();

    ^return dma.transfer_to_vram__forceblank(#:res.farPtr, *(&res.farPtr as *u16), res.size);
}


let load_tiles_resource_into_vram_a = load_tiles_resource_into_vram as func(u8 in a, u16 in xx);


}



// Rooms
// =====

namespace rooms {
    let STARTING_ROOM = _STARTING_ROOM;
}

}

