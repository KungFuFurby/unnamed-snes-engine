// Copyright (c) 2021, Marcus Rowe <undisbeliever@gmail.com>.
// Distributed under The MIT License, see the LICENSE file for more details.

import "memmap";

import "gen/rooms";
import "gen/resources";


namespace resources {

// order MUST match `RESOURCE_TYPES` in `tools/generate-resources-wiz.py`
//        and match `RESOURCE_TYPES` in `tools/insert-resources.py`
enum ResourceType : u8 {
  mt_tileset,
  ms_spritesheet,
};


struct ResourceEntry {
    // ::TODO indicate compressed data::

    farPtr  : far *u8,
    size    : u16,
};


// Hack to provide access into `resourceEntries` fields by `unaligned xx` addressing.
//
// ASSUMES `radata0` is in bank 0xc1.
namespace _RE {
    let addr        = 0xc10000 as far *u16;
    let addrBank    = 0xc10002 as far *u8;
    let size        = 0xc10003 as far *u16;
};


in rodata0 {
    let N_RESOURCE_TYPES = resources.n_resources_per_type.len;

    // Number of resources for each resource resource type.
    // (byte ROM table)
    const __NResourcesPerTypeTable : [ u8 ] = [ i for let i in resources.n_resources_per_type ];
    let NResourcesPerTypeTable = far &__NResourcesPerTypeTable as far *u8;

    // resource entry = ResourceEntryTable[type][resourceId]
    const __ResourceEntryTable : [ *const u8 ] = [
        @[ 0u8 ; sizeof(ResourceEntry) * i ] for let i in resources.n_resources_per_type
    ];
    let ResourceEntryTable = far &__ResourceEntryTable as far * const *ResourceEntry;
}


in zeropage {
    var res : ResourceEntry;
}



in code {


// Load a resource
//
// ASSUMES: type is always valid
//
// DB unknown
#[mem8, idx8]
func load_resource(type : ResourceType in x, resourceId : u8 in a) : ResourceEntry in res {

    // This function MUST ONLY use zeropage variables

    if a >= NResourcesPerTypeTable[x] {
        a = 0;
    }
    y = a;

    mem16_idx16();
    #[mem16, idx16] {
        // No need to mask high byte of `xx`, it is always 0
        xx = aa = xx << 1;

        // Multiply yy by 5
        // No need to mask high byte of `yy`, it is always 0
        // Reuse res.size as temporary variable, ensure all zeropage variables are unused
        // +# is safe: carry always clear
        res.size = aa = yy;
        aa = (aa << 2) +# res.size;

        xx = aa = aa + ResourceEntryTable[unaligned xx] as u16;

        // X = address of ResourceEntry

        res.size = aa = _RE.size[unaligned xx];

        *(&res.farPtr as *u16) = aa = _RE.addr[unaligned xx];

        aa = (_RE.addrBank as far *u16)[unaligned xx];
    }
    mem8_idx8();

    #:res.farPtr = a;

    return res;
}


}





// Resource Data
// =============

namespace ms_ppu_data {
in rodata0 {
    const shadow_tiles = embed "gen/metasprites/shadows-4bpp-tiles.tiles";
}
}


namespace ui {
in rodata0 {
    const tiles = embed "gen/tilesets/ui-2bpp-tiles.tiles";
}
}



// Rooms
// =====

namespace rooms {
    let N_ROOMS = sizeof(typeof(_rooms)) / sizeof(typeof(_rooms[0]));

in rodata0 {
    const _room_list_l : [u8] = [<:&_rooms[i] for let i in 0..N_ROOMS];
    const _room_list_h : [u8] = [>:&_rooms[i] for let i in 0..N_ROOMS];
}

    let room_list_l = far &_room_list_l as far *const u8;
    let room_list_h = far &_room_list_h as far *const u8;
    let room_list_bank = #:far &_rooms;


    let room_table = far &_room_table as far *const u8;

    let STARTING_ROOM = _STARTING_ROOM;
}

}

