// Copyright (c) 2021, Marcus Rowe <undisbeliever@gmail.com>.
// Distributed under The MIT License, see the LICENSE file for more details.

import "memmap";

import "room";
import "resources";
import "gameloop";
import "wait-frame";

import "player";

import "entities/_variables";

import "../wiz/common/snes/snes";

import "../gen/interactive-tiles.wiz";


namespace metatiles {

let METATILE_SIZE = 16;

let MAP_WIDTH = ROOM_MAP_WIDTH;
let MAP_HEIGHT = ROOM_MAP_HEIGHT;

let MAP_WIDTH_PIXELS = MAP_WIDTH * METATILE_SIZE;
let MAP_HEIGHT_PIXELS = MAP_HEIGHT * METATILE_SIZE;


let TILE_PROPERTY_SOLID_BIT = 7;


// Tileset data stored in RAM
struct _Tileset {
    // Mapping of each of the 4 tiles within each MetaTile.
    topLeft_low :      [u8 ; 256],
    topLeft_high :     [u8 ; 256],
    topRight_low :     [u8 ; 256],
    topRight_high :    [u8 ; 256],
    bottomLeft_low :   [u8 ; 256],
    bottomLeft_high :  [u8 ; 256],
    bottomRight_low :  [u8 ; 256],
    bottomRight_high : [u8 ; 256],

    // Tile properties for each MetaTile
    // (`TILE_PROPERTY_*_BIT` bitfield for each tile)
    properties:        [u8 ; 256],
};


// Tileset data format in ROM.
struct _DataFormat {
    tile_data_size : u16,

    ram_data : _Tileset,

    palette_data : [u16 ; 128],

    tile_data : u8,
};


in zeropage {

}


in shadow {
    // MetaTiles to draw on the next VBlank.
    //
    // Array of word structures
    namespace DrawTileBuffer {
        let BUFFER_SIZE = 8;


        var vramWordAddr : [u16 ; BUFFER_SIZE];

        var topLeft     : [u16 ; BUFFER_SIZE];
        var topRight    : [u16 ; BUFFER_SIZE];
        var bottomLeft  : [u16 ; BUFFER_SIZE];
        var bottomRight : [u16 ; BUFFER_SIZE];
    }

    // Current position with `DrawTileBuffer`.
    // (byte index, increment by 2)
    var drawTileBufferIndex : u8;
}


in wram7e {
    // The map for the current room.
    //
    // NOTE: Whenever the map is updated the corresponding `mapTileProperties` cells must be changed.
    let map = room.map;


    // The MetaTile tileset tile properties for each map tile.
    //
    // (bitfield of `TILE_PROPERTY_*_BIT`s for each map tile.)
    //
    // Whenever the map is updated the corresponding `mapTileProperties` cells must be changed.
    #[align(256)]
    var mapTileProperties : [u8 ; 256];


    // this hack allows me to write `tileset.topLeft[y]` without a compile error.
    #[align(256)]
    var __far_tileset : _Tileset;
    let tileset = *(&__far_tileset as *_Tileset);
}


in code {


// Load a tileset into memory and the PPU
//
// REQUIRES: Force-Blank
// Uses DMA channel 0
//
// NOTE: tileset address cannot be in RAM.
//
// DB = 0x80
#[mem8, idx16]
func load_tileset__forceblank(tileset_id : u8 in a) {
let _tilesetPtr = zpTmp_farPtr;

    snes.dma.hdma_enable = 0;

    idx8();
    #[idx8] {
        x = a;
        if x >= resources.metatile_tilesets.N_TILESETS {
            x = 0;
        }

        <:_tilesetPtr = a = resources.metatile_tilesets.tileset_list_l[x];
        >:_tilesetPtr = a = resources.metatile_tilesets.tileset_list_h[x];
        #:_tilesetPtr = a = resources.metatile_tilesets.tileset_list_b[x];
    }
    idx16();


    // A = _tilesetPtr bank
    xx = *(&_tilesetPtr as *u16);

    // Skip _DataFormat.tile_data_size in DMA's below
    xx++;
    xx++;

    snes.dma0.src_address_bank = a;
    snes.dma0.src_address_hl = xx;


    // Copy first data block (tileset) into RAM
    snes.wram.address_hl = xx = &tileset as u16;
    snes.wram.address_bank = a = (#:far &__far_tileset) & 1;

    snes.dma0.control = a = snes.dma.CONTROL_MODE_A;
    snes.dma0.mdma_dest = a = <:&snes.wram.data;
    snes.dma0.mdma_size_hl = xx = sizeof(_Tileset);

    snes.dma.mdma_enable = a = snes.dma.ENABLE_0;


    // Load palette to CGRAM
    snes.ppu.cgram_address = 0;

    snes.dma0.mdma_dest = a = <:&snes.ppu.cgram_write_data;
    snes.dma0.mdma_size_hl = yy = 128 * 2;

    snes.dma.mdma_enable = a = snes.dma.ENABLE_0;


    // Load tiles into VRAM
    snes.ppu.vram_control = a = snes.ppu.VRAM_CONTROL_INCREMENT_1 | snes.ppu.VRAM_CONTROL_REMAP_MODE_0 | snes.ppu.VRAM_CONTROL_SIZE_2;
    snes.ppu.vram_address_hl = xx = VRAM_BG1_TILES_WADDR;

    snes.dma0.control = a = snes.dma.CONTROL_MODE_AB;
    snes.dma0.mdma_dest = a = <:&snes.ppu.vram_write_data_l;

    mem16();
    #[mem16] {
        snes.dma0.mdma_size_hl = aa = **(&_tilesetPtr as *far *u16);
    }
    mem8();

    snes.dma.mdma_enable = a = snes.dma.ENABLE_0;
}



// Draws the entire map to BG1.
//
// REQUIRES: Force-Blank, Tileset loaded into memory.
//
// DB = 0x7e
#[mem8, idx8]
func draw_map__forceblank() {
let _rowsLeft    = zpTmp_byte_0;
let _columnsLeft = zpTmp_byte_1;

    push8(data_bank);

    push8(program_bank);
    data_bank = pop8();
// DB = 0x80

    snes.ppu.brightness = a = snes.ppu.BRIGHTNESS_FORCE_BLANK | snes.ppu.BRIGHTNESS_MASK;

    snes.ppu.vram_control = a = snes.ppu.VRAM_CONTROL_INCREMENT_1 | snes.ppu.VRAM_CONTROL_REMAP_MODE_0 | snes.ppu.VRAM_CONTROL_SIZE_2;
    snes.ppu.vram_address_l = <:VRAM_BG1_MAP_WADDR;
    snes.ppu.vram_address_h = >:VRAM_BG1_MAP_WADDR;



    push8(a = 0x7e);
    data_bank = pop8();
// DB = 0x7e


    // ::TODO setup variables::


    // X = map position
    x = 0;

    _rowsLeft = a = MAP_HEIGHT;
    do {
        push8(x);

        _columnsLeft = a = MAP_WIDTH;
        do {
            y = map[x];

            *(far &snes.ppu.vram_write_data_l) = a = tileset.topLeft_low[y];
            *(far &snes.ppu.vram_write_data_h) = a = tileset.topLeft_high[y];
            *(far &snes.ppu.vram_write_data_l) = a = tileset.topRight_low[y];
            *(far &snes.ppu.vram_write_data_h) = a = tileset.topRight_high[y];

            x++;
            _columnsLeft--;
        } while !zero;

        x = pop8();

        _columnsLeft = a = MAP_WIDTH;
        do {
            y = map[x];

            *(far &snes.ppu.vram_write_data_l) = a = tileset.bottomLeft_low[y];
            *(far &snes.ppu.vram_write_data_h) = a = tileset.bottomLeft_high[y];
            *(far &snes.ppu.vram_write_data_l) = a = tileset.bottomRight_low[y];
            *(far &snes.ppu.vram_write_data_h) = a = tileset.bottomRight_high[y];

            x++;
            _columnsLeft--;
        } while !zero;


        _rowsLeft--;
    } while !zero;


    data_bank = pop8();
// DB = 0x7e


    transitions._reset_state();

    drawTileBufferIndex = 0;
}



// Populate the `mapTileProperties` array.
//
// This function MUST be called when the map or MetaTile tileset is loaded.
//
// ASSUMES: The room is valid
//
// DB = 0x7e
#[mem8, idx8]
func populate_map_tile_properties() {

    x = sizeof(typeof(map)) - 1;
    do {
        y = map[x];
        mapTileProperties[x] = a = tileset.properties[y];

        x--;
    } while !zero;

    y = map[0];
    mapTileProperties[0] = a = tileset.properties[y];


    // Clear tiles outside map
    x = sizeof(typeof(map));
    do {
        mapTileProperties[x] = 0;
        x++;
    } while !zero;
}



// Populate the `mapTileProperties` array with solid tiles.
//
// This function MUST be called when the map or MetaTile tileset is loaded.
//
// ASSUMES: The room map is invalid
//
// DB = 0x7e
#[mem8, idx8]
func populate_map_tile_properties__all_tiles_solid() {
    // Fill the `mapTileProperties` array with solid tiles.

    a = 1 << TILE_PROPERTY_SOLID_BIT;

    x = 0;
    do {
        mapTileProperties[x] = a;

        x++;
    } while !zero;
}



// DrawTileBuffer functions
// ========================


// Update the tiles in VRAM that were changed by `set_tile`.
//
// REQUIRES: V-Blank
//
// DB = shadow
//
// DB = 0x7e
#[mem16, idx8]
inline func process_draw_tile_buffer__vblank() {
    x = drawTileBufferIndex;
    if !zero {
        snes.ppu.vram_control = y = snes.ppu.VRAM_CONTROL_INCREMENT_1 | snes.ppu.VRAM_CONTROL_REMAP_MODE_0 | snes.ppu.VRAM_CONTROL_SIZE_2;

        x--;
        x--;

        do {
            snes.ppu.vram_address_hl = aa = DrawTileBuffer.vramWordAddr[unaligned x];

            snes.ppu.vram_write_data_hl = aa = DrawTileBuffer.topLeft[unaligned x];
            snes.ppu.vram_write_data_hl = aa = DrawTileBuffer.topRight[unaligned x];


            snes.ppu.vram_address_hl = aa = DrawTileBuffer.vramWordAddr[unaligned x] | 32;

            snes.ppu.vram_write_data_hl = aa = DrawTileBuffer.bottomLeft[unaligned x];
            snes.ppu.vram_write_data_hl = aa = DrawTileBuffer.bottomRight[unaligned x];

            x--;
            x--;
        } while !negative;

        drawTileBufferIndex = x = 0;
    }
}



// Set a tile within the map.
//
// Also updates `mapTileProperties` and queues a new entry in the DrawTileBuffer.
//
// NOTE: This function may fail if the DrawTileBuffer is full
//
// NOTE: This function returns true if `tileIndex` is out of bounds.
//       The map will remain unchanged.
//
// DB = 0x7e
#[mem8, idx8]
func set_tile(tileIndex : u8 in y, tile : u8 in a) : bool in carry {
let _tmp    = zpTmp_word_0;

    if y < sizeof(typeof(map)) {

        x = drawTileBufferIndex;
        if x < sizeof(typeof(DrawTileBuffer.vramWordAddr)) {

            map[y] = a;

            // Calculate VRAM word address
            mem16();
            #[mem16] {
                #[idx16] { aa = yy; }
                _tmp = aa = (aa & 0x0f) << 1;

                #[idx16] { aa = yy; }
                aa = ((aa & 0xf0) << 2) | _tmp;
                aa = (aa + transitions.vramVerticalWoffset) & 0x3ff;
                aa |= transitions.currentTilemap_vramWaddr;

                // X = drawTileBufferIndex
                DrawTileBuffer.vramWordAddr[unaligned x] = aa;
            }
            mem8_idx8();


            // Update mapTileProperties
            x = map[y];
            mapTileProperties[y] = a = tileset.properties[x];


            y = drawTileBufferIndex;

            (&<:DrawTileBuffer.topLeft[0] as *u8)[unaligned y] = a = tileset.topLeft_low[x];
            (&>:DrawTileBuffer.topLeft[0] as *u8)[unaligned y] = a = tileset.topLeft_high[x];
            (&<:DrawTileBuffer.topRight[0] as *u8)[unaligned y] = a = tileset.topRight_low[x];
            (&>:DrawTileBuffer.topRight[0] as *u8)[unaligned y] = a = tileset.topRight_high[x];
            (&<:DrawTileBuffer.bottomLeft[0] as *u8)[unaligned y] = a = tileset.bottomLeft_low[x];
            (&>:DrawTileBuffer.bottomLeft[0] as *u8)[unaligned y] = a = tileset.bottomLeft_high[x];
            (&<:DrawTileBuffer.bottomRight[0] as *u8)[unaligned y] = a = tileset.bottomRight_low[x];
            (&>:DrawTileBuffer.bottomRight[0] as *u8)[unaligned y] = a = tileset.bottomRight_high[x];

            y++;
            y++;
            drawTileBufferIndex = y;

            return true;
        }
        else {
            return false;
        }
    }

    // Ignore all out of bounds writes.
    return true;
}



// ::TODO add set_tile_4by4(tileIndex : y) ::



// Interactive Tiles
// =================


// Process any interactive tiles that the player might be touching.
//
// SHOULD ONLY be called inside the player's process function.
//
// DB = 0x7e
#[mem8, idx8]
func process_interactive_tiles__player() {
let _tmp    = zpTmp_byte_0;

    _tmp = a = player.xPos.px >>> 4;
    y = a = (player.yPos.px & 0xf0) | _tmp;

    x = a = mapTileProperties[y] & interactive_tiles.FUNCTION_TABLE_MASK;

    interactive_tiles.player_touches_tile_function_table[unaligned x](y);


    // Interactions with solid tiles are only preformed on the tile at the player's
    // origin point.  The tile (if any) to the left or right will not be interacted with.
    //
    // ::TODO throughly test if this works as expected::

    a = player.movementState;
    if a & entities.MovementState.LEFT_COLLISION != 0 {
        // left = xPos - 1 - tileHitbox_halfWidth (with clamping)
        a = player.xPos.px;
        if !zero {
            a--;
            a -= player.tileHitbox_halfWidth;
            if !carry { a = 0; }
        }

        _tmp = a = a >>> 4;
        y = a = (player.yPos.px & 0xf0) | _tmp;

        x = a = mapTileProperties[y] & interactive_tiles.FUNCTION_TABLE_MASK;
        return interactive_tiles.player_tile_collision_function_table[unaligned x](y);

        a = player.movementState;

    }
    else if a & entities.MovementState.RIGHT_COLLISION != 0 {
        // right = xPos + 1 + tileHitbox_halfWidth (with clamping)

        a = player.xPos.px;
        a++;
        if zero {
            a = 0xff;
        }
        else {
            a += player.tileHitbox_halfWidth;
            if carry { a = 0xff; }
        }

        _tmp = a = a >>> 4;
        y = a = (player.yPos.px & 0xf0) | _tmp;

        x = a = mapTileProperties[y] & interactive_tiles.FUNCTION_TABLE_MASK;
        return interactive_tiles.player_tile_collision_function_table[unaligned x](y);

        a = player.movementState;
    }


    // A is player.movementState
    if a & entities.MovementState.UP_COLLISION != 0 {
        _tmp = a = player.xPos.px >>> 4;

        // top = yPos - 1 - tileHitbox_halfHeight (with clamping)
        a = player.yPos.px;
        if !zero {
            a--;
            a -= player.tileHitbox_halfHeight;
            if !carry { a = 0; }
        }

        y = a = (a & 0xf0) | _tmp;

        x = a = mapTileProperties[y] & interactive_tiles.FUNCTION_TABLE_MASK;
        return interactive_tiles.player_tile_collision_function_table[unaligned x](y);

    }
    else if a & entities.MovementState.DOWN_COLLISION != 0 {
        _tmp = a = player.xPos.px >>> 4;

        // bottom = yPos + 1 + tileHitbox_halfHeight (with clamping)
        a = player.yPos.px;
        a++;
        if zero {
            a = 0xff;
        }
        else {
            a += player.tileHitbox_halfHeight;
            if carry { a = 0xff; }
        }

        y = a = (a & 0xf0) | _tmp;

        x = a = mapTileProperties[y] & interactive_tiles.FUNCTION_TABLE_MASK;
        return interactive_tiles.player_tile_collision_function_table[unaligned x](y);
    }
}



// Collisions
// ==========



// Check if a tile at a given position is solid
//
// DB = 0x7e
#[mem8, idx8]
func check_tile_solid(xPos : u8 in x, yPos : u8 in y) : bool in negative {
let _tmp    = zpTmp_byte_0;

    _tmp = a = x >>> 4;
    x = a = (y & 0xf0) | _tmp;

    bit(mapTileProperties[x]);
    return negative;
}



// Tests if the player is touching a solid tile.
//
// NOTE: This only checks the four corners of the player's tile hitbox.
//
// ASSUMES: The player's tile hitbox's half-width and half-height is <= 8.
//
// DB = 0x7e
#[mem8, idx8]
func test_if_player_touches_a_solid_tile() : bool in negative {

let _tmp          = zpTmp_byte_0;
let _topMasked    = zpTmp_byte_1;
let _bottomMasked = zpTmp_byte_2;


    // Left tiles
    a = player.xPos.px - player.tileHitbox_halfWidth;
    if !carry { a = 0; }
    _tmp = a = a >>> 4;


    // Test Top-left tile
    a = player.yPos.px - player.tileHitbox_halfHeight;
    if !carry { a = 0; }
    _topMasked = a = a & 0xf0;
    x = a = a | _tmp;

    bit(mapTileProperties[x]);
    goto Return if negative;


    // Test bottom-left tile
    a = player.yPos.px + player.tileHitbox_halfHeight;
    if carry { a = 0xff; }
    _bottomMasked = a = a & 0xf0;
    x = a = a | _tmp;

    bit(mapTileProperties[x]);
    goto Return if negative;


    // Right tiles
    a = player.xPos.px + player.tileHitbox_halfWidth;
    if carry { a = 0xff; }
    y = a = a >>> 4;


    // Test Top-Right tile
    x = a = a | _topMasked;

    bit(mapTileProperties[x]);
    goto Return if negative;


    // Test bottom-Right tile
    x = a = y | _bottomMasked;

    bit(mapTileProperties[x]);
Return:
    return negative;
}



// Unbounded Tile Collisions
// -------------------------



// Add velocity to the entity's position and preform a collision test (screen boundary is not solid).
//
// This function will not stop the entity from walking to the edge of the screen.
//
// OUTPUT: entities.SoA.movementState bits will be set if there is a collision, otherwise cleared.
//
// KEEP: Y
// DB = 0x7e
#[mem8, idx8]
func move_entity_and_collision_test__unbounded(entityId : u8 in y) : u8 in y {
    // Clear movementState flags;
    entities.SoA.movementState[y] = a = 0;

    y = _move_entity_and_collision_test__unbounded__x_axis(y);
    y = _move_entity_and_collision_test__unbounded__y_axis(y);

    return y;
}



// Add X-Velocity to X-Position and preform a collision test in the X axis (screen boundary is not solid).
//
// NOTE: If you edit this function, you should also edit `_move_entity_and_collision_test__bounded__x_axis`.
//
// OUTPUT: entities.SoA.movementState bits will be set if there is a collision, otherwise cleared.
// KEEP: Y
#[mem8, idx8]
inline func _move_entity_and_collision_test__unbounded__x_axis(entityId : u8 in y) : u8 in y {
let _tmp    = zpTmp_byte_0;
let _top    = zpTmp_byte_1;
let _left   = zpTmp_byte_2;
let _right  = zpTmp_byte_3;

    // X Axis
    // ------

    a = entities.SoA.yPos_px[y] - entities.SoA.tileHitbox_halfHeight[y];
    if !carry { a = 0; }
    _top = a;

    entities.SoA.xPos_sx[y] = a = entities.SoA.xVelocity_sx[y] + entities.SoA.xPos_sx[y];
    a = entities.SoA.xVelocity_px[y];
    if negative {
        a +#= entities.SoA.xPos_px[y];
        if !carry { a = 0; }
        entities.SoA.xPos_px[y] = a;

        // Entity moving left

        a -= entities.SoA.tileHitbox_halfWidth[y];
        if !carry { a = 0; }
        _left = a;

        // calculate tile position
        _tmp = a = a >>> 4;
        x = a = (_top & 0xf0) | _tmp;

        a = mapTileProperties[x];
        if negative {
            // solid collision
            a = (~_left & 0xf);
            a++;
            a += entities.SoA.xPos_px[y];
            if carry { a = 0xff; }
            entities.SoA.xPos_px[y] = a;

            entities.SoA.movementState[y] = a = entities.SoA.movementState[y] | entities.MovementState.LEFT_COLLISION;
        }
        else {
            // Check if the hitbox touches the tile below this one
            a = (_top & 0xf) + entities.SoA.tileHitbox_halfHeight[y] + entities.SoA.tileHitbox_halfHeight[y];
            if a >= METATILE_SIZE + 1 {
                a = (&mapTileProperties[MAP_WIDTH])[x];
                if negative {
                    a = (~_left & 0xf);
                    a++;
                    a += entities.SoA.xPos_px[y];
                    if carry { a = 0xff; }
                    entities.SoA.xPos_px[y] = a;

                    entities.SoA.movementState[y] = a = entities.SoA.movementState[y] | entities.MovementState.LEFT_COLLISION;
                }
            }
        }
    }
    else {
        a +#= entities.SoA.xPos_px[y];
        if carry { a = 0xff; }
        entities.SoA.xPos_px[y] = a;

        // Entity moving right

        a += entities.SoA.tileHitbox_halfWidth[y];
        if carry { a = 0xff; }
        _right = a;

        // calculate tile position
        _tmp = a = a >>> 4;
        x = a = (_top & 0xf0) | _tmp;

        a = mapTileProperties[x];
        if negative {
            // solid collision
            a = (_right & 0xf0);
            a--;
            a -= entities.SoA.tileHitbox_halfWidth[y];
            if !carry { a = 1; }
            entities.SoA.xPos_px[y] = a;
            entities.SoA.movementState[y] = a = entities.SoA.movementState[y] | entities.MovementState.RIGHT_COLLISION;
        }
        else {
            // Check if the hitbox touches the tile below this one
            a = (_top & 0xf) + entities.SoA.tileHitbox_halfHeight[y] + entities.SoA.tileHitbox_halfHeight[y];
            if a >= METATILE_SIZE + 1 {
                a = (&mapTileProperties[MAP_WIDTH])[x];
                if negative {
                    // solid collision
                    a = (_right & 0xf0);
                    a--;
                    a -= entities.SoA.tileHitbox_halfWidth[y];
                    if !carry { a = 1; }
                    entities.SoA.xPos_px[y] = a;
                    entities.SoA.movementState[y] = a = entities.SoA.movementState[y] | entities.MovementState.RIGHT_COLLISION;
                }
            }
        }
    }

    return y;
}



// Add Y-Velocity to Y-Position and preform a collision test in the Y axis (screen boundary is not-solid).
//
// NOTE: If you edit this function, you should also edit `_move_entity_and_collision_test__bounded__y_axis`.
//
// OUTPUT: entities.SoA.movementState bits will be set if there is a collision, otherwise cleared.
// KEEP: Y
// DB = 0x7e
#[mem8, idx8]
inline func _move_entity_and_collision_test__unbounded__y_axis(entityId : u8 in y) : u8 in y {
let _tmp    = zpTmp_byte_0;
let _left   = zpTmp_byte_1;
let _top    = zpTmp_byte_2;
let _bottom = zpTmp_byte_3;

    a = entities.SoA.xPos_px[y] - entities.SoA.tileHitbox_halfWidth[y];
    if !carry { a = 0; }
    _left = a;

    entities.SoA.yPos_sx[y] = a = entities.SoA.yVelocity_sx[y] + entities.SoA.yPos_sx[y];
    a = entities.SoA.yVelocity_px[y];
    if negative {
        a +#= entities.SoA.yPos_px[y];
        if !carry { a = 0; }
        entities.SoA.yPos_px[y] = a;

        // Entity moving up

        a -= entities.SoA.tileHitbox_halfHeight[y];
        if !carry { a = 0; }
        _top = a;

        // calculate tile position
        _tmp = a = _left >>> 4;
        x = a = (_top & 0xf0) | _tmp;

        a = mapTileProperties[x];
        if negative {
            // solid collision
            a = (~_top & 0xf);
            a++;
            a += entities.SoA.yPos_px[y];
            if carry { a = 0xff; }
            entities.SoA.yPos_px[y] = a;

            entities.SoA.movementState[y] = a = entities.SoA.movementState[y] | entities.MovementState.UP_COLLISION;
        }
        else {
            // Check if the hitbox touches the tile to the right of this one
            a = (_left & 0xf) + entities.SoA.tileHitbox_halfWidth[y] + entities.SoA.tileHitbox_halfWidth[y];
            if a >= METATILE_SIZE + 1 {
                // Test X index to prevent an out-of-bounds read past the rightmost tile.
                a = x & 0xf;
                if a != 0x0f {
                    a = (&mapTileProperties[1])[x];
                    if negative {
                        a = (~_top & 0xf);
                        a++;
                        a += entities.SoA.yPos_px[y];
                        if carry { a = 0xff; }
                        entities.SoA.yPos_px[y] = a;

                        entities.SoA.movementState[y] = a = entities.SoA.movementState[y] | entities.MovementState.UP_COLLISION;
                    }
                }
            }
        }
    }
    else {
        a +#= entities.SoA.yPos_px[y];
        if carry { a = 0xff; }
        entities.SoA.yPos_px[y] = a;

        // Entity moving down

        a += entities.SoA.tileHitbox_halfHeight[y];
        if carry { a = 0xff; }
        _bottom = a;

        // calculate tile position
        _tmp = a = _left >>> 4;
        x = a = (_bottom & 0xf0) | _tmp;

        a = mapTileProperties[x];
        if negative {
            // solid collision
            a = (_bottom & 0xf0);
            a--;
            a -= entities.SoA.tileHitbox_halfHeight[y];
            if !carry { a = 1; }
            entities.SoA.yPos_px[y] = a;
            entities.SoA.movementState[y] = a = entities.SoA.movementState[y] | entities.MovementState.DOWN_COLLISION;
        }
        else {
            // Check if the hitbox touches the tile to the right of this one
            a = (_left & 0xf) + entities.SoA.tileHitbox_halfWidth[y] + entities.SoA.tileHitbox_halfWidth[y];
            if a >= METATILE_SIZE + 1 {
                // Test X index to prevent an out-of-bounds read past the rightmost tile.
                a = x & 0xf;
                if a != 0x0f {
                    a = (&mapTileProperties[1])[x];
                    if negative {
                        a = (_bottom & 0xf0);
                        a--;
                        a -= entities.SoA.tileHitbox_halfHeight[y];
                        if !carry { a = 1; }
                        entities.SoA.yPos_px[y] = a;
                        entities.SoA.movementState[y] = a = entities.SoA.movementState[y] | entities.MovementState.DOWN_COLLISION;
                    }
                }
            }
        }
    }

    return y;
}



// Bounded Tile Collisions
// -----------------------



// Add velocity to the entity's position and preform a collision test (screen boundary is solid).
//
// OUTPUT: entities.SoA.movementState bits will be set if there is a collision, otherwise cleared.
//
// KEEP: Y
// DB = 0x7e
#[mem8, idx8]
func move_entity_and_collision_test__bounded(entityId : u8 in y) : u8 in y {
    // Clear movementState flags;
    entities.SoA.movementState[y] = a = 0;

    y = _move_entity_and_collision_test__bounded__x_axis(y);
    y = _move_entity_and_collision_test__bounded__y_axis(y);

    return y;
}



// Add X-Velocity to X-Position and preform a collision test in the X axis (screen boundary is solid).
//
// NOTE: If you edit this function, you should also edit `_move_entity_and_collision_test__unbounded__x_axis`.
//
// OUTPUT: entities.SoA.movementState bits will be set if there is a collision, otherwise cleared.
// KEEP: Y
#[mem8, idx8]
inline func _move_entity_and_collision_test__bounded__x_axis(entityId : u8 in y) : u8 in y {
let _tmp    = zpTmp_byte_0;
let _top    = zpTmp_byte_1;
let _left   = zpTmp_byte_2;
let _right  = zpTmp_byte_3;

    // X Axis
    // ------

    a = entities.SoA.yPos_px[y] - entities.SoA.tileHitbox_halfHeight[y];
    if !carry { a = 0; }
    _top = a;

    entities.SoA.xPos_sx[y] = a = entities.SoA.xVelocity_sx[y] + entities.SoA.xPos_sx[y];
    a = entities.SoA.xVelocity_px[y];
    ^if negative {
        a +#= entities.SoA.xPos_px[y];
        if !carry { a = 0; }
        entities.SoA.xPos_px[y] = a;

        // Entity moving left

        a -= entities.SoA.tileHitbox_halfWidth[y];
        if !carry {
            // Collided with left edge of the screen
            entities.SoA.xPos_px[y] = a = entities.SoA.tileHitbox_halfWidth[y];
            entities.SoA.movementState[y] = a = entities.SoA.movementState[y] | entities.MovementState.LEFT_COLLISION;
            ^return y;
        }
        _left = a;

        // calculate tile position
        _tmp = a = a >>> 4;
        x = a = (_top & 0xf0) | _tmp;

        a = mapTileProperties[x];
        if negative {
            // solid collision
            a = (~_left & 0xf);
            a++;
            a += entities.SoA.xPos_px[y];
            if carry { a = 0xff; }
            entities.SoA.xPos_px[y] = a;

            entities.SoA.movementState[y] = a = entities.SoA.movementState[y] | entities.MovementState.LEFT_COLLISION;
        }
        else {
            // Check if the hitbox touches the tile below this one
            a = (_top & 0xf) + entities.SoA.tileHitbox_halfHeight[y] + entities.SoA.tileHitbox_halfHeight[y];
            if a >= METATILE_SIZE + 1 {
                a = (&mapTileProperties[MAP_WIDTH])[x];
                if negative {
                    a = (~_left & 0xf);
                    a++;
                    a += entities.SoA.xPos_px[y];
                    if carry { a = 0xff; }
                    entities.SoA.xPos_px[y] = a;

                    entities.SoA.movementState[y] = a = entities.SoA.movementState[y] | entities.MovementState.LEFT_COLLISION;
                }
            }
        }
    }
    else {
        a +#= entities.SoA.xPos_px[y];
        if carry { a = 0xff; }
        entities.SoA.xPos_px[y] = a;

        // Entity moving right

        a += entities.SoA.tileHitbox_halfWidth[y];
        if carry {
            // Collided with right edge of the screen
            entities.SoA.xPos_px[y] = a = (MAP_WIDTH_PIXELS - 1) - entities.SoA.tileHitbox_halfWidth[y];
            entities.SoA.movementState[y] = a = entities.SoA.movementState[y] | entities.MovementState.RIGHT_COLLISION;
            return y;
        }
        _right = a;

        // calculate tile position
        _tmp = a = a >>> 4;
        x = a = (_top & 0xf0) | _tmp;

        a = mapTileProperties[x];
        if negative {
            // solid collision
            a = (_right & 0xf0);
            a--;
            a -= entities.SoA.tileHitbox_halfWidth[y];
            if !carry { a = 1; }
            entities.SoA.xPos_px[y] = a;
            entities.SoA.movementState[y] = a = entities.SoA.movementState[y] | entities.MovementState.RIGHT_COLLISION;
        }
        else {
            // Check if the hitbox touches the tile below this one
            a = (_top & 0xf) + entities.SoA.tileHitbox_halfHeight[y] + entities.SoA.tileHitbox_halfHeight[y];
            if a >= METATILE_SIZE + 1 {
                a = (&mapTileProperties[MAP_WIDTH])[x];
                if negative {
                    // solid collision
                    a = (_right & 0xf0);
                    a--;
                    a -= entities.SoA.tileHitbox_halfWidth[y];
                    if !carry { a = 1; }
                    entities.SoA.xPos_px[y] = a;
                    entities.SoA.movementState[y] = a = entities.SoA.movementState[y] | entities.MovementState.RIGHT_COLLISION;
                }
            }
        }
    }

    return y;
}



// Add Y-Velocity to Y-Position and preform a collision test in the Y axis (screen boundary is solid).
//
// NOTE: If you edit this function, you should also edit `_move_entity_and_collision_test__unbounded__y_axis`.
//
// OUTPUT: entities.SoA.movementState bits will be set if there is a collision, otherwise cleared.
// KEEP: Y
// DB = 0x7e
#[mem8, idx8]
inline func _move_entity_and_collision_test__bounded__y_axis(entityId : u8 in y) : u8 in y {
let _tmp    = zpTmp_byte_0;
let _left   = zpTmp_byte_1;
let _top    = zpTmp_byte_2;
let _bottom = zpTmp_byte_3;

    a = entities.SoA.xPos_px[y] - entities.SoA.tileHitbox_halfWidth[y];
    if !carry { a = 0; }
    _left = a;

    entities.SoA.yPos_sx[y] = a = entities.SoA.yVelocity_sx[y] + entities.SoA.yPos_sx[y];
    a = entities.SoA.yVelocity_px[y];
    ^if negative {
        a +#= entities.SoA.yPos_px[y];
        if !carry { a = 0; }
        entities.SoA.yPos_px[y] = a;

        // Entity moving up

        a -= entities.SoA.tileHitbox_halfHeight[y];
        if !carry {
            // Collided with top edge of screen
            entities.SoA.yPos_px[y] = a = entities.SoA.tileHitbox_halfHeight[y];
            entities.SoA.movementState[y] = a = entities.SoA.movementState[y] | entities.MovementState.UP_COLLISION;
            ^return y;
        }
        _top = a;

        // calculate tile position
        _tmp = a = _left >>> 4;
        x = a = (_top & 0xf0) | _tmp;

        a = mapTileProperties[x];
        if negative {
            // solid collision
            a = (~_top & 0xf);
            a++;
            a += entities.SoA.yPos_px[y];
            if carry { a = 0xff; }
            entities.SoA.yPos_px[y] = a;

            entities.SoA.movementState[y] = a = entities.SoA.movementState[y] | entities.MovementState.UP_COLLISION;
        }
        else {
            // Check if the hitbox touches the tile to the right of this one
            a = (_left & 0xf) + entities.SoA.tileHitbox_halfWidth[y] + entities.SoA.tileHitbox_halfWidth[y];
            if a >= METATILE_SIZE + 1 {
                // Test X index to prevent an out-of-bounds read past the rightmost tile.
                a = x & 0xf;
                if a != 0x0f {
                    a = (&mapTileProperties[1])[x];
                    if negative {
                        a = (~_top & 0xf);
                        a++;
                        a += entities.SoA.yPos_px[y];
                        if carry { a = 0xff; }
                        entities.SoA.yPos_px[y] = a;

                        entities.SoA.movementState[y] = a = entities.SoA.movementState[y] | entities.MovementState.UP_COLLISION;
                    }
                }
            }
        }
    }
    else {
        a +#= entities.SoA.yPos_px[y];
        if carry { a = 0xff; }
        entities.SoA.yPos_px[y] = a;

        // Entity moving down

        a += entities.SoA.tileHitbox_halfHeight[y];
        if carry || a >= MAP_HEIGHT_PIXELS {
            // Collided with bottom edge of the screen
            entities.SoA.yPos_px[y] = a = (MAP_HEIGHT_PIXELS - 1) - entities.SoA.tileHitbox_halfHeight[y];
            entities.SoA.movementState[y] = a = entities.SoA.movementState[y] | entities.MovementState.DOWN_COLLISION;
            ^return y;
        }
        _bottom = a;

        // calculate tile position
        _tmp = a = _left >>> 4;
        x = a = (_bottom & 0xf0) | _tmp;

        a = mapTileProperties[x];
        if negative {
            // solid collision
            a = (_bottom & 0xf0);
            a--;
            a -= entities.SoA.tileHitbox_halfHeight[y];
            if !carry { a = 1; }
            entities.SoA.yPos_px[y] = a;
            entities.SoA.movementState[y] = a = entities.SoA.movementState[y] | entities.MovementState.DOWN_COLLISION;
        }
        else {
            // Check if the hitbox touches the tile to the right of this one
            a = (_left & 0xf) + entities.SoA.tileHitbox_halfWidth[y] + entities.SoA.tileHitbox_halfWidth[y];
            if a >= METATILE_SIZE + 1 {
                // Test X index to prevent an out-of-bounds read past the rightmost tile.
                a = x & 0xf;
                if a != 0x0f {
                    a = (&mapTileProperties[1])[x];
                    if negative {
                        a = (_bottom & 0xf0);
                        a--;
                        a -= entities.SoA.tileHitbox_halfHeight[y];
                        if !carry { a = 1; }
                        entities.SoA.yPos_px[y] = a;
                        entities.SoA.movementState[y] = a = entities.SoA.movementState[y] | entities.MovementState.DOWN_COLLISION;
                    }
                }
            }
        }
    }

    return y;
}

}


// Transitions
// ===========

namespace transitions {

let TRANSITION_SPEED = 8;


in wram7e {
    // Map position within the current transition
    // (byte index)
    var mapPos : u8;


    // The VRAM word address of the tilemap the map is drawn to.
    //
    // This variable contains one of two possible values:
    //  * VRAM_BG1_MAP_WADDR
    //  * VRAM_BG1_MAP_WADDR + 0x400
    //
    // This variable MUST only be changed by `_reset_state()` and `swap_currentTilemap()`.
    //
    // (VRAM word address)
    var currentTilemap_vramWaddr : u16;


    // The offset between the top of the tilemap and the top of the room map in tiles.
    //
    // This value should be masked by `topmostRowOffset_MASK` whenever it is used to
    // calculate a VRAM address or buffer index.
    //
    // (byte)
    var topmostRowOffset : u8;
    let topmostRowOffset_MASK = 0x1f;


    // The offset between the top of the tilemap and the top row of the room map.
    //
    // NOTE: This variable only holds a vertical offset,  it does NOT contain
    //       the horizontal offset (`currentTilemap_vramWaddr`).
    //
    // (word - VRAM word offset)
    var vramVerticalWoffset : u16;


    // A buffer containing a single row/column to transfer to VRAM.
    var buffer : [u8 ; 32 * 2];
}


in shadow {
    // `VMAIN` register to use when transferring the buffer to VRAM.
    //
    // NOTE: If this value is 0 then no buffer will be transferred.
    //
    // (byte)
    var buffer_vram_control : u8;


    // VRAM word position to store the buffer to.
    //
    // NOTE: This variable is handled differently in horizontal and vertical transitions.
    //
    // (word)
    var buffer_vramWordPos : u16;

    // ::ANNOY why do I have to do this?::
    // ::: Used to work around a "could not generate code for assignment `=` (got: `a = *(8269313 as *u8)` (mem8, idx8))" error::
    let buffer_vramWordPos_l = *(&<:buffer_vramWordPos as *u8);
    let buffer_vramWordPos_h = *(&>:buffer_vramWordPos as *u8);
}


in code {



// Transfer the buffer to VRAM if required.
//
// REQUIRES: V-Blank
//
// Uses DMA channel 0
//
// DB = 0x80
#[mem8, idx16]
func transfer_buffer__vblank() {
    a = buffer_vram_control;
    if !zero {
        snes.ppu.vram_control = a;

        snes.ppu.vram_address_hl = xx = buffer_vramWordPos;

        snes.dma0.control = a = snes.dma.CONTROL_MODE_AB;
        snes.dma0.mdma_dest = a = <:&snes.ppu.vram_write_data_l;

        snes.dma0.src_address_hl = xx = &buffer as u16;
        snes.dma0.src_address_bank = a = #:far &buffer;

        snes.dma0.mdma_size_hl = xx = sizeof(typeof(buffer));

        snes.dma.mdma_enable = a = snes.dma.ENABLE_0;


        // Do not transfer buffer on the next frame
        buffer_vram_control = 0;
    }
}



// Reset internal state and scroll positions.
//
// DB = 0x7e
#[mem8, idx8]
inline func _reset_state() {
    transitions.topmostRowOffset = 0;

    mem16();
    #[mem16] {
        vramVerticalWoffset = 0;
        currentTilemap_vramWaddr = VRAM_BG1_MAP_WADDR;

        // Reset BG1 scroll
        bg1_scrollX = 0;
        bg1_scrollY = aa = 0xffff;
    }
    mem8();
}



// Horizontal Transitions
// ----------------------


// Swap the currentTilemap.
//
// DB = 0x7e
#[mem8, idx8]
func swap_currentTilemap() {
    a = *(&>:currentTilemap_vramWaddr as *u8);
    if a == >:VRAM_BG1_MAP_WADDR {
        a = >:(VRAM_BG1_MAP_WADDR + 0x400);
    }
    else {
        a = >:VRAM_BG1_MAP_WADDR;
    }

    *(&>:currentTilemap_vramWaddr as *u8) = a;
}



// Fill the buffer with the right half of a MetaTile column and queue a transfer during VBlank.
//
// REQUIRES: buffer_vramWordPos set.
//
// DB = 0x7e
#[mem8, idx8]
func _draw_left_column() {
let _tmp = zpTmp_byte_0;

    y = a = (topmostRowOffset & topmostRowOffset_MASK) << 1;

    a = mapPos;

    do {
        _tmp = a;

        x = a = map[x = a];

        buffer[y++] = a = tileset.topLeft_low[x];
        buffer[y++] = a = tileset.topLeft_high[x];
        buffer[y++] = a = tileset.bottomLeft_low[x];
        buffer[y++] = a = tileset.bottomLeft_high[x];

        if y == sizeof(typeof(buffer)) {
            y = 0;
        }

        a = _tmp + 0x10;
    }
    while a < MAP_HEIGHT * MAP_WIDTH;


    buffer_vram_control = a = snes.ppu.VRAM_CONTROL_INCREMENT_32 | snes.ppu.VRAM_CONTROL_REMAP_MODE_0 | snes.ppu.VRAM_CONTROL_SIZE_2;
}



// Fill the buffer with the right half of a MetaTile column and queue a transfer during VBlank.
//
// REQUIRES: buffer_vramWordPos set.
//
// DB = 0x7e
#[mem8, idx8]
func _draw_right_column() {
let _tmp = zpTmp_byte_0;

    y = a = (topmostRowOffset & topmostRowOffset_MASK) << 1;

    a = mapPos;

    do {
        _tmp = a;

        x = a = map[x = a];

        buffer[y++] = a = tileset.topRight_low[x];
        buffer[y++] = a = tileset.topRight_high[x];
        buffer[y++] = a = tileset.bottomRight_low[x];
        buffer[y++] = a = tileset.bottomRight_high[x];

        if y == sizeof(typeof(buffer)) {
            y = 0;
        }

        a = _tmp + 0x10;
    }
    while a < MAP_HEIGHT * MAP_WIDTH;


    buffer_vram_control = a = snes.ppu.VRAM_CONTROL_INCREMENT_32 | snes.ppu.VRAM_CONTROL_REMAP_MODE_0 | snes.ppu.VRAM_CONTROL_SIZE_2;
}



// Initialize a scroll right transition.
//
// DB = 0x7e
#[mem8, idx8]
func scroll_right__setup() {

    swap_currentTilemap();

    mapPos = 0;


    // Determine the next VRAM position
    let VRAM_OFFSET = 0;

    // Subtract one to counter the +1 at the start of `right__process()`
    *(&<:buffer_vramWordPos as *u8) = a = <:(VRAM_BG1_MAP_WADDR + VRAM_OFFSET - 1);

    *(&>:buffer_vramWordPos as *u8) = a = *(&>:currentTilemap_vramWaddr as *u8);
}



// Process a scroll right transition.
//
// This function is to be called once per frame until the transition has completed.
//
// Returns true if transition is complete.
//
// DB = 0x7e
#[mem8, idx8]
func scroll_right__process() : bool in carry {

    *(&<:bg1_scrollX as *u8) = a = *(&<:bg1_scrollX as *u8) + TRANSITION_SPEED;
    if carry {
        (*(&>:bg1_scrollX as *u8))++;
    }


    a = buffer_vramWordPos_l;
    a++;
    buffer_vramWordPos_l = a;

    if a & 1 == 0 {
        _draw_left_column();
    }
    else {
        _draw_right_column();

        mapPos++;
    }


    a = mapPos;
    if a == MAP_WIDTH {
        return true;
    }

    return false;
}



// Rollback a scroll right transition.
//
// This function is to be called once per frame until it returns true.
//
// Returns true if transition is complete.
//
// DB = 0x7e
#[mem8, idx8]
func scroll_right__rollback() : bool in carry {

    // no need to draw tiles, only need to change scroll.

    *(&<:bg1_scrollX as *u8) = a = *(&<:bg1_scrollX as *u8) - TRANSITION_SPEED;
    if !carry {
        (*(&>:bg1_scrollX as *u8))--;
    }

    if a == 0 {
        swap_currentTilemap();
        return true;
    }
    return false;
}



// Initialize a scroll left transition.
//
// DB = 0x7e
#[mem8, idx8]
func scroll_left__setup() {

    swap_currentTilemap();

    mapPos = a = 0xf;

    // Determine the next VRAM position
    let VRAM_OFFSET = 31;

    // Add one to counter the -1 at the start of `left__process()`
    *(&<:buffer_vramWordPos as *u8) = a = <:(VRAM_BG1_MAP_WADDR + VRAM_OFFSET + 1);

    *(&>:buffer_vramWordPos as *u8) = a = *(&>:currentTilemap_vramWaddr as *u8);
}



// Process a scroll left transition.
//
// This function is to be called once per frame until the transition has completed.
//
// Returns true if transition is complete.
//
// DB = 0x7e
#[mem8, idx8]
func scroll_left__process() : bool in carry {

    *(&<:bg1_scrollX as *u8) = a = *(&<:bg1_scrollX as *u8) - TRANSITION_SPEED;
    if !carry {
        (*(&>:bg1_scrollX as *u8))--;
    }


    a = buffer_vramWordPos_l;
    a--;
    buffer_vramWordPos_l = a;

    if a & 1 != 0 {
        _draw_right_column();
    }
    else {
        _draw_left_column();

        mapPos--;
    }


    a = mapPos;
    if negative {
        return true;
    }

    return false;
}



// Rollback a scroll left transition.
//
// This function is to be called once per frame until it returns true.
//
// Returns true if transition is complete.
//
// DB = 0x7e
#[mem8, idx8]
func scroll_left__rollback() : bool in carry {

    // no need to draw tiles, only need to change scroll.

    *(&<:bg1_scrollX as *u8) = a = *(&<:bg1_scrollX as *u8) + TRANSITION_SPEED;
    if carry {
        (*(&>:bg1_scrollX as *u8))++;
    }

    if a == 0 {
        swap_currentTilemap();
        return true;
    }
    return false;
}



// Vertical Transitions
// --------------------



// Calculate the `buffer_vramWordPos` value to use for a vertical scroll transition.
//
// DB = 0x7e
#[mem8, idx8]
func _calculate_vram_position_for_row(tilemapRow : u8 in a) {
    mem16();
    #[mem16] {
        aa = (aa & topmostRowOffset_MASK) << 5;
        aa += currentTilemap_vramWaddr;

        buffer_vramWordPos = aa;
    }
    mem8();
}



// Fill the buffer with the top half of a MetaTile row and queue a transfer during VBlank.
//
// DB = 0x7e
#[mem8, idx8]
func _draw_top_row(tilemapRow : u8 in a) {
let _tmp = zpTmp_byte_0;

    _calculate_vram_position_for_row(a);


    y = 0;
    a = mapPos;

    do {
        _tmp = a;

        x = a = map[x = a];

        buffer[y++] = a = tileset.topLeft_low[x];
        buffer[y++] = a = tileset.topLeft_high[x];
        buffer[y++] = a = tileset.topRight_low[x];
        buffer[y++] = a = tileset.topRight_high[x];

        a = _tmp;
        a++;
    }
    while y < sizeof(typeof(buffer));


    buffer_vram_control = a = snes.ppu.VRAM_CONTROL_INCREMENT_1 | snes.ppu.VRAM_CONTROL_REMAP_MODE_0 | snes.ppu.VRAM_CONTROL_SIZE_2;
}



// Fill the buffer with the bottom half of a MetaTile row and queue a transfer during VBlank.
//
// DB = 0x7e
#[mem8, idx8]
func _draw_bottom_row(tilemapRow : u8 in a) {
let _tmp = zpTmp_byte_0;

    _calculate_vram_position_for_row(a);


    y = 0;
    a = mapPos;

    do {
        _tmp = a;

        x = a = map[x = a];

        buffer[y++] = a = tileset.bottomLeft_low[x];
        buffer[y++] = a = tileset.bottomLeft_high[x];
        buffer[y++] = a = tileset.bottomRight_low[x];
        buffer[y++] = a = tileset.bottomRight_high[x];

        a = _tmp;
        a++;
    }
    while y < sizeof(typeof(buffer));


    buffer_vram_control = a = snes.ppu.VRAM_CONTROL_INCREMENT_1 | snes.ppu.VRAM_CONTROL_REMAP_MODE_0 | snes.ppu.VRAM_CONTROL_SIZE_2;
}



// Initialize a scroll down transition.
//
// DB = 0x7e
#[mem8, idx8]
func scroll_down__setup() {

    mapPos = 0;
}



// Process a scroll down transition.
//
// This function is to be called once per frame until the transition has completed.
//
// Returns true if transition is complete.
//
// DB = 0x7e
#[mem8, idx8]
func scroll_down__process() : bool in carry {

    *(&<:bg1_scrollY as *u8) = a = *(&<:bg1_scrollY as *u8) + TRANSITION_SPEED;


    a = topmostRowOffset;
    a++;
    topmostRowOffset = a;

    if a & 1 != 0 {
        _draw_top_row(a + MAP_HEIGHT * 2 - 1);
    }
    else {
        _draw_bottom_row(a + MAP_HEIGHT * 2 - 1);

        mapPos = a = mapPos + MAP_WIDTH;

        if a >= MAP_WIDTH * MAP_HEIGHT {
            return _update_vram_vertical_woffset__and_return_true();
        }
    }

    return false;
}




// Initialize a scroll up transition.
//
// DB = 0x7e
#[mem8, idx8]
func scroll_up__setup() {

    mapPos = a = MAP_WIDTH * (MAP_HEIGHT - 1);
}



// Process a scroll up transition.
//
// This function is to be called once per frame until the transition has completed.
//
// Returns true if transition is complete.
//
// DB = 0x7e
#[mem8, idx8]
func scroll_up__process() : bool in carry {

    *(&<:bg1_scrollY as *u8) = a = *(&<:bg1_scrollY as *u8) - TRANSITION_SPEED;


    a = topmostRowOffset;
    a--;
    topmostRowOffset = a;

    if a & 1 != 0 {
        _draw_bottom_row(a);
    }
    else {
        _draw_top_row(a);

        mapPos = a = mapPos - 0x10;

        if a >= MAP_WIDTH * MAP_HEIGHT{
            return _update_vram_vertical_woffset__and_return_true();
        }
    }

    return false;
}



// Calculates the new value of the `vramVerticalWoffset`.
//
// NOTE: Always returns true
#[mem8, idx8]
func _update_vram_vertical_woffset__and_return_true() : bool in carry {
    a = topmostRowOffset;

    mem16();
    #[mem16] {
        vramVerticalWoffset = aa = (aa & topmostRowOffset_MASK) << 5;
    }
    mem8();

    return true;
}


}

}
}


