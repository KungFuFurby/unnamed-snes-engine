// Copyright (c) 2021, Marcus Rowe <undisbeliever@gmail.com>.
// Distributed under The MIT License, see the LICENSE file for more details.

import "memmap";

import "room";
import "resources";
import "gameloop";
import "wait-frame";
import "../wiz/common/snes/snes";

import "entities/_variables";


namespace metatiles {

let METATILE_SIZE = 16;

let MAP_WIDTH = ROOM_MAP_WIDTH;
let MAP_HEIGHT = ROOM_MAP_HEIGHT;

let MAP_WIDTH_PIXELS = MAP_WIDTH * METATILE_SIZE;
let MAP_HEIGHT_PIXELS = MAP_HEIGHT * METATILE_SIZE;


let TILE_PROPERTY_SOLID_BIT = 7;


// Tileset data stored in RAM
struct _Tileset {
    // Mapping of each of the 4 tiles within each MetaTile.
    topLeft_low :      [u8 ; 256],
    topLeft_high :     [u8 ; 256],
    topRight_low :     [u8 ; 256],
    topRight_high :    [u8 ; 256],
    bottomLeft_low :   [u8 ; 256],
    bottomLeft_high :  [u8 ; 256],
    bottomRight_low :  [u8 ; 256],
    bottomRight_high : [u8 ; 256],

    // Tile properties for each MetaTile
    // (`TILE_PROPERTY_*_BIT` bitfield for each tile)
    properties:        [u8 ; 256],
};


// Tileset data format in ROM.
struct _DataFormat {
    tile_data_size : u16,

    ram_data : _Tileset,

    palette_data : [u16 ; 128],

    tile_data : u8,
};


in zeropage {

}


in wram7e {
    // The map for the current room.
    //
    // NOTE: Whenever the map is updated the corresponding `mapTileProperties` cells must be changed.
    let map = room.map;


    // The MetaTile tileset tile properties for each map tile.
    //
    // (bitfield of `TILE_PROPERTY_*_BIT`s for each map tile.)
    //
    // Whenever the map is updated the corresponding `mapTileProperties` cells must be changed.
    #[align(256)]
    var mapTileProperties : [u8 ; 256];


    // this hack allows me to write `tileset.topLeft[y]` without a compile error.
    #[align(256)]
    var __far_tileset : _Tileset;
    let tileset = *(&__far_tileset as *_Tileset);
}


in code {


// Load a tileset into memory and the PPU
//
// REQUIRES: Force-Blank
// Uses DMA channel 0
//
// NOTE: tileset address cannot be in RAM.
//
// DB = 0x80
#[mem8, idx16]
func load_tileset__forceblank(tileset_id : u8 in a) {
let _tilesetPtr = zpTmp_farPtr;

    snes.dma.hdma_enable = 0;

    idx8();
    #[idx8] {
        x = a;
        if x >= resources.metatile_tilesets.N_TILESETS {
            x = 0;
        }

        <:_tilesetPtr = a = resources.metatile_tilesets.tileset_list_l[x];
        >:_tilesetPtr = a = resources.metatile_tilesets.tileset_list_h[x];
        #:_tilesetPtr = a = resources.metatile_tilesets.tileset_list_b[x];
    }
    idx16();


    // A = _tilesetPtr bank
    xx = *(&_tilesetPtr as *u16);

    // Skip _DataFormat.tile_data_size in DMA's below
    xx++;
    xx++;

    snes.dma0.src_address_bank = a;
    snes.dma0.src_address_hl = xx;


    // Copy first data block (tileset) into RAM
    snes.wram.address_hl = xx = &tileset as u16;
    snes.wram.address_bank = a = (#:far &__far_tileset) & 1;

    snes.dma0.control = a = snes.dma.CONTROL_MODE_A;
    snes.dma0.mdma_dest = a = <:&snes.wram.data;
    snes.dma0.mdma_size_hl = xx = sizeof(_Tileset);

    snes.dma.mdma_enable = a = snes.dma.ENABLE_0;


    // Load palette to CGRAM
    snes.ppu.cgram_address = 0;

    snes.dma0.mdma_dest = a = <:&snes.ppu.cgram_write_data;
    snes.dma0.mdma_size_hl = yy = 128 * 2;

    snes.dma.mdma_enable = a = snes.dma.ENABLE_0;


    // Load tiles into VRAM
    snes.ppu.vram_control = a = snes.ppu.VRAM_CONTROL_INCREMENT_1 | snes.ppu.VRAM_CONTROL_REMAP_MODE_0 | snes.ppu.VRAM_CONTROL_SIZE_2;
    snes.ppu.vram_address_hl = xx = VRAM_BG1_TILES_WADDR;

    snes.dma0.control = a = snes.dma.CONTROL_MODE_AB;
    snes.dma0.mdma_dest = a = <:&snes.ppu.vram_write_data_l;

    mem16();
    #[mem16] {
        snes.dma0.mdma_size_hl = aa = **(&_tilesetPtr as *far *u16);
    }
    mem8();

    snes.dma.mdma_enable = a = snes.dma.ENABLE_0;
}



// Draws the entire map to BG1.
//
// REQUIRES: Force-Blank, Tileset loaded into memory.
//
// DB = 0x7e
#[mem8, idx8]
func draw_map__forceblank() {
let _rowsLeft    = zpTmp_byte_0;
let _columnsLeft = zpTmp_byte_1;

    push8(data_bank);

    push8(program_bank);
    data_bank = pop8();
// DB = 0x80

    snes.ppu.brightness = a = snes.ppu.BRIGHTNESS_FORCE_BLANK | snes.ppu.BRIGHTNESS_MASK;

    snes.ppu.vram_control = a = snes.ppu.VRAM_CONTROL_INCREMENT_1 | snes.ppu.VRAM_CONTROL_REMAP_MODE_0 | snes.ppu.VRAM_CONTROL_SIZE_2;
    snes.ppu.vram_address_l = <:VRAM_BG1_MAP_WADDR;
    snes.ppu.vram_address_h = >:VRAM_BG1_MAP_WADDR;



    push8(a = 0x7e);
    data_bank = pop8();
// DB = 0x7e


    // ::TODO setup variables::


    // X = map position
    x = 0;

    _rowsLeft = a = MAP_HEIGHT;
    do {
        push8(x);

        _columnsLeft = a = MAP_WIDTH;
        do {
            y = map[x];

            *(far &snes.ppu.vram_write_data_l) = a = tileset.topLeft_low[y];
            *(far &snes.ppu.vram_write_data_h) = a = tileset.topLeft_high[y];
            *(far &snes.ppu.vram_write_data_l) = a = tileset.topRight_low[y];
            *(far &snes.ppu.vram_write_data_h) = a = tileset.topRight_high[y];

            x++;
            _columnsLeft--;
        } while !zero;

        x = pop8();

        _columnsLeft = a = MAP_WIDTH;
        do {
            y = map[x];

            *(far &snes.ppu.vram_write_data_l) = a = tileset.bottomLeft_low[y];
            *(far &snes.ppu.vram_write_data_h) = a = tileset.bottomLeft_high[y];
            *(far &snes.ppu.vram_write_data_l) = a = tileset.bottomRight_low[y];
            *(far &snes.ppu.vram_write_data_h) = a = tileset.bottomRight_high[y];

            x++;
            _columnsLeft--;
        } while !zero;


        _rowsLeft--;
    } while !zero;


    data_bank = pop8();
// DB = 0x7e


    transitions._reset_state();
}



// Populate the `mapTileProperties` array.
//
// This function MUST be called when the map or MetaTile tileset is loaded.
//
// ASSUMES: The room is valid
//
// DB = 0x7e
#[mem8, idx8]
func populate_map_tile_properties() {
    x = 0;
    do {
        y = map[x];
        mapTileProperties[x] = a = tileset.properties[y];

        x++;
    } while !zero;
}



// Populate the `mapTileProperties` array with solid tiles.
//
// This function MUST be called when the map or MetaTile tileset is loaded.
//
// ASSUMES: The room map is invalid
//
// DB = 0x7e
#[mem8, idx8]
func populate_map_tile_properties__all_tiles_solid() {
    // Fill the `mapTileProperties` array with solid tiles.

    a = 1 << TILE_PROPERTY_SOLID_BIT;

    x = 0;
    do {
        mapTileProperties[x] = a;

        x++;
    } while !zero;
}



// Collisions
// ==========



// Check if a tile at a given position is solid
//
// DB = 0x7e
#[mem8, idx8]
func check_tile_solid(xPos : u8 in x, yPos : u8 in y) : bool in negative {
let _tmp    = zpTmp_byte_0;

    _tmp = a = x >>> 4;
    x = a = (y & 0xf0) + _tmp;

    bit(mapTileProperties[x]);
    return negative;
}



// Tests if the player is touching a solid tile.
//
// NOTE: This only checks the four corners of the player's tile hitbox.
//
// ASSUMES: The player's tile hitbox's half-width and half-height is <= 8.
//
// DB = 0x7e
#[mem8, idx8]
func test_if_player_touches_a_solid_tile() : bool in negative {

let _tmp          = zpTmp_byte_0;
let _topMasked    = zpTmp_byte_1;
let _bottomMasked = zpTmp_byte_2;


    // Left tiles
    a = entities.SoA.xPos_px[PLAYER_ENTITY_ID] - entities.SoA.tileHitbox_halfWidth[PLAYER_ENTITY_ID];
    if !carry { a = 0; }
    _tmp = a = a >>> 4;


    // Test Top-left tile
    a = entities.SoA.yPos_px[PLAYER_ENTITY_ID] - entities.SoA.tileHitbox_halfHeight[PLAYER_ENTITY_ID];
    if !carry { a = 0; }
    _topMasked = a = a & 0xf0;
    x = a = a | _tmp;

    bit(mapTileProperties[x]);
    goto Return if negative;


    // Test bottom-left tile
    a = entities.SoA.yPos_px[PLAYER_ENTITY_ID] + entities.SoA.tileHitbox_halfHeight[PLAYER_ENTITY_ID];
    if carry { a = 0xff; }
    _bottomMasked = a = a & 0xf0;
    x = a = a | _tmp;

    bit(mapTileProperties[x]);
    goto Return if negative;


    // Right tiles
    a = entities.SoA.xPos_px[PLAYER_ENTITY_ID] + entities.SoA.tileHitbox_halfWidth[PLAYER_ENTITY_ID];
    if carry { a = 0xff; }
    y = a = a >>> 4;


    // Test Top-Right tile
    x = a = a | _topMasked;

    bit(mapTileProperties[x]);
    goto Return if negative;


    // Test bottom-Right tile
    x = a = y | _bottomMasked;

    bit(mapTileProperties[x]);
Return:
    return negative;
}



// Unbounded Tile Collisions
// -------------------------



// Add velocity to the entity's position and preform a collision test (screen boundary is not solid).
//
// This function will not stop the entity from walking to the edge of the screen.
//
// OUTPUT: entities.SoA.movementState bits will be set if there is a collision, otherwise cleared.
//
// KEEP: Y
// DB = 0x7e
#[mem8, idx8]
func move_entity_and_collision_test__unbounded(entityId : u8 in y) : u8 in y {
    // Clear movementState flags;
    entities.SoA.movementState[y] = a = 0;

    y = _move_entity_and_collision_test__unbounded__x_axis(y);
    y = _move_entity_and_collision_test__unbounded__y_axis(y);

    return y;
}



// Add X-Velocity to X-Position and preform a collision test in the X axis (screen boundary is not solid).
//
// NOTE: If you edit this function, you should also edit `_move_entity_and_collision_test__bounded__x_axis`.
//
// OUTPUT: entities.SoA.movementState bits will be set if there is a collision, otherwise cleared.
// KEEP: Y
#[mem8, idx8]
inline func _move_entity_and_collision_test__unbounded__x_axis(entityId : u8 in y) : u8 in y {
let _tmp    = zpTmp_byte_0;
let _top    = zpTmp_byte_1;
let _left   = zpTmp_byte_2;
let _right  = zpTmp_byte_3;

    // X Axis
    // ------

    a = entities.SoA.yPos_px[y] - entities.SoA.tileHitbox_halfHeight[y];
    if !carry { a = 0; }
    _top = a;

    entities.SoA.xPos_sx[y] = a = entities.SoA.xVelocity_sx[y] + entities.SoA.xPos_sx[y];
    a = entities.SoA.xVelocity_px[y];
    if negative {
        a +#= entities.SoA.xPos_px[y];
        if !carry { a = 0; }
        entities.SoA.xPos_px[y] = a;

        // Entity moving left

        a -= entities.SoA.tileHitbox_halfWidth[y];
        if !carry { a = 0; }
        _left = a;

        // calculate tile position
        _tmp = a = a >>> 4;
        x = a = (_top & 0xf0) + _tmp;

        a = mapTileProperties[x];
        if negative {
            // solid collision
            a = (~_left & 0xf);
            a++;
            a += entities.SoA.xPos_px[y];
            if carry { a = 0xff; }
            entities.SoA.xPos_px[y] = a;

            entities.SoA.movementState[y] = a = entities.SoA.movementState[y] | entities.MovementState.LEFT_COLLISION;
        }
        else {
            // Check if the hitbox touches the tile below this one
            a = (_top & 0xf) + entities.SoA.tileHitbox_halfHeight[y] + entities.SoA.tileHitbox_halfHeight[y];
            if a >= METATILE_SIZE + 1 {
                a = (&mapTileProperties[MAP_WIDTH])[x];
                if negative {
                    a = (~_left & 0xf);
                    a++;
                    a += entities.SoA.xPos_px[y];
                    if carry { a = 0xff; }
                    entities.SoA.xPos_px[y] = a;

                    entities.SoA.movementState[y] = a = entities.SoA.movementState[y] | entities.MovementState.LEFT_COLLISION;
                }
            }
        }
    }
    else {
        a +#= entities.SoA.xPos_px[y];
        if carry { a = 0xff; }
        entities.SoA.xPos_px[y] = a;

        // Entity moving right

        a += entities.SoA.tileHitbox_halfWidth[y];
        if carry { a = 0xff; }
        _right = a;

        // calculate tile position
        _tmp = a = a >>> 4;
        x = a = (_top & 0xf0) + _tmp;

        a = mapTileProperties[x];
        if negative {
            // solid collision
            a = (_right & 0xf0);
            a--;
            a -= entities.SoA.tileHitbox_halfWidth[y];
            if !carry { a = 1; }
            entities.SoA.xPos_px[y] = a;
            entities.SoA.movementState[y] = a = entities.SoA.movementState[y] | entities.MovementState.RIGHT_COLLISION;
        }
        else {
            // Check if the hitbox touches the tile below this one
            a = (_top & 0xf) + entities.SoA.tileHitbox_halfHeight[y] + entities.SoA.tileHitbox_halfHeight[y];
            if a >= METATILE_SIZE + 1 {
                a = (&mapTileProperties[MAP_WIDTH])[x];
                if negative {
                    // solid collision
                    a = (_right & 0xf0);
                    a--;
                    a -= entities.SoA.tileHitbox_halfWidth[y];
                    if !carry { a = 1; }
                    entities.SoA.xPos_px[y] = a;
                    entities.SoA.movementState[y] = a = entities.SoA.movementState[y] | entities.MovementState.RIGHT_COLLISION;
                }
            }
        }
    }

    return y;
}



// Add Y-Velocity to Y-Position and preform a collision test in the Y axis (screen boundary is not-solid).
//
// NOTE: If you edit this function, you should also edit `_move_entity_and_collision_test__bounded__y_axis`.
//
// OUTPUT: entities.SoA.movementState bits will be set if there is a collision, otherwise cleared.
// KEEP: Y
// DB = 0x7e
#[mem8, idx8]
inline func _move_entity_and_collision_test__unbounded__y_axis(entityId : u8 in y) : u8 in y {
let _tmp    = zpTmp_byte_0;
let _left   = zpTmp_byte_1;
let _top    = zpTmp_byte_2;
let _bottom = zpTmp_byte_3;

    a = entities.SoA.xPos_px[y] - entities.SoA.tileHitbox_halfWidth[y];
    if !carry { a = 0; }
    _left = a;

    entities.SoA.yPos_sx[y] = a = entities.SoA.yVelocity_sx[y] + entities.SoA.yPos_sx[y];
    a = entities.SoA.yVelocity_px[y];
    if negative {
        a +#= entities.SoA.yPos_px[y];
        if !carry { a = 0; }
        entities.SoA.yPos_px[y] = a;

        // Entity moving up

        a -= entities.SoA.tileHitbox_halfHeight[y];
        if !carry { a = 0; }
        _top = a;

        // calculate tile position
        _tmp = a = _left >>> 4;
        x = a = (_top & 0xf0) + _tmp;

        a = mapTileProperties[x];
        if negative {
            // solid collision
            a = (~_top & 0xf);
            a++;
            a += entities.SoA.yPos_px[y];
            if carry { a = 0xff; }
            entities.SoA.yPos_px[y] = a;

            entities.SoA.movementState[y] = a = entities.SoA.movementState[y] | entities.MovementState.UP_COLLISION;
        }
        else {
            // Check if the hitbox touches the tile to the right of this one
            a = (_left & 0xf) + entities.SoA.tileHitbox_halfWidth[y] + entities.SoA.tileHitbox_halfWidth[y];
            if a >= METATILE_SIZE + 1 {
                // Test X index to prevent an out-of-bounds read past the rightmost tile.
                a = x & 0xf;
                if a != 0x0f {
                    a = (&mapTileProperties[1])[x];
                    if negative {
                        a = (~_top & 0xf);
                        a++;
                        a += entities.SoA.yPos_px[y];
                        if carry { a = 0xff; }
                        entities.SoA.yPos_px[y] = a;

                        entities.SoA.movementState[y] = a = entities.SoA.movementState[y] | entities.MovementState.UP_COLLISION;
                    }
                }
            }
        }
    }
    else {
        a +#= entities.SoA.yPos_px[y];
        if carry { a = 0xff; }
        entities.SoA.yPos_px[y] = a;

        // Entity moving down

        a += entities.SoA.tileHitbox_halfHeight[y];
        if carry { a = 0xff; }
        _bottom = a;

        // calculate tile position
        _tmp = a = _left >>> 4;
        x = a = (_bottom & 0xf0) + _tmp;

        a = mapTileProperties[x];
        if negative {
            // solid collision
            a = (_bottom & 0xf0);
            a--;
            a -= entities.SoA.tileHitbox_halfHeight[y];
            if !carry { a = 1; }
            entities.SoA.yPos_px[y] = a;
            entities.SoA.movementState[y] = a = entities.SoA.movementState[y] | entities.MovementState.DOWN_COLLISION;
        }
        else {
            // Check if the hitbox touches the tile to the right of this one
            a = (_left & 0xf) + entities.SoA.tileHitbox_halfWidth[y] + entities.SoA.tileHitbox_halfWidth[y];
            if a >= METATILE_SIZE + 1 {
                // Test X index to prevent an out-of-bounds read past the rightmost tile.
                a = x & 0xf;
                if a != 0x0f {
                    a = (&mapTileProperties[1])[x];
                    if negative {
                        a = (_bottom & 0xf0);
                        a--;
                        a -= entities.SoA.tileHitbox_halfHeight[y];
                        if !carry { a = 1; }
                        entities.SoA.yPos_px[y] = a;
                        entities.SoA.movementState[y] = a = entities.SoA.movementState[y] | entities.MovementState.DOWN_COLLISION;
                    }
                }
            }
        }
    }

    return y;
}



// Bounded Tile Collisions
// -----------------------



// Add velocity to the entity's position and preform a collision test (screen boundary is solid).
//
// OUTPUT: entities.SoA.movementState bits will be set if there is a collision, otherwise cleared.
//
// KEEP: Y
// DB = 0x7e
#[mem8, idx8]
func move_entity_and_collision_test__bounded(entityId : u8 in y) : u8 in y {
    // Clear movementState flags;
    entities.SoA.movementState[y] = a = 0;

    y = _move_entity_and_collision_test__bounded__x_axis(y);
    y = _move_entity_and_collision_test__bounded__y_axis(y);

    return y;
}



// Add X-Velocity to X-Position and preform a collision test in the X axis (screen boundary is solid).
//
// NOTE: If you edit this function, you should also edit `_move_entity_and_collision_test__unbounded__x_axis`.
//
// OUTPUT: entities.SoA.movementState bits will be set if there is a collision, otherwise cleared.
// KEEP: Y
#[mem8, idx8]
inline func _move_entity_and_collision_test__bounded__x_axis(entityId : u8 in y) : u8 in y {
let _tmp    = zpTmp_byte_0;
let _top    = zpTmp_byte_1;
let _left   = zpTmp_byte_2;
let _right  = zpTmp_byte_3;

    // X Axis
    // ------

    a = entities.SoA.yPos_px[y] - entities.SoA.tileHitbox_halfHeight[y];
    if !carry { a = 0; }
    _top = a;

    entities.SoA.xPos_sx[y] = a = entities.SoA.xVelocity_sx[y] + entities.SoA.xPos_sx[y];
    a = entities.SoA.xVelocity_px[y];
    ^if negative {
        a +#= entities.SoA.xPos_px[y];
        if !carry { a = 0; }
        entities.SoA.xPos_px[y] = a;

        // Entity moving left

        a -= entities.SoA.tileHitbox_halfWidth[y];
        if !carry {
            // Collided with left edge of the screen
            entities.SoA.xPos_px[y] = a = entities.SoA.tileHitbox_halfWidth[y];
            entities.SoA.movementState[y] = a = entities.SoA.movementState[y] | entities.MovementState.LEFT_COLLISION;
            ^return y;
        }
        _left = a;

        // calculate tile position
        _tmp = a = a >>> 4;
        x = a = (_top & 0xf0) + _tmp;

        a = mapTileProperties[x];
        if negative {
            // solid collision
            a = (~_left & 0xf);
            a++;
            a += entities.SoA.xPos_px[y];
            if carry { a = 0xff; }
            entities.SoA.xPos_px[y] = a;

            entities.SoA.movementState[y] = a = entities.SoA.movementState[y] | entities.MovementState.LEFT_COLLISION;
        }
        else {
            // Check if the hitbox touches the tile below this one
            a = (_top & 0xf) + entities.SoA.tileHitbox_halfHeight[y] + entities.SoA.tileHitbox_halfHeight[y];
            if a >= METATILE_SIZE + 1 {
                a = (&mapTileProperties[MAP_WIDTH])[x];
                if negative {
                    a = (~_left & 0xf);
                    a++;
                    a += entities.SoA.xPos_px[y];
                    if carry { a = 0xff; }
                    entities.SoA.xPos_px[y] = a;

                    entities.SoA.movementState[y] = a = entities.SoA.movementState[y] | entities.MovementState.LEFT_COLLISION;
                }
            }
        }
    }
    else {
        a +#= entities.SoA.xPos_px[y];
        if carry { a = 0xff; }
        entities.SoA.xPos_px[y] = a;

        // Entity moving right

        a += entities.SoA.tileHitbox_halfWidth[y];
        if carry {
            // Collided with right edge of the screen
            entities.SoA.xPos_px[y] = a = (MAP_WIDTH_PIXELS - 1) - entities.SoA.tileHitbox_halfWidth[y];
            entities.SoA.movementState[y] = a = entities.SoA.movementState[y] | entities.MovementState.RIGHT_COLLISION;
            return y;
        }
        _right = a;

        // calculate tile position
        _tmp = a = a >>> 4;
        x = a = (_top & 0xf0) + _tmp;

        a = mapTileProperties[x];
        if negative {
            // solid collision
            a = (_right & 0xf0);
            a--;
            a -= entities.SoA.tileHitbox_halfWidth[y];
            if !carry { a = 1; }
            entities.SoA.xPos_px[y] = a;
            entities.SoA.movementState[y] = a = entities.SoA.movementState[y] | entities.MovementState.RIGHT_COLLISION;
        }
        else {
            // Check if the hitbox touches the tile below this one
            a = (_top & 0xf) + entities.SoA.tileHitbox_halfHeight[y] + entities.SoA.tileHitbox_halfHeight[y];
            if a >= METATILE_SIZE + 1 {
                a = (&mapTileProperties[MAP_WIDTH])[x];
                if negative {
                    // solid collision
                    a = (_right & 0xf0);
                    a--;
                    a -= entities.SoA.tileHitbox_halfWidth[y];
                    if !carry { a = 1; }
                    entities.SoA.xPos_px[y] = a;
                    entities.SoA.movementState[y] = a = entities.SoA.movementState[y] | entities.MovementState.RIGHT_COLLISION;
                }
            }
        }
    }

    return y;
}



// Add Y-Velocity to Y-Position and preform a collision test in the Y axis (screen boundary is solid).
//
// NOTE: If you edit this function, you should also edit `_move_entity_and_collision_test__unbounded__y_axis`.
//
// OUTPUT: entities.SoA.movementState bits will be set if there is a collision, otherwise cleared.
// KEEP: Y
// DB = 0x7e
#[mem8, idx8]
inline func _move_entity_and_collision_test__bounded__y_axis(entityId : u8 in y) : u8 in y {
let _tmp    = zpTmp_byte_0;
let _left   = zpTmp_byte_1;
let _top    = zpTmp_byte_2;
let _bottom = zpTmp_byte_3;

    a = entities.SoA.xPos_px[y] - entities.SoA.tileHitbox_halfWidth[y];
    if !carry { a = 0; }
    _left = a;

    entities.SoA.yPos_sx[y] = a = entities.SoA.yVelocity_sx[y] + entities.SoA.yPos_sx[y];
    a = entities.SoA.yVelocity_px[y];
    ^if negative {
        a +#= entities.SoA.yPos_px[y];
        if !carry { a = 0; }
        entities.SoA.yPos_px[y] = a;

        // Entity moving up

        a -= entities.SoA.tileHitbox_halfHeight[y];
        if !carry {
            // Collided with top edge of screen
            entities.SoA.yPos_px[y] = a = entities.SoA.tileHitbox_halfHeight[y];
            entities.SoA.movementState[y] = a = entities.SoA.movementState[y] | entities.MovementState.UP_COLLISION;
            ^return y;
        }
        _top = a;

        // calculate tile position
        _tmp = a = _left >>> 4;
        x = a = (_top & 0xf0) + _tmp;

        a = mapTileProperties[x];
        if negative {
            // solid collision
            a = (~_top & 0xf);
            a++;
            a += entities.SoA.yPos_px[y];
            if carry { a = 0xff; }
            entities.SoA.yPos_px[y] = a;

            entities.SoA.movementState[y] = a = entities.SoA.movementState[y] | entities.MovementState.UP_COLLISION;
        }
        else {
            // Check if the hitbox touches the tile to the right of this one
            a = (_left & 0xf) + entities.SoA.tileHitbox_halfWidth[y] + entities.SoA.tileHitbox_halfWidth[y];
            if a >= METATILE_SIZE + 1 {
                // Test X index to prevent an out-of-bounds read past the rightmost tile.
                a = x & 0xf;
                if a != 0x0f {
                    a = (&mapTileProperties[1])[x];
                    if negative {
                        a = (~_top & 0xf);
                        a++;
                        a += entities.SoA.yPos_px[y];
                        if carry { a = 0xff; }
                        entities.SoA.yPos_px[y] = a;

                        entities.SoA.movementState[y] = a = entities.SoA.movementState[y] | entities.MovementState.UP_COLLISION;
                    }
                }
            }
        }
    }
    else {
        a +#= entities.SoA.yPos_px[y];
        if carry { a = 0xff; }
        entities.SoA.yPos_px[y] = a;

        // Entity moving down

        a += entities.SoA.tileHitbox_halfHeight[y];
        if carry || a >= MAP_HEIGHT_PIXELS {
            // Collided with bottom edge of the screen
            entities.SoA.yPos_px[y] = a = (MAP_HEIGHT_PIXELS - 1) - entities.SoA.tileHitbox_halfHeight[y];
            entities.SoA.movementState[y] = a = entities.SoA.movementState[y] | entities.MovementState.DOWN_COLLISION;
            ^return y;
        }
        _bottom = a;

        // calculate tile position
        _tmp = a = _left >>> 4;
        x = a = (_bottom & 0xf0) + _tmp;

        a = mapTileProperties[x];
        if negative {
            // solid collision
            a = (_bottom & 0xf0);
            a--;
            a -= entities.SoA.tileHitbox_halfHeight[y];
            if !carry { a = 1; }
            entities.SoA.yPos_px[y] = a;
            entities.SoA.movementState[y] = a = entities.SoA.movementState[y] | entities.MovementState.DOWN_COLLISION;
        }
        else {
            // Check if the hitbox touches the tile to the right of this one
            a = (_left & 0xf) + entities.SoA.tileHitbox_halfWidth[y] + entities.SoA.tileHitbox_halfWidth[y];
            if a >= METATILE_SIZE + 1 {
                // Test X index to prevent an out-of-bounds read past the rightmost tile.
                a = x & 0xf;
                if a != 0x0f {
                    a = (&mapTileProperties[1])[x];
                    if negative {
                        a = (_bottom & 0xf0);
                        a--;
                        a -= entities.SoA.tileHitbox_halfHeight[y];
                        if !carry { a = 1; }
                        entities.SoA.yPos_px[y] = a;
                        entities.SoA.movementState[y] = a = entities.SoA.movementState[y] | entities.MovementState.DOWN_COLLISION;
                    }
                }
            }
        }
    }

    return y;
}

}


// Transitions
// ===========

namespace transitions {

let TRANSITION_SPEED = 8;


in wram7e {
    // Map position within the current transition
    // (byte index)
    var mapPos : u8;


    // Variable to determine which of the two tilemaps the current map is drawn to.
    //
    //  * zero value = VRAM_BG1_MAP_WADDR
    //  * non-zero value = VRAM_BG1_MAP_WADDR + 0x400
    //
    //
    // This flag MUST only be changed by `_reset_state()` and `swap_currentTilemap()`.
    //
    // (byte flag)
    var currentTilemap : u8;


    // The tilemap row (within VRAM) that matches the top row of the room map.
    //
    // This value should be masked by `topmostRowInVram_MASK` whenever it is used to calculate a VRAM address.
    //
    // (byte)
    var topmostRowInVram : u8;

    let topmostRowInVram_MASK = 0x1f;


    // A buffer containing a single row/column to transfer to VRAM.
    var buffer : [u8 ; 32 * 2];
}


in shadow {
    // `VMAIN` register to use when transferring the buffer to VRAM.
    //
    // NOTE: If this value is 0 then no buffer will be transferred.
    //
    // (byte)
    var buffer_vram_control : u8;


    // VRAM word position to store the buffer to.
    //
    // NOTE: This variable is handled differently in horizontal and vertical transitions.
    //
    // (word)
    var buffer_vramWordPos : u16;

    // ::ANNOY why do I have to do this?::
    // ::: Used to work around a "could not generate code for assignment `=` (got: `a = *(8269313 as *u8)` (mem8, idx8))" error::
    let buffer_vramWordPos_l = *(&<:buffer_vramWordPos as *u8);
    let buffer_vramWordPos_h = *(&>:buffer_vramWordPos as *u8);
}


in code {



// Transfer the buffer to VRAM if required.
//
// REQUIRES: V-Blank
//
// Uses DMA channel 0
//
// DB = 0x80
#[mem8, idx16]
func transfer_buffer__vblank() {
    a = buffer_vram_control;
    if !zero {
        snes.ppu.vram_control = a;

        snes.ppu.vram_address_hl = xx = buffer_vramWordPos;

        snes.dma0.control = a = snes.dma.CONTROL_MODE_AB;
        snes.dma0.mdma_dest = a = <:&snes.ppu.vram_write_data_l;

        snes.dma0.src_address_hl = xx = &buffer as u16;
        snes.dma0.src_address_bank = a = #:far &buffer;

        snes.dma0.mdma_size_hl = xx = sizeof(typeof(buffer));

        snes.dma.mdma_enable = a = snes.dma.ENABLE_0;


        // Do not transfer buffer on the next frame
        buffer_vram_control = 0;
    }
}



// Reset internal state and scroll positions.
//
// DB = 0x7e
#[mem8, idx8]
inline func _reset_state() {
    transitions.currentTilemap = 0;
    transitions.topmostRowInVram = 0;

    // Reset BG1 scroll
    *(&<:bg1_scrollX as *u8) = 0;
    *(&>:bg1_scrollX as *u8) = 0;

    a = 0xff;
    *(&<:bg1_scrollY as *u8) = a;
    *(&>:bg1_scrollY as *u8) = a;
}



// Horizontal Transitions
// ----------------------


// Invert the `currentTilemap` flag.
//
// DB = 0x7e
#[mem8, idx8]
inline func swap_currentTilemap() {
    currentTilemap = a = currentTilemap ^ 0xff;
}



// Fill the buffer with the right half of a MetaTile column and queue a transfer during VBlank.
//
// REQUIRES: buffer_vramWordPos set.
//
// DB = 0x7e
#[mem8, idx8]
func _draw_left_column() {
let _tmp = zpTmp_byte_0;

    y = a = (topmostRowInVram & topmostRowInVram_MASK) << 1;

    a = mapPos;

    do {
        _tmp = a;

        x = a = map[x = a];

        buffer[y++] = a = tileset.topLeft_low[x];
        buffer[y++] = a = tileset.topLeft_high[x];
        buffer[y++] = a = tileset.bottomLeft_low[x];
        buffer[y++] = a = tileset.bottomLeft_high[x];

        if y == sizeof(typeof(buffer)) {
            y = 0;
        }

        a = _tmp + 0x10;
    }
    while a < MAP_HEIGHT * MAP_WIDTH;


    buffer_vram_control = a = snes.ppu.VRAM_CONTROL_INCREMENT_32 | snes.ppu.VRAM_CONTROL_REMAP_MODE_0 | snes.ppu.VRAM_CONTROL_SIZE_2;
}



// Fill the buffer with the right half of a MetaTile column and queue a transfer during VBlank.
//
// REQUIRES: buffer_vramWordPos set.
//
// DB = 0x7e
#[mem8, idx8]
func _draw_right_column() {
let _tmp = zpTmp_byte_0;

    y = a = (topmostRowInVram & topmostRowInVram_MASK) << 1;

    a = mapPos;

    do {
        _tmp = a;

        x = a = map[x = a];

        buffer[y++] = a = tileset.topRight_low[x];
        buffer[y++] = a = tileset.topRight_high[x];
        buffer[y++] = a = tileset.bottomRight_low[x];
        buffer[y++] = a = tileset.bottomRight_high[x];

        if y == sizeof(typeof(buffer)) {
            y = 0;
        }

        a = _tmp + 0x10;
    }
    while a < MAP_HEIGHT * MAP_WIDTH;


    buffer_vram_control = a = snes.ppu.VRAM_CONTROL_INCREMENT_32 | snes.ppu.VRAM_CONTROL_REMAP_MODE_0 | snes.ppu.VRAM_CONTROL_SIZE_2;
}



// Initialize a scroll right transition.
//
// DB = 0x7e
#[mem8, idx8]
func scroll_right__setup() {

    mapPos = 0;


    // Determine the next VRAM position
    let VRAM_OFFSET = 0;

    // Subtract one to counter the +1 at the start of `right__process()`
    *(&<:buffer_vramWordPos as *u8) = a = <:(VRAM_BG1_MAP_WADDR + VRAM_OFFSET - 1);

    a = currentTilemap;
    if !zero {
        a = >:(VRAM_BG1_MAP_WADDR + VRAM_OFFSET);
    }
    else {
        a = >:(VRAM_BG1_MAP_WADDR + VRAM_OFFSET + 0x400);
    }
    *(&>:buffer_vramWordPos as *u8) = a;
}



// Process a scroll right transition.
//
// This function is to be called once per frame until the transition has completed.
//
// Returns true if transition is complete.
//
// DB = 0x7e
#[mem8, idx8]
func scroll_right__process() : bool in carry {

    *(&<:bg1_scrollX as *u8) = a = *(&<:bg1_scrollX as *u8) + TRANSITION_SPEED;
    if carry {
        (*(&>:bg1_scrollX as *u8))++;
    }


    a = buffer_vramWordPos_l;
    a++;
    buffer_vramWordPos_l = a;

    if a & 1 == 0 {
        _draw_left_column();
    }
    else {
        _draw_right_column();

        mapPos++;
    }


    a = mapPos;
    if a == MAP_WIDTH {
        swap_currentTilemap();

        return true;
    }

    return false;
}



// Rollback a scroll right transition.
//
// This function is to be called once per frame until it returns true.
//
// Returns true if transition is complete.
//
// DB = 0x7e
#[mem8, idx8]
func scroll_right__rollback() : bool in carry {

    // no need to draw tiles, only need to change scroll.

    *(&<:bg1_scrollX as *u8) = a = *(&<:bg1_scrollX as *u8) - TRANSITION_SPEED;
    if !carry {
        (*(&>:bg1_scrollX as *u8))--;
    }

    if a == 0 {
        return true;
    }
    return false;
}



// Initialize a scroll left transition.
//
// DB = 0x7e
#[mem8, idx8]
func scroll_left__setup() {

    mapPos = a = 0xf;

    // Determine the next VRAM position
    let VRAM_OFFSET = 31;

    // Add one to counter the -1 at the start of `left__process()`
    *(&<:buffer_vramWordPos as *u8) = a = <:(VRAM_BG1_MAP_WADDR + VRAM_OFFSET + 1);

    a = currentTilemap;
    if !zero {
        a = >:(VRAM_BG1_MAP_WADDR + VRAM_OFFSET);
    }
    else {
        a = >:(VRAM_BG1_MAP_WADDR + VRAM_OFFSET + 0x400);
    }
    *(&>:buffer_vramWordPos as *u8) = a;
}



// Process a scroll left transition.
//
// This function is to be called once per frame until the transition has completed.
//
// Returns true if transition is complete.
//
// DB = 0x7e
#[mem8, idx8]
func scroll_left__process() : bool in carry {

    *(&<:bg1_scrollX as *u8) = a = *(&<:bg1_scrollX as *u8) - TRANSITION_SPEED;
    if !carry {
        (*(&>:bg1_scrollX as *u8))--;
    }


    a = buffer_vramWordPos_l;
    a--;
    buffer_vramWordPos_l = a;

    if a & 1 != 0 {
        _draw_right_column();
    }
    else {
        _draw_left_column();

        mapPos--;
    }


    a = mapPos;
    if negative {
        swap_currentTilemap();

        return true;
    }

    return false;
}



// Rollback a scroll left transition.
//
// This function is to be called once per frame until it returns true.
//
// Returns true if transition is complete.
//
// DB = 0x7e
#[mem8, idx8]
func scroll_left__rollback() : bool in carry {

    // no need to draw tiles, only need to change scroll.

    *(&<:bg1_scrollX as *u8) = a = *(&<:bg1_scrollX as *u8) + TRANSITION_SPEED;
    if carry {
        (*(&>:bg1_scrollX as *u8))++;
    }

    if a == 0 {
        return true;
    }
    return false;
}



// Vertical Transitions
// --------------------



// Calculate the `buffer_vramWordPos` value to use for a vertical scroll transition.
//
// DB = 0x7e
#[mem8, idx8]
func _calculate_vram_position_for_row(tilemapRow : u8 in a) {
    mem16();
    #[mem16] {
        aa = (aa & topmostRowInVram_MASK) << 5;

        #[compile_if(VRAM_BG1_MAP_WADDR != 0)] {
            aa += VRAM_BG1_MAP_WADDR;
        }

        x = currentTilemap;
        if !zero {
            aa += 0x400;
        }

        buffer_vramWordPos = aa;
    }
    mem8();
}



// Fill the buffer with the top half of a MetaTile row and queue a transfer during VBlank.
//
// DB = 0x7e
#[mem8, idx8]
func _draw_top_row(tilemapRow : u8 in a) {
let _tmp = zpTmp_byte_0;

    _calculate_vram_position_for_row(a);


    y = 0;
    a = mapPos;

    do {
        _tmp = a;

        x = a = map[x = a];

        buffer[y++] = a = tileset.topLeft_low[x];
        buffer[y++] = a = tileset.topLeft_high[x];
        buffer[y++] = a = tileset.topRight_low[x];
        buffer[y++] = a = tileset.topRight_high[x];

        a = _tmp;
        a++;
    }
    while y < sizeof(typeof(buffer));


    buffer_vram_control = a = snes.ppu.VRAM_CONTROL_INCREMENT_1 | snes.ppu.VRAM_CONTROL_REMAP_MODE_0 | snes.ppu.VRAM_CONTROL_SIZE_2;
}



// Fill the buffer with the bottom half of a MetaTile row and queue a transfer during VBlank.
//
// DB = 0x7e
#[mem8, idx8]
func _draw_bottom_row(tilemapRow : u8 in a) {
let _tmp = zpTmp_byte_0;

    _calculate_vram_position_for_row(a);


    y = 0;
    a = mapPos;

    do {
        _tmp = a;

        x = a = map[x = a];

        buffer[y++] = a = tileset.bottomLeft_low[x];
        buffer[y++] = a = tileset.bottomLeft_high[x];
        buffer[y++] = a = tileset.bottomRight_low[x];
        buffer[y++] = a = tileset.bottomRight_high[x];

        a = _tmp;
        a++;
    }
    while y < sizeof(typeof(buffer));


    buffer_vram_control = a = snes.ppu.VRAM_CONTROL_INCREMENT_1 | snes.ppu.VRAM_CONTROL_REMAP_MODE_0 | snes.ppu.VRAM_CONTROL_SIZE_2;
}



// Initialize a scroll down transition.
//
// DB = 0x7e
#[mem8, idx8]
func scroll_down__setup() {

    mapPos = 0;
}



// Process a scroll down transition.
//
// This function is to be called once per frame until the transition has completed.
//
// Returns true if transition is complete.
//
// DB = 0x7e
#[mem8, idx8]
func scroll_down__process() : bool in carry {

    *(&<:bg1_scrollY as *u8) = a = *(&<:bg1_scrollY as *u8) + TRANSITION_SPEED;


    a = topmostRowInVram;
    a++;
    topmostRowInVram = a;

    if a & 1 != 0 {
        _draw_top_row(a + MAP_HEIGHT * 2 - 1);
    }
    else {
        _draw_bottom_row(a + MAP_HEIGHT * 2 - 1);

        mapPos = a = mapPos + MAP_WIDTH;

        if a >= MAP_WIDTH * MAP_HEIGHT {
            return true;
        }
    }

    return false;
}




// Initialize a scroll up transition.
//
// DB = 0x7e
#[mem8, idx8]
func scroll_up__setup() {

    mapPos = a = MAP_WIDTH * (MAP_HEIGHT - 1);
}



// Process a scroll up transition.
//
// This function is to be called once per frame until the transition has completed.
//
// Returns true if transition is complete.
//
// DB = 0x7e
#[mem8, idx8]
func scroll_up__process() : bool in carry {

    *(&<:bg1_scrollY as *u8) = a = *(&<:bg1_scrollY as *u8) - TRANSITION_SPEED;


    a = topmostRowInVram;
    a--;
    topmostRowInVram = a;

    if a & 1 != 0 {
        _draw_bottom_row(a);
    }
    else {
        _draw_top_row(a);

        mapPos = a = mapPos - 0x10;

        if a >= MAP_WIDTH * MAP_HEIGHT{
            return true;
        }
    }

    return false;
}

}

}
}


