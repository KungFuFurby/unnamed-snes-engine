// Copyright (c) 2021, Marcus Rowe <undisbeliever@gmail.com>.
// Distributed under The MIT License, see the LICENSE file for more details.

import "memmap";
import "resources";
import "../wiz/common/snes/snes";

import "entities/_variables";


namespace metatiles {

let METATILE_SIZE = 16;

let MAP_WIDTH = 16;
let MAP_HEIGHT = 14;


let TILE_PROPERTY_SOLID_BIT = 7;


// Tileset data stored in RAM
struct _Tileset {
    // Mapping of each of the 4 tiles within each MetaTile.
    topLeft_low :      [u8 ; 256],
    topLeft_high :     [u8 ; 256],
    topRight_low :     [u8 ; 256],
    topRight_high :    [u8 ; 256],
    bottomLeft_low :   [u8 ; 256],
    bottomLeft_high :  [u8 ; 256],
    bottomRight_low :  [u8 ; 256],
    bottomRight_high : [u8 ; 256],

    // Tile properties for each MetaTile
    // (`TILE_PROPERTY_*_BIT` bitfield for each tile)
    properties:        [u8 ; 256],
};


// Tileset data format in ROM.
struct _DataFormat {
    tile_data_size : u16,

    ram_data : _Tileset,

    palette_data : [u16 ; 128],

    tile_data : u8,
};


in zeropage {

}

in wram7e {
    // The map for the current room.
    //
    // NOTE: Whenever the map is updated the corresponding `mapTileProperties` cells must be changed.
    #[align(256)]
    var map : [u8 ; 256];

    // The MetaTile tileset tile properties for each map tile.
    //
    // (bitfield of `TILE_PROPERTY_*_BIT`s for each map tile.)
    //
    // Whenever the map is updated the corresponding `mapTileProperties` cells must be changed.
    #[align(256)]
    var mapTileProperties : [u8 ; 256];


    // this hack allows me to write `tileset.topLeft[y]` without a compile error.
    #[align(256)]
    var __far_tileset : _Tileset;
    let tileset = *(&__far_tileset as *_Tileset);
}


in code {


// Load a map into memory
//
// DB = 0x7e
#[mem8, idx16]
func load_map(map_id : u8 in a) {
let _tmp = <:dpTmp0;
let _mapPtr = dpTmp_farPtr;

    if a >= sizeof(typeof(resources.maps.map_list_l)) {
        a = 0;
    }

    idx8();
    #[idx8] {
        x = a;

        <:_mapPtr = a = resources.maps.map_list_l[x];
        >:_mapPtr = a = resources.maps.map_list_h[x];
        #:_mapPtr = a = resources.maps.map_list_b[x];
    }
    idx16();


    yy = sizeof(typeof(map));
    do {
        map[yy] = a = _mapPtr[yy];
        yy--;
    } while !negative;
}


// Load a tileset into memory and the PPU
//
// REQUIRES: Force-Blank
// Uses DMA channel 0
//
// NOTE: tileset address cannot be in RAM.
//
// DB = 0x80
#[mem8, idx16]
func load_tileset__forceblank(tileset_bank : u8 in a, tileset_addr : u16 in xx) {
let _tilesetPtr = dpTmp_farPtr;

    // Save pointer so we can retrieve `_DataFormat.tile_data_size` later
    #:_tilesetPtr = a;
    *(&_tilesetPtr as *u16) = xx;

    // Skip _DataFormat.tile_data_size in DMA's below
    xx++;
    xx++;


    snes.dma.hdma_enable = 0;

    snes.dma0.src_address_bank = a;
    snes.dma0.src_address_hl = xx;


    // Copy first data block (tileset) into RAM
    snes.wram.address_hl = xx = &tileset as u16;
    snes.wram.address_bank = a = (#:far &__far_tileset) & 1;

    snes.dma0.control = a = snes.dma.CONTROL_MODE_A;
    snes.dma0.mdma_dest = a = <:&snes.wram.data;
    snes.dma0.mdma_size_hl = xx = sizeof(_Tileset);

    snes.dma.mdma_enable = a = snes.dma.ENABLE_0;


    // Load palette to CGRAM
    snes.ppu.cgram_address = 0;

    snes.dma0.mdma_dest = a = <:&snes.ppu.cgram_write_data;
    snes.dma0.mdma_size_hl = yy = 128 * 2;

    snes.dma.mdma_enable = a = snes.dma.ENABLE_0;


    // Load tiles into VRAM
    snes.ppu.vram_control = a = snes.ppu.VRAM_CONTROL_INCREMENT_1 | snes.ppu.VRAM_CONTROL_REMAP_MODE_0 | snes.ppu.VRAM_CONTROL_SIZE_2;
    snes.ppu.vram_address_hl = xx = VRAM_BG1_TILES_WADDR;

    snes.dma0.control = a = snes.dma.CONTROL_MODE_AB;
    snes.dma0.mdma_dest = a = <:&snes.ppu.vram_write_data_l;

    mem16();
    #[mem16] {
        snes.dma0.mdma_size_hl = aa = **(&_tilesetPtr as *far *u16);
    }
    mem8();

    snes.dma.mdma_enable = a = snes.dma.ENABLE_0;
}



// Draws the entire map to BG1.
//
// REQUIRES: Force-Blank, Tileset loaded into memory.
//
// DB = unknown
#[mem8, idx8]
func draw_map__forceblank() {
let _rowsLeft    = <:dpTmp0;
let _columnsLeft = >:dpTmp0;

    push8(data_bank);

    push8(program_bank);
    data_bank = pop8();
// DB = 0x80

    snes.ppu.brightness = a = snes.ppu.BRIGHTNESS_FORCE_BLANK | snes.ppu.BRIGHTNESS_MASK;

    snes.ppu.vram_control = a = snes.ppu.VRAM_CONTROL_INCREMENT_1 | snes.ppu.VRAM_CONTROL_REMAP_MODE_0 | snes.ppu.VRAM_CONTROL_SIZE_2;
    snes.ppu.vram_address_l = <:VRAM_BG1_MAP_WADDR;
    snes.ppu.vram_address_h = >:VRAM_BG1_MAP_WADDR;


    // Reset BG1 scroll
    snes.ppu.bg1_scroll_x = 0;
    snes.ppu.bg1_scroll_x = 0;

    a = 0xff;
    snes.ppu.bg1_scroll_y = a;
    snes.ppu.bg1_scroll_y = a;



    push8(a = 0x7e);
    data_bank = pop8();
// DB = 0x7e


    // ::TODO setup variables::


    // X = map position
    x = 0;

    _rowsLeft = a = MAP_HEIGHT;
    do {
        push8(x);

        _columnsLeft = a = MAP_WIDTH;
        do {
            y = map[x];

            *(far &snes.ppu.vram_write_data_l) = a = tileset.topLeft_low[y];
            *(far &snes.ppu.vram_write_data_h) = a = tileset.topLeft_high[y];
            *(far &snes.ppu.vram_write_data_l) = a = tileset.topRight_low[y];
            *(far &snes.ppu.vram_write_data_h) = a = tileset.topRight_high[y];

            x++;
            _columnsLeft--;
        } while !zero;

        x = pop8();

        _columnsLeft = a = MAP_WIDTH;
        do {
            y = map[x];

            *(far &snes.ppu.vram_write_data_l) = a = tileset.bottomLeft_low[y];
            *(far &snes.ppu.vram_write_data_h) = a = tileset.bottomLeft_high[y];
            *(far &snes.ppu.vram_write_data_l) = a = tileset.bottomRight_low[y];
            *(far &snes.ppu.vram_write_data_h) = a = tileset.bottomRight_high[y];

            x++;
            _columnsLeft--;
        } while !zero;


        _rowsLeft--;
    } while !zero;


    data_bank = pop8();
}



// Populate the `mapTileProperties` array.
//
// This function MUST be called when the map is loaded
//
// DB = 0x7e
#[mem8, idx8]
func populate_map_tile_properties() {
    x = 0;
    do {
        y = map[x];
        mapTileProperties[x] = a = tileset.properties[y];

        x++;
    } while !zero;
}



// Add velocity to the entity's position and preform a collision test.
//
// OUTPUT: entities.SoA.movementState bits will be set if there is a collision, otherwise cleared.
//
// KEEP: X
// DB = 0x7e
#[mem8, idx8]
func move_entity_and_collision_test(entityId : u8 in x) : u8 in x {
    // Clear movementState flags;
    entities.SoA.movementState[x] = 0;

    x = _move_entity_and_collision_test_x_axis(x);
    x = _move_entity_and_collision_test_y_axis(x);

    return x;
}



// Add X-Velocity to X-Position and preform a collision test in the X axis
//
// OUTPUT: entities.SoA.movementState bits will be set if there is a collision, otherwise cleared.
// KEEP: X
#[mem8, idx8]
func _move_entity_and_collision_test_x_axis(entityId : u8 in x) : u8 in x {
let _tmp    = <:dpTmp0;
let _top    = >:dpTmp0;
let _left   = <:dpTmp1;
let _right  = <:dpTmp1;

    // X Axis
    // ------

    a = entities.SoA.yPos_px[x] - entities.SoA.tileHitbox_halfHeight[x];
    if !carry { a = 0; }
    _top = a;

    entities.SoA.xPos_sx[x] = a = entities.SoA.xVelocity_sx[x] + entities.SoA.xPos_sx[x];
    a = entities.SoA.xVelocity_px[x];
    if negative {
        a +#= entities.SoA.xPos_px[x];
        if !carry { a = 0; }
        entities.SoA.xPos_px[x] = a;

        // Entity moving left

        a -= entities.SoA.tileHitbox_halfWidth[x];
        if !carry { a = 0; }
        _left = a;

        // calculate tile position
        _tmp = a = a >>> 4;
        y = a = (_top & 0xf0) + _tmp;

        a = mapTileProperties[y];
        if negative {
            // solid collision
            entities.SoA.xPos_px[x] = a = (~_left & 0xf) + 1 + entities.SoA.xPos_px[x];
            entities.SoA.movementState[x] = a = entities.SoA.movementState[x] | entities.MovementState.LEFT_COLLISION;
        }
        else {
            // Check if the hitbox touches the tile below this one
            a = (_top & 0xf) + entities.SoA.tileHitbox_halfHeight[x] + entities.SoA.tileHitbox_halfHeight[x];
            if a >= METATILE_SIZE {
                a = (&mapTileProperties[MAP_WIDTH])[y];
                if negative {
                    entities.SoA.xPos_px[x] = a = (~_left & 0xf) + 1 + entities.SoA.xPos_px[x];
                    entities.SoA.movementState[x] = a = entities.SoA.movementState[x] | entities.MovementState.LEFT_COLLISION;
                }
            }
        }
    }
    else {
        a +#= entities.SoA.xPos_px[x];
        if carry { a = 0xff; }
        entities.SoA.xPos_px[x] = a;

        // Entity moving right

        a += entities.SoA.tileHitbox_halfWidth[x];
        if carry { a = 0xff; }
        _right = a;

        // calculate tile position
        _tmp = a = a >>> 4;
        y = a = (_top & 0xf0) + _tmp;

        a = mapTileProperties[y];
        if negative {
            // solid collision
            a = (_right & 0xf0) - entities.SoA.tileHitbox_halfWidth[x];
            if !carry { a = 1; }
            a--;
            entities.SoA.xPos_px[x] = a;
            entities.SoA.movementState[x] = a = entities.SoA.movementState[x] | entities.MovementState.RIGHT_COLLISION;
        }
        else {
            // Check if the hitbox touches the tile below this one
            a = (_top & 0xf) + entities.SoA.tileHitbox_halfHeight[x] + entities.SoA.tileHitbox_halfHeight[x];
            if a >= METATILE_SIZE {
                a = (&mapTileProperties[MAP_WIDTH])[y];
                if negative {
                    // solid collision
                    a = (_right & 0xf0) - entities.SoA.tileHitbox_halfWidth[x];
                    if !carry { a = 1; }
                    a--;
                    entities.SoA.xPos_px[x] = a;
                    entities.SoA.movementState[x] = a = entities.SoA.movementState[x] | entities.MovementState.RIGHT_COLLISION;
                }
            }
        }
    }

    return x;
}



// Add Y-Velocity to Y-Position and preform a collision test in the Y axis
//
// OUTPUT: entities.SoA.movementState bits will be set if there is a collision, otherwise cleared.
// KEEP: X
// DB = 0x7e
#[mem8, idx8]
func _move_entity_and_collision_test_y_axis(entityId : u8 in x) : u8 in x {
let _tmp    = <:dpTmp0;
let _left   = >:dpTmp0;
let _top    = <:dpTmp1;
let _bottom = <:dpTmp1;

    a = entities.SoA.xPos_px[x] - entities.SoA.tileHitbox_halfWidth[x];
    if !carry { a = 0; }
    _left = a;

    entities.SoA.yPos_sx[x] = a = entities.SoA.yVelocity_sx[x] + entities.SoA.yPos_sx[x];
    a = entities.SoA.yVelocity_px[x];
    if negative {
        a +#= entities.SoA.yPos_px[x];
        if !carry { a = 0; }
        entities.SoA.yPos_px[x] = a;

        // Entity moving up

        a -= entities.SoA.tileHitbox_halfHeight[x];
        if !carry { a = 0; }
        _top = a;

        // calculate tile position
        _tmp = a = _left >>> 4;
        y = a = (_top & 0xf0) + _tmp;

        a = mapTileProperties[y];
        if negative {
            // solid collision
            entities.SoA.yPos_px[x] = a = (~_top & 0xf) + 1 + entities.SoA.yPos_px[x];
            entities.SoA.movementState[x] = a = entities.SoA.movementState[x] | entities.MovementState.UP_COLLISION;
        }
        else {
            // Check if the hitbox touches the tile to the right of this one
            a = (_left & 0xf) + entities.SoA.tileHitbox_halfWidth[x] + entities.SoA.tileHitbox_halfWidth[x];
            if a >= METATILE_SIZE {
                a = (&mapTileProperties[1])[y];
                if negative {
                    entities.SoA.yPos_px[x] = a = (~_top & 0xf) + 1 + entities.SoA.yPos_px[x];
                    entities.SoA.movementState[x] = a = entities.SoA.movementState[x] | entities.MovementState.UP_COLLISION;
                }
            }
        }
    }
    else {
        a +#= entities.SoA.yPos_px[x];
        if carry { a = 0xff; }
        entities.SoA.yPos_px[x] = a;

        // Entity moving down

        a += entities.SoA.tileHitbox_halfHeight[x];
        if carry { a = 0xff; }
        _bottom = a;

        // calculate tile position
        _tmp = a = _left >>> 4;
        y = a = (_bottom & 0xf0) + _tmp;

        a = mapTileProperties[y];
        if negative {
            // solid collision
            a = (_bottom & 0xf0) - entities.SoA.tileHitbox_halfHeight[x];
            if !carry { a = 1; }
            a--;
            entities.SoA.yPos_px[x] = a;
            entities.SoA.movementState[x] = a = entities.SoA.movementState[x] | entities.MovementState.DOWN_COLLISION;
        }
        else {
            // Check if the hitbox touches the tile to the right of this one
            a = (_left & 0xf) + entities.SoA.tileHitbox_halfWidth[x] + entities.SoA.tileHitbox_halfWidth[x];
            if a >= METATILE_SIZE {
                a = (&mapTileProperties[1])[y];
                if negative {
                    a = (_bottom & 0xf0) - entities.SoA.tileHitbox_halfHeight[x];
                    if !carry { a = 1; }
                    a--;
                    entities.SoA.yPos_px[x] = a;
                    entities.SoA.movementState[x] = a = entities.SoA.movementState[x] | entities.MovementState.DOWN_COLLISION;
                }
            }
        }
    }

    return x;
}

}

}


