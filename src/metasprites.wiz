// Copyright (c) 2021, Marcus Rowe <undisbeliever@gmail.com>.
// Distributed under The MIT License, see the LICENSE file for more details.

import "memmap";
import "resources";
import "common/dma";
import "common/math";
import "../wiz/common/snes/snes";

import "../gen/resources";


let DISPLAY_WIDTH = 256;
let DISPLAY_HEIGHT = 224;


namespace metasprites {

let N_OBJECTS = 128;

let SMALL_TILE_DATA_SIZE = 32;


// MUST match `SHADOW_SIZES` in `tools/convert_metasprite.py`
enum ShadowSize : u8 {
    // Deleted entities MUST NOT have a shadow
    NONE,

    SMALL,
    MEDIUM,
    LARGE,
};


// MetaSprite Frameset Data format in ROM
struct MsFramesetFormat {
    shadowSize : ShadowSize,
    tileHitbox : [u8; 2],

    // func(msFrame : u16 in yy, xPos : u16 in metasprites.xPos, yPos : u16 in metasprites.yPos)
    drawFunction : func,

    // List of pointers to `MsDataFormat` entries
    frameTable : *const *const u8,

    // List of pointers to `AnimationDataFormat` entries
    animationTable : *const *const u8,
};

// ::HACK manually create accessors to MsFramesetFormat data ::
namespace MsFsData {
    let _base = resources.MS_FS_DATA_BANK << 16;

    let shadowSize      = (_base + 0) as far *ShadowSize;
            let shadowSize__u16 = (_base + 0) as far *u16;

    let tileHitbox      = (_base + 1) as far *u16;
    let drawFunction    = (_base + 3) as far *u16;
    let frameTable      = (_base + 5) as far *u16;
    let animationTable  = (_base + 7) as far *u16;
};


// MetaSprite Frame Table Data offset in ROM
// (word addr table)
let MetaSpriteFrameTableOffset = MsFsData._base as far *u16;


// MetaSprite Animation Table Data offset in ROM
// (word addr table)
let MetaSpriteAnimationTableOffset = MsFsData._base as far *u16;


// MetaSprite Data in ROM
namespace MsDataFormat {
    let _base = resources.MS_FS_DATA_BANK << 16;


    // Byte value to use when there is no hitbox or hurtbox.
    let NO_AABB_VALUE = 0x80;


    // The MetaSprite frame's hitbox.
    //
    // If `hitbox_left` == `NO_AABB_VALUE` then the frame has no hitbox.
    let hitbox_left     = (_base + 0) as far *i8;
    let hitbox_right    = (_base + 1) as far *i8;
    let hitbox_top      = (_base + 2) as far *i8;
    let hitbox_bottom   = (_base + 3) as far *i8;


    // The MetaSprite frame's hurtbox.
    //
    // If `hurtbox_left` == `NO_AABB_VALUE` then the frame has no hurtbox.
    let hurtbox_left     = (_base + 4) as far *i8;
    let hurtbox_right    = (_base + 5) as far *i8;
    let hurtbox_top      = (_base + 6) as far *i8;
    let hurtbox_bottom   = (_base + 7) as far *i8;


    // MetaSprite Pattern Id
    //
    // Only read if the entity uses multiple MetaSprite patterns.
    //
    // (byte index into `metasprites.ms_patterns_table`, masked by `MS_PATTERNS_TABLE_MASK`)
    let pattern = (_base +  8) as far *u8;

    let xOffset = (_base +  9) as far *u8;
    let yOffset = (_base + 10) as far *u8;

    // NOTE: Not all `charAttr*` fields will be filled.
    // Most MetaSprite patterns use less then 4 charAttr words.
    let charAttr0 = (_base + 11) as far *u16;
    let charAttr1 = (_base + 13) as far *u16;
    let charAttr2 = (_base + 15) as far *u16;
    let charAttr3 = (_base + 17) as far *u16;
}



// MetaSprite Animation Data in ROM
namespace AnimationDataFormat {
    let _base = resources.MS_FS_DATA_BANK << 16;


    // Animation process function index.  First byte of an animation.
    // (index into `metasprites.animations.AnimationProcessFunctions`)
    let processFunction  = (_base + 0) as far *u8;


    // Each animation frame is two bytes in size.

        // MetaSprite FrameId to show.
        //
        // If this value is `END_OF_ANIMATION_BYTE` then the animation is over and there is no `delay` byte
        //
        // (element position in MsFramesetFormat.frameTable)
        let frame       = (_base + 1) as far *u8;

        // Animation delay.
        //
        //  * If `delayType` is `frame`, this byte is number of display frames.
        //  * If `delayType` is `distance_*`, this value is a distance in 4.4 unsigned fixed point.
        //
        // (u8 byte or 4.4 unsigned fixed point)
        let delay       = (_base + 2) as far *u8;


    // After the last frame, the Animation Data ends with a 0xff byte
    let END_OF_ANIMATION_BYTE = 0xff;


    // The shift between a 4.4 unsigned fixed point animation delay byte and a 8:8 unsigned fixed point distance
    let DISTANCE_DELAY_SHIFT = 4;
}



// MetaSprie PPU data format in ROM.
struct _PpuDataFormat {
    first_tile : u16,

    palette_data : [u16 ; 128],

    tile_data : u8,
}



struct OamEntry {
    xPos : u8,
    yPos : u8,
    char : u8,
    attr : u8
};

let OAM_V_FLIP = 0x80;
let OAM_H_FLIP = 0x40;

let SHADOW_ATTR = 0x20;



let OFFSCREEN_YPOS = 255 - 16;

let SHADOW_SMALL_CHAR  = 0x00;
let SHADOW_MEDIUM_CHAR = 0x01;
let SHADOW_LARGE_CHAR  = 0x10;


in zeropage {
    // The current index within `buffer`.
    //
    // `buffer` is read back to front.
    //
    // This value if negative if the buffer is full.
    var bufferPos : u16;

    // Queue of pending bits to write to `hiTableBuffer`.
    //
    // Bits are pushed leftwise into the queue using `lsr` or `rol`
    // instructions.
    //
    // An empty queue has the value of `HI_TABLE_QUEUE_INIT_VALUE` (`1`).  This
    // This allows for the queue-full state to be checked by reading the carry
    // flag after every second bit-shift.  When the carry flag is set, the
    // queue is full, and `_hiTableQueue_full()` must be called.
    //
    var hiTableQueue : u8;

    let HI_TABLE_QUEUE_INIT_VALUE = 1;

    let INITIAL_BUFFER_POS = (N_OBJECTS - 1) * sizeof(OamEntry);


    // Temporary variables to store the metasprite's position on screen
    var xPos : u16;
    var yPos : u16;
}


in wram7e {
    var buffer : [OamEntry ; N_OBJECTS];
    var hiTableBuffer : [u8 ; N_OBJECTS / 4];

    var hiTableBufferPos : u16;

    var oldBufferPos : u16;
}


in code {


// REQUIRES: Force-Blank
// DB = 0x80
#[mem8, idx16]
inline func setup__forceblank() {
    {
        push8(data_bank);

        push8(a = 0x7e);
        data_bank = pop8();
    // DB = 0x7e

        reset_buffers();

        data_bank = pop8();
    }

    update_oam__vblank();
}



// Load a MetaSprite Spritesheet into the PPU
//
// REQUIRES: Force-Blank
// Uses DMA Channel 0
// DB = 0x80
#[mem8, idx16]
inline func load_ms_spritesheet_ppu_data__forceblank(spritesheet_id : u8 in a) {
var _res : resources.ResourceEntry in resources.res;

    push8(a);

    // Set OBJ Registers
    snes.ppu.obj_control = a = (VRAM_OBJ_WADDR / 8192) | (snes.ppu.OBJ_CONTROL_8x8_16x16 << 4);


    // Transfer shadow data to VRAM

    // ::TODO Find a better way to store the shadow tiles in ROM and load them into VRAM::
    resources.load_tiles_resource_into_vram(resources.tiles.metasprite_shadows, VRAM_OBJ_WADDR);


    // Load common spritesheet tiles
    // Assumes resources.ms_spritesheets.common is 0
    _res = resources.load_ms_spritesheet(0);
    __transfer_ppu_data__forceblank(_res);


    // Load requested spritesheet
    // (Assumes resources.ms_spritesheets.common is 0)
    a = pop8();
    if !zero {
        _res = resources.load_ms_spritesheet(a);
        __transfer_ppu_data__forceblank(_res);
    }
}



// Transfer MetaSprite data to the PPU (CGRAM and VRAM)
//
// REQUIRES: force-blank
// Uses DMA channel 0
//
// DB = 0x80
#[mem8, idx16]
func __transfer_ppu_data__forceblank(_res : resources.ResourceEntry in resources.res) {

var _secondRowVramWaddr : u16 in zpTmp_word_0;

    dma.set_dma0_source__res_plus_offset(_res, offsetof(_PpuDataFormat, palette_data));

    snes.ppu.cgram_address = a = 128;
    dma.continue_transfer_to_cgram__forceblank(256);

    mem16();
    #[mem16] {
        // Calculate VRAM address of tile data

        // _PpuDataFormat.first_tile;
        aa = **(&_res.farPtr as *far *u16);

        // +# safe, carry will never be set
        snes.ppu.vram_address_hl = aa = ((aa & 0x1ff) << 4) +# VRAM_OBJ_WADDR;

        // Calculate the start of the second row of small tiles
        _secondRowVramWaddr = aa = aa + 0x10 * SMALL_TILE_DATA_SIZE / 2;


        // Transfer first small row of tiles to VRAM
        // (The first_tile can start in the middle of a VRAM row)

        // Number of tiles in the first row (farPtr = _PpuDataFormat.first_tile)
        aa = (0x1ff - **(&_res.farPtr as *far *u16)) & 0xf;
        aa++;

        // first DMA transfer size
        yy = aa <<<= 5;
    }
    mem8();

    // Transfer the first row of tiles to VRAM
    dma.continue_transfer_to_vram__forceblank(yy);

    // Transfer the remaining tiles to VRAM
    snes.ppu.vram_address_hl = xx = _secondRowVramWaddr;
    dma.transfer_remaining_res_data_to_vram__forceblank(_res);
}



// REQUIRES: VBlank or Force-Blank
// Uses DMA channel 0
//
// DB = 0x80
#[mem8, idx16]
inline func update_oam__vblank() {

    // ::ANNOY snes.ppu.oam_address_hl address is wrong (should be 0x2102)
    *(&snes.ppu.oam_address_l as *u16) = xx = 0;

    snes.dma0.control = a = snes.dma.CONTROL_MODE_A;
    snes.dma0.mdma_dest = a = <:&snes.ppu.oam_write_data;
    snes.dma0.src_address_hl = xx = &buffer as u16;
    snes.dma0.src_address_bank = a = #:far &buffer;
    snes.dma0.mdma_size_hl = xx = sizeof(typeof(buffer)) + sizeof(typeof(hiTableBuffer));

    snes.dma.mdma_enable = a = snes.dma.ENABLE_0;
}



// DB = 0x7e
#[mem8, idx16]
func reset_buffers() {
    xx = (N_OBJECTS - 1) * sizeof(OamEntry);
    bufferPos = xx;
    oldBufferPos = xx;

    a = OFFSCREEN_YPOS;
    do {
        // ::ANNOY cannot do `buffer[unaligned xx].yPos = a;` ::

        (&buffer[0].yPos)[unaligned xx] = a;

        // subtract 4
        xx--; xx--; xx--; xx--;
    } while !negative;


    // ::ANNOY cannot run this loop backwards::
    for xx in 0 .. sizeof(typeof(hiTableBuffer)) - 1 {
        hiTableBuffer[xx] = a = 0xff;
    }

    hiTableQueue = a = HI_TABLE_QUEUE_INIT_VALUE;
    hiTableBufferPos = xx = sizeof(typeof(hiTableBuffer)) - 1;
}



// KEEP: Y
// DB = 0x7e
#[idx16]
inline func _decrement_buffer_index(pos : u16 in xx) : u16 in xx {
    // xx -= sizeof(OamEntry);
    xx--;
    xx--;
    xx--;
    xx--;

    return xx;
}



// Update `hiTableBuffer` and reset the `hiTableQueue`
// KEEP: X and Y
// DB = 0x7e
#[mem8, idx16]
func _hiTableQueue_full() {
    push16(xx);

    xx = hiTableBufferPos;

    hiTableBuffer[xx] = a = hiTableQueue;
    xx--;

    hiTableBufferPos = xx;


    hiTableQueue = a = HI_TABLE_QUEUE_INIT_VALUE;

    xx = pop16();
}



// Reset the buffer
//
// DB = 0x7e
#[mem8, idx16]
func reset_buffer() {
    // NOTE: If I modify this function I must also modify `reset_buffer_and_draw_shadows()`

    hiTableQueue = a = HI_TABLE_QUEUE_INIT_VALUE;
    hiTableBufferPos = xx = sizeof(typeof(hiTableBuffer)) - 1;
    bufferPos = xx = INITIAL_BUFFER_POS;
}



// NOTE: Resets the buffer positions.
// MUST be called before any MetaSprites are drawn.
// DB = 0x7e
#[mem8, idx16]
inline func reset_buffer_and_draw_entity_shadows() {
    // NOTE: If I modify this function, also modify `reset_buffer_and_draw_room_transition_shadows`

    // KEEP: X and Y
    #[mem8, idx16]
    inline func _update_hi_table_size_small() {
        hiTableQueue <<= 1;
    }


    // KEEP: X and Y
    #[mem8, idx16]
    inline func _update_hi_table_x9(x9 : bool in carry) {
        // Invert carry flag
        a = 0;
        a +#= 0xff;
        a >>>= 1;

        hiTableQueue <<<<#= 1;
        if carry {
            _hiTableQueue_full();
        }
    }

    // KEEP: X and Y
    #[mem8, idx16]
    inline func _update_hi_table_x9_0() {
        hiTableQueue <<= 1;
        if carry {
            _hiTableQueue_full();
        }
    }


    // Reset buffer positions
    hiTableQueue = a = HI_TABLE_QUEUE_INIT_VALUE;
    hiTableBufferPos = xx = sizeof(typeof(hiTableBuffer)) - 1;

    // xx = bufferPos
    xx = INITIAL_BUFFER_POS;


    // yy = entity pos
    yy = entities.SoA.LAST_INDEX;
    ^do {
        a = entities.SoA.shadowSize[unaligned yy] as u8;
        if !zero {
            _update_hi_table_size_small();

            if a == ShadowSize.SMALL as u8 {
                // ::ANNOY cannot do `buffer[xx].xPos = a`::
                // ::ANNOY cannot do `u8_array[xx + 4] = a`::

                // yPos
                (&buffer[0].yPos as *u8)[xx] = a = entities.SoA.yPos_px[unaligned yy] - 4;
                // char
                (&buffer[0].char as *u8)[xx] = SHADOW_SMALL_CHAR;
                // attr
                (&buffer[0].attr as *u8)[xx] = a = SHADOW_ATTR;

                // xPos
                (&buffer[0].xPos as *u8)[xx] = a = entities.SoA.xPos_px[unaligned yy] + (-4 as u8);
                _update_hi_table_x9(carry);
            }
            else {
                if a == ShadowSize.MEDIUM as u8 {
                    a = SHADOW_MEDIUM_CHAR;
                }
                else {
                    a = SHADOW_LARGE_CHAR;
                }
                // char
                (&buffer[ 0].char as *u8)[xx] = a;
                (&buffer[-1].char as *u8)[xx] = a;

                // yPos
                a = entities.SoA.yPos_px[unaligned yy] - 4;
                (&buffer[ 0].yPos as *u8)[xx] = a;
                (&buffer[-1].yPos as *u8)[xx] = a;

                // attr
                (&buffer[ 0].attr as *u8)[xx] = a = SHADOW_ATTR | OAM_H_FLIP;
                (&buffer[-1].attr as *u8)[xx] = a = SHADOW_ATTR;

                // xPos
                (&buffer[ 0].xPos as *u8)[xx] = a = entities.SoA.xPos_px[unaligned yy];
                _update_hi_table_x9_0();

                _update_hi_table_size_small();
                // carry clear from shift in _update_hi_table_size_small()
                (&buffer[-1].xPos as *u8)[xx] = a = entities.SoA.xPos_px[unaligned yy] +# (-8 as u8);
                _update_hi_table_x9(carry);


                xx = _decrement_buffer_index(xx);
            }

            xx = _decrement_buffer_index(xx);
        }


        yy--;
        yy--;
    } while !negative;


    bufferPos = xx;
}



// NOTE: Resets the buffer positions.
// MUST be called before any MetaSprites are drawn.
//
// DB = 0x7e
#[mem8, idx16]
inline func reset_buffer_and_draw_room_transition_shadows__inline() {

var _shadowX : u16 in zpTmp_word_0;
var _shadowY : u8 in zpTmp_byte_0;


    // NOTE: If I modify this function, also modify `reset_buffer_and_draw_entity_shadows`

    // KEEP: X and Y
    #[mem8, idx16]
    inline func _update_hi_table_size_small() {
        hiTableQueue <<= 1;
    }


    // KEEP: X and Y
    #[mem8, idx16]
    inline func _update_hi_table_x9(x9 : bool in carry) {
        hiTableQueue <<<<#= 1;
        if carry {
            _hiTableQueue_full();
        }
    }

    // yy = room_transitions.SpriteList index
    idx8();
    #[idx8] {
        y = room_transitions.spriteListEnd;
        y--;
        y--;
    }
    idx16();
    if negative {
        ^return;
    }


    // Reset buffer positions
    hiTableQueue = a = HI_TABLE_QUEUE_INIT_VALUE;
    hiTableBufferPos = xx = sizeof(typeof(hiTableBuffer)) - 1;

    // xx = bufferPos
    xx = INITIAL_BUFFER_POS;


    mem16();
    #[mem16] {
        ^do {
            aa = room_transitions.SpriteList.xPos[unaligned yy] - room_transitions.camera_x;
            ^if aa < DISPLAY_WIDTH + 8 || aa >= (-8 as u16) {
                _shadowX = aa;

                aa = room_transitions.SpriteList.yPos[unaligned yy] - room_transitions.camera_y;
                ^if aa < DISPLAY_HEIGHT + 8 || aa >= (-8 as u16) {
                    mem8();
                    #[mem8, idx16] {
                        _shadowY = a;

                        a = room_transitions.SpriteList.shadowSize[unaligned yy] as u8;
                        ^if !zero {
                            _update_hi_table_size_small();

                            if a == ShadowSize.SMALL as u8 {
                                // ::ANNOY cannot do `buffer[xx].xPos = a`::
                                // ::ANNOY cannot do `u8_array[xx + 4] = a`::

                                // yPos
                                (&buffer[0].yPos as *u8)[xx] = a = _shadowY - 4;
                                // char
                                (&buffer[0].char as *u8)[xx] = SHADOW_SMALL_CHAR;
                                // attr
                                (&buffer[0].attr as *u8)[xx] = a = SHADOW_ATTR;

                                // xPos
                                (&buffer[0].xPos as *u8)[xx] = a = <:_shadowX + (-4 as u8);
                                a = >:_shadowX +# >:(-4 as u16);
                                cmp(a, 1);
                                _update_hi_table_x9(carry);
                            }
                            else {
                                if a == ShadowSize.MEDIUM as u8 {
                                    a = SHADOW_MEDIUM_CHAR;
                                }
                                else {
                                    a = SHADOW_LARGE_CHAR;
                                }
                                // char
                                (&buffer[ 0].char as *u8)[xx] = a;
                                (&buffer[-1].char as *u8)[xx] = a;

                                // yPos
                                a = _shadowY - 4;
                                (&buffer[ 0].yPos as *u8)[xx] = a;
                                (&buffer[-1].yPos as *u8)[xx] = a;

                                // attr
                                (&buffer[ 0].attr as *u8)[xx] = a = SHADOW_ATTR | OAM_H_FLIP;
                                (&buffer[-1].attr as *u8)[xx] = a = SHADOW_ATTR;

                                // xPos
                                (&buffer[ 0].xPos as *u8)[xx] = a = <:_shadowX;
                                a = >:_shadowX >>> 1;
                                _update_hi_table_x9(carry);

                                _update_hi_table_size_small();
                                // carry clear from shift in _update_hi_table_size_small()
                                (&buffer[-1].xPos as *u8)[xx] = a = <:_shadowX +# (-8 as u8);
                                a = >:_shadowX +# >:(-8 as u16);
                                cmp(a, 1);
                                _update_hi_table_x9(carry);


                                xx = _decrement_buffer_index(xx);
                            }

                            xx = _decrement_buffer_index(xx);
                        }
                    }
                    mem16();
                }
            }

            yy--;
            yy--;
        } while !negative;
    }
    mem8();


    bufferPos = xx;
}



// Finalise the buffer and hide the unused sprites.
//
// DB = 0x7e
#[mem8, idx16]
func finalize_buffer() {
    xx = bufferPos;
    if negative {
        // Required to prevent an underflow in `cmp(xx, oldBufferPos)` below
        xx = 0;
    }
    else {
        // buffer is not empty.
        // Hide sprites that were on-screen on the previous frame.
        //

        // Fix a bug where sprite 0 remains on-screen if the buffer was full on the previous frame.
        a = OFFSCREEN_YPOS;
        buffer[0].yPos = a;

        // ::ANNOY greater-than comparison `>` operator is not allowed in conditional::
        // ::: `if xx > oldBufferPos {` ::
        if { cmp(xx, oldBufferPos); } && carry && !zero {
            // The previous frame had more sprites on-screen the this frame.
            // Move them off-screen.
            do {
                (&buffer[0].yPos)[unaligned xx] = a;

                // subtract 4
                xx = _decrement_buffer_index(xx);
            } while xx != oldBufferPos;

            xx = bufferPos;
        }
    }
    oldBufferPos = xx;


    a = hiTableQueue;
    if a != HI_TABLE_QUEUE_INIT_VALUE {
        // hiTableQueue is not empty.

        // fill buffer
        do {
            a <<= 2;
        } while !carry;

        xx = hiTableBufferPos;
        hiTableBuffer[xx] = a;
    }
}


// Entity Functions
// ================


// Draw the entity's MetaSprite frame.
//
// Also updates `entities.SoA.previousXpos` and `entities.SoA.previousYpos`.
//
// DB = 0x7e
#[mem8, idx8]
inline func _draw_entity__inline(entityId : u8 in y) {

    // Calculate MetaSprite position

    a = entities.SoA.xPos_px[unaligned y];
    entities.SoA.previousXpos[unaligned y] = a;
    <:xPos = a;
    >:xPos = 0;

    a = entities.SoA.yPos_px[unaligned y];
    entities.SoA.previousYpos[unaligned y] = a;
    <:yPos = a = a - entities.SoA.zPos[unaligned y];
    a = 0;
    >:yPos = a = a -# 0;


    idx16();
    #[mem8, idx16] {
        xx = yy;
        yy = entities.SoA.msFrameAddr[unaligned xx];
        entities.SoA.ms_draw_function[unaligned xx](yy, xPos, yPos);
    }
    mem8_idx8();
}



// MetaSprite Animations
// ---------------------



// Initialise the MetaSprite Animation for the player entity.
//
// NOTE: This function does not set the animationId
//
// DB = 0x7e
#[mem8, idx8]
inline func init_player_metasprite_animation__inline() {
    entities.SoA.msAnimationProcessFunctionIndex[0] = a = animations.NEW_ANIMATION__FUNCTION_ID;
}



// Initialise the MetaSprite Animation for an entity.
//
// This function MUST be called before the entity's `init` function.
//
// NOTE: This function will not populate all of the animation fields,
//       `init_entity_metasprite_animation__after_init` must be called after entity `init` routine
//
// KEEP: Y
//
// DB = 0x7e
#[mem16, idx8]
inline func init_entity_metasprite_animation__inline(entityId : u8 in y) {

    (&entities.SoA._msAnimationIdAndPfIndex as *u16)[unaligned y] = aa = (animations.NEW_ANIMATION__FUNCTION_ID << 8);
}



// Finish initialising an entity's MetaSprite Animation.
//
// This function MUST be called AFTER the entity's `init` function.
//
// KEEP: Y
//
// DB = 0x7e
#[mem16, idx8]
let init_entity_metasprite_animation__after_init = metasprites.animations._new_animation;



// Set the entity's MetaSprite animation.
//
// NOTE: This function will always restart the animation.
// NOTE: This function will not immediately change the MetaSprite animation state.
//
// KEEP: X and Y
//
// DB = 0x7e
#[mem8, idx8]
#[fallthrough]
func set_entity_animation_x(entityId : u8 in y, animationId : u8 in x) {
    a = x;
// fallthrough
}

// Set the entity's MetaSprite animation.
//
// NOTE: This function will always restart the animation.
// NOTE: This function will not immediately change the MetaSprite animation state.
//
// KEEP: X and Y
//
// DB = 0x7e
#[mem8, idx8]
func set_entity_animation(entityId : u8 in y, animationId : u8 in a) {
    entities.SoA.msAnimationId[unaligned y] = a;
    entities.SoA.msAnimationProcessFunctionIndex[unaligned y] = a = animations.NEW_ANIMATION__FUNCTION_ID;
}


// Set the entity's MetaSprite animation if entity's `msAnimationId` is not `animationId`.
//
// If the entity's `msAnimationId` is equal to `animationId` then the animation is unchanged.
//
// NOTE: This function will not immediately change the MetaSprite animation state.
//
// KEEP: X and Y
//
// DB = 0x7e
#[mem8, idx8]
func set_entity_animation_if_changed(entityId : u8 in y, animationId : u8 in a) {
    if a != entities.SoA.msAnimationId[y] {
        entities.SoA.msAnimationId[unaligned y] = a;
        entities.SoA.msAnimationProcessFunctionIndex[unaligned y] = a = metasprites.animations.NEW_ANIMATION__FUNCTION_ID;
    }
}



// Set the player's MetaSprite animation.
//
// NOTE: This function will always restart the animation.
// NOTE: This function will not immediately change the MetaSprite animation state.
//
// KEEP: X and Y
//
// DB = 0x7e
#[mem8, idx8]
func set_player_animation(animationId : u8 in a) {
    entities.SoA.msAnimationId[PLAYER_ENTITY_ID] = a;
    entities.SoA.msAnimationProcessFunctionIndex[PLAYER_ENTITY_ID] = a = metasprites.animations.NEW_ANIMATION__FUNCTION_ID;
}



// Set the player's MetaSprite animation if the player's `msAnimationId` is not `animationId`.
//
// If the player's `msAnimationId` is equal to `animationId` then the animation is unchanged.
//
// NOTE: This function will not immediately change the MetaSprite animation state.
//
// KEEP: X and Y
//
// DB = 0x7e
#[mem8, idx8]
func set_player_animation_if_changed(animationId : u8 in a) {
    if a != entities.SoA.msAnimationId[PLAYER_ENTITY_ID] {
        entities.SoA.msAnimationId[PLAYER_ENTITY_ID] = a;
        entities.SoA.msAnimationProcessFunctionIndex[PLAYER_ENTITY_ID] = a = metasprites.animations.NEW_ANIMATION__FUNCTION_ID;
    }
}



// Stop the entity's MetaSprite animation.
//
// KEEP: Y
//
// DB = 0x7e
#[mem8, idx8]
inline func stop_entity_animation(entityId : u8 in y) {
    x = y;
    entities.SoA.msAnimationProcessFunctionIndex[unaligned x] = animations.DISABLED_FUNCTION_ID;
}



// Tests if the entity is running a non-looping animation.
//
// Returns `true` if the animation is running and it is a non-looping animation.
// Returns `true` if the animation process-function is NEW_ANIMATION__FUNCTION_ID.
// Returns `false` if a non-looping animation is completed or `stop_entity_animation()` has been called.
// Returns `false` for looping animations to prevent an infinite-loop if this function to used break a loop.
//
// KEEP: Y
// KEEP: X
//
// DB = 0x7e
#[mem8, idx8]
inline func is_entity_non_looping_animation_running(entityId : u8 in y) : bool in carry {
    // Assumes the non-looping animations and NEW_ANIMATION__FUNCTION_ID are at the end of `AnimationProcessFunctions`

    a = entities.SoA.msAnimationProcessFunctionIndex[unaligned y];
    cmp(a, metasprites.animations.FIRST_NON_LOOPING_FUNCTION_ID);
    return carry;
}



// Tests if the player is running a non-looping animation.
//
// Returns `true` if the animation is running and it is a non-looping animation.
// Returns `true` if the animation process-function is NEW_ANIMATION__FUNCTION_ID.
// Returns `false` if a non-looping animation is completed or `stop_entity_animation()` has been called.
// Returns `false` for looping animations to prevent an infinite-loop if this function to used break a loop.
//
// KEEP: Y
// KEEP: X
//
// DB = 0x7e
#[mem8, idx8]
inline func is_player_non_looping_animation_running() : bool in carry {
    // Assumes the non-looping animations and NEW_ANIMATION__FUNCTION_ID are at the end of `AnimationProcessFunctions`

    a = entities.SoA.msAnimationProcessFunctionIndex[PLAYER_ENTITY_ID];
    cmp(a, metasprites.animations.FIRST_NON_LOOPING_FUNCTION_ID);
    return carry;
}



// Process the entity's MetaSprite animation.
//
// This function MUST be called after the entity's process routine.
//
// KEEP: Y
//
// DB = 0x7e
#[mem8, idx8]
inline func process_entity_animation(entityId : u8 in y) {
    x = entities.SoA.msAnimationProcessFunctionIndex[unaligned y];

    animations.AnimationProcessFunctions[unaligned x](y);
}


namespace animations {


// Order MUST match `LOOPING_ANIMATION_DELAY_IDS` and `NON_LOOPING_ANIMATION_DELAY_IDS` in `tools/convert-metasprite.py`
const AnimationProcessFunctions = [
    disabled,

    // Looping process functions
    frame_count__looping,
    distance_x__looping,
    distance_y__looping,
    distance_xy__looping,

    // Unused delay types
    disabled,
    disabled,
    disabled,
    disabled,
    disabled,
    disabled,
    disabled,

    // Non looping process functions. Should be last
    frame_count__once,
    distance_x__once,
    distance_y__once,
    distance_xy__once,

    // A special animation process function to setup the animation in memory.
    // This must be the 17th function in this table
    _new_animation,
];

let DELAY_TYPE_MASK = 0b00011110;

let FRAME_COUNT__LOOPING__FUNCTION_ID = 1 * 2;
let FRAME_COUNT__ONCE__FUNCTION_ID = 12 * 2;

let FIRST_NON_LOOPING_FUNCTION_ID = 12 * 2;

let DISABLED_FUNCTION_ID = 0;
let NEW_ANIMATION__FUNCTION_ID = DELAY_TYPE_MASK + 2;

let entities_SoA_msAnimationCounter_u8 = &<:entities.SoA.msAnimationCounter[0] as *u8;



// Animation Process Routine: Start a new animation.
//
// This function is called after entity `init` or after the animation
// has been changed by a previous `set_player_animation` call.
//
//
// KEEP: Y
//
// DB = 0x7e
#[mem8, idx8]
func _new_animation(entityId : u8 in y) {
    // Assumes all animation state (except `msAnimationId`, `msAnimationTable` and `metaSpriteFrameTable`) is invalid.
    // This function is part of an entity's init routine.

    mem16_idx16();
    #[mem16, idx16] {
        aa = (&entities.SoA.msAnimationId as *u16)[unaligned yy];
        xx = aa = ((aa & 0xff) << 1) + entities.SoA.msAnimationTable[unaligned yy];
        aa = MetaSpriteAnimationTableOffset[unaligned xx];

        entities.SoA.msAnimationAddr[unaligned yy] = aa;
        entities.SoA.msAnimationPos[unaligned yy] = aa;
        xx = aa;

        // Calculate metasprite frame address
        aa = (AnimationDataFormat.frame as far *u16)[unaligned xx];
        xx = aa = ((aa & 0xff) << 1) +# entities.SoA.metaSpriteFrameTable[unaligned yy];
        entities.SoA.msFrameAddr[unaligned yy] = aa = MetaSpriteFrameTableOffset[unaligned xx];

        mem8();
        #[mem8] {
            xx = entities.SoA.msAnimationAddr[unaligned yy];

            entities.SoA.msAnimationProcessFunctionIndex[unaligned yy] = a = AnimationDataFormat.processFunction[xx] & DELAY_TYPE_MASK;

            if a == FRAME_COUNT__LOOPING__FUNCTION_ID || a == FRAME_COUNT__ONCE__FUNCTION_ID {
                entities_SoA_msAnimationCounter_u8[unaligned yy] = a = AnimationDataFormat.delay[xx];
            }
            else {
                mem16();
                #[mem16] {
                    aa = (AnimationDataFormat.delay as far *u16)[unaligned xx];
                    entities.SoA.msAnimationCounter[unaligned yy] = aa = (aa & 0xff) <<< AnimationDataFormat.DISTANCE_DELAY_SHIFT;
                }
            }
            // A size is unknown
        }
    }
    mem8_idx8();
}



// Animation Process Routine:  Does nothing.
//
// KEEP: Y
//
// DB = 0x7e
#[mem8, idx8]
func disabled(entityId : u8 in y) {
}



// Looping Animation Process Routine:  Delay byte measures display frames.
//
// KEEP: Y
//
// DB = 0x7e
#[mem8, idx8]
func frame_count__looping(entityId : u8 in y) {

    a = entities_SoA_msAnimationCounter_u8[unaligned y];
    if zero {
        // NOTE: If you modify this code, you MUST ALSO modify `frame_count__once()`
        // NOTE: If you modify this code, you MUST ALSO modify `__distance_animation__looping__return_mem8_idx8()`

        // Advance to the next MetaSprite frame
        idx16();
        #[idx16] {
            xx = entities.SoA.msAnimationPos[unaligned yy];
            xx++;
            xx++;

            a = AnimationDataFormat.frame[xx];
            if a == AnimationDataFormat.END_OF_ANIMATION_BYTE {
                // Restart MetaSprite animation
                xx = entities.SoA.msAnimationAddr[unaligned yy];
            }

            mem16();
            #[mem16] {
                entities.SoA.msAnimationPos[unaligned yy] = aa = xx;

                // Delay must be processed first as calculating `msFrameAddr` clobbers xx.
                // (wasting 2 cycles on the 16 bit load-store is faster then reloading `msAnimationPos` back into xx later)
                aa = (AnimationDataFormat.delay as far *u16)[unaligned xx];
                entities.SoA.msAnimationCounter[unaligned yy] = aa;

                aa = (AnimationDataFormat.frame as far *u16)[unaligned xx];
                xx = aa = ((aa & 0xff) << 1) +# entities.SoA.metaSpriteFrameTable[unaligned yy];
                entities.SoA.msFrameAddr[unaligned yy] = aa = MetaSpriteFrameTableOffset[unaligned xx];
            }
        }
        mem8_idx8();
        return;
    }
    else {
        // msAnimationCounter is non-zero
        a--;
        entities_SoA_msAnimationCounter_u8[unaligned y] = a;
    }
}



// Looping Animation Process Routine:  Delay byte measures distance in the X-Axis.
//
// KEEP: Y
//
// DB = 0x7e
#[mem8, idx8]
func distance_x__looping(entityId : u8 in y) {
    mem16();
    #[mem16] {
        aa = entities.SoA.xVelocity[unaligned y];
        if !zero {
            if !negative {
                aa = negate16(aa);
            }

            return __distance_animation__looping__return_mem8_idx8(aa as i16, y);
        }
    }
    mem8_idx8();
}



// Looping Animation Process Routine:  Delay byte measures distance in the Y-Axis.
//
// KEEP: Y
//
// DB = 0x7e
#[mem8, idx8]
func distance_y__looping(entityId : u8 in y) {
    mem16();
    #[mem16] {
        aa = entities.SoA.yVelocity[unaligned y];
        if !zero {
            if !negative {
                aa = negate16(aa);
            }

            return __distance_animation__looping__return_mem8_idx8(aa as i16, y);
        }
    }
    mem8_idx8();
}



// Looping Animation Process Routine:  Delay byte measures distance in the both X and Y Axises.
//
// KEEP: Y
//
// DB = 0x7e
#[mem8, idx8]
func distance_xy__looping(entityId : u8 in y) {
var _tmp : u16 in zpTmp_word_0;

    mem16();
    #[mem16] {
        aa = entities.SoA.xVelocity[unaligned y];
        if !negative {
            aa = negate16(aa);
        }
        _tmp = aa;

        aa = entities.SoA.yVelocity[unaligned y];
        if !negative {
            aa = negate16(aa);
        }
        aa += _tmp;

        return __distance_animation__looping__return_mem8_idx8(aa as i16, y) if !zero;
    }
    mem8_idx8();
}



// Process a looping MetaSprite animation with a distance delay variable.
//
// ASSUMES: negativeVelocity is negative and non-zero.
//
// KEEP: Y
//
// RETURNS with mem8, idx8
//
// DB = 0x7e
#[mem16, idx8]
func __distance_animation__looping__return_mem8_idx8(negativeVelocity : i16 in aa, entityId : u8 in y) {
    aa += entities.SoA.msAnimationCounter[unaligned y];
    if !carry {
        // NOTE: If you modify this code, you MUST ALSO modify `__distance_animation__once__return_mem8_idx8()`
        // NOTE: If you modify this code, you MUST ALSO modify `frame_count__looping()`

        // Advance to the next MetaSprite frame
        idx16();
        #[idx16] {
            xx = entities.SoA.msAnimationPos[unaligned yy];
            xx++;
            xx++;

            mem8();
            #[mem8] {
                a = AnimationDataFormat.frame[unaligned xx];
                if a == AnimationDataFormat.END_OF_ANIMATION_BYTE {
                    // Restart MetaSprite animation
                    xx = entities.SoA.msAnimationAddr[unaligned yy];
                }
            }

            mem16();
            #[mem16] {
                entities.SoA.msAnimationPos[unaligned yy] = aa = xx;

                // Delay must be processed first as calculating `msFrameAddr` clobbers xx.
                aa = (AnimationDataFormat.delay as far *u16)[unaligned xx];
                aa = (aa & 0xff) <<< AnimationDataFormat.DISTANCE_DELAY_SHIFT;
                entities.SoA.msAnimationCounter[unaligned yy] = aa;

                aa = (AnimationDataFormat.frame as far *u16)[unaligned xx];
                xx = aa = ((aa & 0xff) << 1) +# entities.SoA.metaSpriteFrameTable[unaligned yy];
                entities.SoA.msFrameAddr[unaligned yy] = aa = MetaSpriteFrameTableOffset[unaligned xx];
            }
        }
        mem8_idx8();
        return;
    }
    else {
        // msAnimationCounter did not underflow

        entities.SoA.msAnimationCounter[unaligned y] = aa;

        mem8_idx8();
        return;
    }
}



// Non-Looping Animation Process Routine:  Delay byte measures display frames.
//
// KEEP: Y
//
// DB = 0x7e
#[mem8, idx8]
func frame_count__once(entityId : u8 in y) {

    a = entities_SoA_msAnimationCounter_u8[unaligned y];
    if zero {
        // NOTE: If you modify this code, you MUST ALSO modify `frame_count__looping()`
        // NOTE: If you modify this code, you MUST ALSO modify `__distance_animation__once__return_mem8_idx8()`

        // Advance to the next MetaSprite frame
        idx16();
        #[idx16] {
            xx = entities.SoA.msAnimationPos[unaligned yy];
            xx++;
            xx++;

            a = AnimationDataFormat.frame[xx];
            goto __end_of_animation__idx16 if a == AnimationDataFormat.END_OF_ANIMATION_BYTE;

            mem16();
            #[mem16] {
                entities.SoA.msAnimationPos[unaligned yy] = aa = xx;

                // Delay must be processed first as calculating `msFrameAddr` clobbers xx.
                // (wasting 2 cycles on the 16 bit load-store is faster then reloading `msAnimationPos` back into xx later)
                aa = (AnimationDataFormat.delay as far *u16)[unaligned xx];
                entities.SoA.msAnimationCounter[unaligned yy] = aa;

                aa = (AnimationDataFormat.frame as far *u16)[unaligned xx];
                xx = aa = ((aa & 0xff) << 1) +# entities.SoA.metaSpriteFrameTable[unaligned yy];
                entities.SoA.msFrameAddr[unaligned yy] = aa = MetaSpriteFrameTableOffset[unaligned xx];
            }
        }
        mem8_idx8();
        return;
    }
    else {
        // msAnimationCounter is non-zero
        a--;
        entities_SoA_msAnimationCounter_u8[unaligned y] = a;
    }
}



// A non-looping animation has ended.  Change animation process function to `disabled`.
//
// KEEP: Y
//
// RETURNS with mem8, idx8
//
// DB = 0x7e
#[mem8, idx8]
func __end_of_animation__idx16() {
    // This function is called with a idx16, and it needs to return mem8, idx8
    mem8_idx8();

    x = y;
    entities.SoA.msAnimationProcessFunctionIndex[unaligned x] = DISABLED_FUNCTION_ID;
}



// Non-Looping Animation Process Routine:  Delay byte measures distance in the X-Axis.
//
// KEEP: Y
//
// DB = 0x7e
#[mem8, idx8]
func distance_x__once(entityId : u8 in y) {
    mem16();
    #[mem16] {
        aa = entities.SoA.xVelocity[unaligned y];
        if !zero {
            if !negative {
                aa = negate16(aa);
            }

            return __distance_animation__once__return_mem8_idx8(aa as i16, y);
        }
    }
    mem8_idx8();
}



// Non-Looping Animation Process Routine:  Delay byte measures distance in the Y-Axis.
//
// KEEP: Y
//
// DB = 0x7e
#[mem8, idx8]
func distance_y__once(entityId : u8 in y) {
    mem16();
    #[mem16] {
        aa = entities.SoA.yVelocity[unaligned y];
        if !zero {
            if !negative {
                aa = negate16(aa);
            }

            return __distance_animation__once__return_mem8_idx8(aa as i16, y);
        }
    }
    mem8_idx8();
}



// Non-Looping Animation Process Routine:  Delay byte measures distance in the both X and Y Axises.
//
// KEEP: Y
//
// DB = 0x7e
#[mem8, idx8]
func distance_xy__once(entityId : u8 in y) {
var _tmp : u16 in zpTmp_word_0;

    mem16();
    #[mem16] {
        aa = entities.SoA.xVelocity[unaligned y];
        if !negative {
            aa = negate16(aa);
        }
        _tmp = aa;

        aa = entities.SoA.yVelocity[unaligned y];
        if !negative {
            aa = negate16(aa);
        }
        aa += _tmp;

        return __distance_animation__once__return_mem8_idx8(aa as i16, y) if !zero;
    }
    mem8_idx8();
}



// Process a non-looping MetaSprite animation with a distance delay variable.
//
// ASSUMES: negativeVelocity is negative and non-zero.
//
// KEEP: Y
//
// RETURNS with mem8, idx8
//
// DB = 0x7e
#[mem16, idx8]
func __distance_animation__once__return_mem8_idx8(negativeVelocity : i16 in aa, entityId : u8 in y) {
    aa += entities.SoA.msAnimationCounter[unaligned y];
    if !carry {
        // NOTE: If you modify this code, you MUST ALSO modify `__distance_animation__looping__return_mem8_idx8()`
        // NOTE: If you modify this code, you MUST ALSO modify `frame_count__once()`

        // Advance to the next MetaSprite frame
        idx16();
        #[idx16] {
            xx = entities.SoA.msAnimationPos[unaligned yy];
            xx++;
            xx++;

            mem8();
            #[mem8] {
                a = AnimationDataFormat.frame[unaligned xx];
                goto __end_of_animation__idx16 if a == AnimationDataFormat.END_OF_ANIMATION_BYTE;
            }

            mem16();
            #[mem16] {
                entities.SoA.msAnimationPos[unaligned yy] = aa = xx;

                // Delay must be processed first as calculating `msFrameAddr` clobbers xx.
                aa = (AnimationDataFormat.delay as far *u16)[unaligned xx];
                aa = (aa & 0xff) <<< AnimationDataFormat.DISTANCE_DELAY_SHIFT;
                entities.SoA.msAnimationCounter[unaligned yy] = aa;

                aa = (AnimationDataFormat.frame as far *u16)[unaligned xx];
                xx = aa = ((aa & 0xff) << 1) +# entities.SoA.metaSpriteFrameTable[unaligned yy];
                entities.SoA.msFrameAddr[unaligned yy] = aa = MetaSpriteFrameTableOffset[unaligned xx];
            }
        }
        mem8_idx8();
        return;
    }
    else {
        // msAnimationCounter did not underflow

        entities.SoA.msAnimationCounter[unaligned y] = aa;

        mem8_idx8();
        return;
    }
}


}



// MetaSprite Patterns
// ===================

namespace drawing_functions {

// ::TODO do a thorough test of the drawing functions and confirm partially off-screen sprites works correctly::


// Subtract the MsDataFormat offset from the MetaSprite position.
//
// KEEP: X and Y
// DB = 0x7e
#[mem8, idx16]
inline func _subtract_ms_offset_from_position(msFrame : u16 in xx, xPos : u16 in metasprites.xPos, yPos : u16 in metasprites.yPos) {

    <:xPos = a = <:xPos - MsDataFormat.xOffset[unaligned xx];
    if !carry {
        (>:xPos)--;
    }

    <:yPos = a = <:yPos - MsDataFormat.yOffset[unaligned xx];
    if !carry {
        (>:yPos)--;
    }
}



// KEEP: X and Y
// DB = 0x7e
#[mem8, idx16]
inline func _update_hi_table_size_small() {
    hiTableQueue <<= 1;
}



// KEEP: X and Y
// DB = 0x7e
#[mem8, idx16]
inline func _update_hi_table_size_large() {
    carry = true;
    hiTableQueue <<<<#= 1;
}



// KEEP: X and Y
// DB = 0x7e
#[mem8, idx16]
inline func _update_hi_table_x8(x8 : bool in carry) {
    hiTableQueue <<<<#= 1;
    if carry {
        _hiTableQueue_full();
    }
}

// KEEP: X and Y
#[mem8, idx16]
inline func _update_hi_table_x8_invert(x8 : bool in carry) {
    // Invert carry flag
    a = 0;
    a +#= 0xff;
    a >>>= 1;

    _update_hi_table_x8(carry);
}



// KEEP: X and Y
// DB = 0x7e
#[mem8, idx16]
inline func _update_hi_table_x8_xPos() {
    a = >:xPos >>> 1;
    _update_hi_table_x8(carry);
}



// KEEP: X and Y
// DB = 0x7e
#[mem8, idx16]
inline func _update_hi_table_x8_0() {
    hiTableQueue <<= 1;
    if carry {
        _hiTableQueue_full();
    }
}



// Read the `MsDataFormat.pattern` byte execute the pattern's draw function.
//
// DB = 0x7e, DP = 0
#[mem8, idx16]
func dynamic_pattern(msFrame : u16 in yy, xPos : u16 in xPos, yPos : u16 in yPos) {
    xx = yy;

    // Clear the high byte of aa
    #[mem16] {
        aa = direct_page;
    }

    a = MsDataFormat.pattern[unaligned xx];
    a &= MS_PATTERNS_TABLE_MASK;

    #[mem16] {
        xx = aa;
    }

    return ms_patterns_table[unaligned xx](yy, xPos, yPos);
}



// Blank drawing function - does nothing.
//
#[mem8, idx16]
func null_function(msFrame : u16 in yy, xPos : u16 in xPos, yPos : u16 in yPos) {
}



// Four sprites, 32x32 square (all large)
//
// ┌─┬─┐
// │1│2│
// ├─┼─┤
// │3│4│
// └─┴─┘
//
// This pattern is not auto-generated, it is provided as an example.
//
// DB = 0x7e
#[mem8, idx16]
func square_four_32(msFrame : u16 in yy, xPos : u16 in xPos, yPos : u16 in yPos) {
    xx = yy;

    _subtract_ms_offset_from_position(xx, xPos, yPos);

    yy = bufferPos;
    return if negative || yy < (4 - 1) * sizeof(OamEntry);


    a = <:xPos;
    (&buffer[ 0].xPos)[unaligned yy] = a;
    (&buffer[-2].xPos)[unaligned yy] = a;

    _update_hi_table_size_large();
    _update_hi_table_x8_xPos();

    _update_hi_table_size_large();

    (&buffer[-1].xPos)[unaligned yy] = a = <:xPos + 16;
    a = (>:xPos +# 0) >>> 1;
    _update_hi_table_x8(carry);

    _update_hi_table_size_large();
    _update_hi_table_x8_xPos();

    _update_hi_table_size_large();

    (&buffer[-3].xPos)[unaligned yy] = a = <:xPos + 16;
    a = (>:xPos +# 0) >>> 1;
    _update_hi_table_x8(carry);


    mem16();
    #[mem16] {
        aa = yPos;
        if aa >= DISPLAY_HEIGHT && aa < -16 as u16 {
            aa = -16 as u16;
        }
        (&buffer[ 0].yPos as *u16)[unaligned yy] = aa;
        (&buffer[-1].yPos as *u16)[unaligned yy] = aa;

        aa = yPos + 16;
        if aa >= DISPLAY_HEIGHT && aa < -16 as u16 {
            aa = -16 as u16;
        }
        (&buffer[-2].yPos as *u16)[unaligned yy] = aa;
        (&buffer[-3].yPos as *u16)[unaligned yy] = aa;


        (&buffer[ 0].char as *u16)[unaligned yy] = aa = MsDataFormat.charAttr0[unaligned xx];
        (&buffer[-1].char as *u16)[unaligned yy] = aa = MsDataFormat.charAttr1[unaligned xx];
        (&buffer[-2].char as *u16)[unaligned yy] = aa = MsDataFormat.charAttr2[unaligned xx];
        (&buffer[-3].char as *u16)[unaligned yy] = aa = MsDataFormat.charAttr3[unaligned xx];

        bufferPos = aa = yy - 4 * sizeof(OamEntry);
    }
    mem8();
}

}

}
}



// Moving this here prevents an
// "encountered a reference to `var metasprites.xPos` before its type was known" error.
import "entities/_variables";
import "room-transitions";

import "../gen/ms-drawing-functions";

