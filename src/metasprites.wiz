// Copyright (c) 2021, Marcus Rowe <undisbeliever@gmail.com>.
// Distributed under The MIT License, see the LICENSE file for more details.

import "memmap";
import "resources";
import "common/dma";
import "../wiz/common/snes/snes";


namespace metasprites {

let N_OBJECTS = 128;

let DISPLAY_HEIGHT = 224;


// MetaSprite Frame Table Data offset in ROM
// (word addr table)
let MetaSpriteFrameTableOffset = 0xc10000 as far *u16;


// MetaSprite Data in ROM
namespace MsDataFormat {
    let xOffset = 0xc10000 as far *u8;
    let yOffset = 0xc10001 as far *u8;

    // NOTE: Not all `charAttr*` fields will be filled.
    // Most MetaSprite patterns use less then 4 charAttr words.
    let charAttr0 = 0xc10002 as far *u16;
    let charAttr1 = 0xc10004 as far *u16;
    let charAttr2 = 0xc10006 as far *u16;
    let charAttr3 = 0xc10008 as far *u16;
}

// MetaSprie PPU data format in ROM.
struct _PpuDataFormat {
    tile_data_size : u16,

    palette_data : [u16 ; 128],

    tile_data : u8,
}



struct OamEntry {
    xPos : u8,
    yPos : u8,
    char : u8,
    attr : u8
};

let OAM_V_FLIP = 0x80;
let OAM_H_FLIP = 0x40;

let SHADOW_ATTR = 0x20;



let OFFSCREEN_YPOS = 255 - 16;

let SHADOW_SMALL_CHAR  = 0;
let SHADOW_MEDIUM_CHAR = 1;
let SHADOW_LARGE_CHAR  = 2;


in zeropage {
    // The current index within `buffer`.
    //
    // `buffer` is read back to front.
    //
    // This value if negative if the buffer is full.
    var bufferPos : u16;

    // Queue of pending bits to write to `hiTableBuffer`.
    //
    // Bits are pushed leftwise into the queue using `lsr` or `rol`
    // instructions.
    //
    // An empty queue has the value of `HI_TABLE_QUEUE_INIT_VALUE` (`1`).  This
    // This allows for the queue-full state to be checked by reading the carry
    // flag after every second bit-shift.  When the carry flag is set, the
    // queue is full, and `_hiTableQueue_full()` must be called.
    //
    var hiTableQueue : u8;

    let HI_TABLE_QUEUE_INIT_VALUE = 1;

    let INITIAL_BUFFER_POS = (N_OBJECTS - 1) * sizeof(OamEntry);


    // Temporary variables to store the metasprite's position on screen
    var xPos : u16;
    var yPos : u16;
}


in wram7e {
    var buffer : [OamEntry ; N_OBJECTS];
    var hiTableBuffer : [u8 ; N_OBJECTS / 4];

    var hiTableBufferPos : u16;

    var oldBufferPos : u16;
}


in code {


// REQUIRES: Force-Blank
// DB = 0x80
#[mem8, idx16]
inline func setup__fblank() {
    {
        push8(data_bank);

        push8(a = 0x7e);
        data_bank = pop8();
    // DB = 0x7e

        reset_buffers();

        data_bank = pop8();
    }

    update_oam__vblank();
}



// REQUIRES: Force-Blank
// DB = 0x80
#[mem8, idx16]
inline func load_ppu_data__fblank(spritesheet_id : u8 in a) {
let _ptr = dpTmp_farPtr;

    snes.dma.hdma_enable = 0;

    snes.ppu.obj_control = a = (VRAM_OBJ_WADDR / 8192) | (snes.ppu.OBJ_CONTROL_8x8_16x16 << 4);


    idx8();
    #[idx8] {
        x = a;
        if x >= sizeof(typeof(*resources.metasprites.spritesheet_list_l)) {
            x = 0;
        }

        <:_ptr = a = resources.metasprites.spritesheet_list_l[x];
        >:_ptr = a = resources.metasprites.spritesheet_list_h[x];
        #:_ptr = a = resources.metasprites.spritesheet_list_b[x];
    }
    idx16();


    // A = _ptr bank
    xx = *(&_ptr as *u16);

    // Skip _PpuDataFormat.tile_data_size in DMA's below
    xx++;
    xx++;

    snes.dma0.src_address_bank = a;
    snes.dma0.src_address_hl = xx;


    // Transfer Palette data to CGRAM
    snes.ppu.cgram_address = a = 128;

    snes.dma0.control = a = snes.dma.CONTROL_MODE_A;
    snes.dma0.mdma_dest = a = <:&snes.ppu.cgram_write_data;
    snes.dma0.mdma_size_hl = yy = 128 * 2;

    snes.dma.mdma_enable = a = snes.dma.ENABLE_0;


    // Calculate location to store Sprite tiles
    // (Tiles are stored at the end of the OBJ tile block)
    mem16();
    #[mem16] {
        snes.ppu.vram_address_hl = aa = (((VRAM_OBJ_WADDR * 2 + 512 * 32) & 0xffff) - **(&_ptr as *far *u16)) >>> 1;
        snes.dma0.mdma_size_hl = aa = **(&_ptr as *far *u16);
    }
    mem8();

    snes.dma0.control = a = snes.dma.CONTROL_MODE_AB;
    snes.dma0.mdma_dest = a = <:&snes.ppu.vram_write_data_l;

    snes.dma.mdma_enable = a = snes.dma.ENABLE_0;


    // Transfer common sprite tiles to VRAM
    {
        let tile_data = (far &resources.ms_ppu_data.common as u24 + sizeof(_PpuDataFormat) - 1) as far *u8;
        let tile_data_size = sizeof(typeof(resources.ms_ppu_data.common)) - sizeof(_PpuDataFormat) + 1;

        snes.ppu.vram_address_hl = xx = VRAM_OBJ_WADDR;
        dma.transfer_to_vram__forceblank(#:tile_data, tile_data as u16, tile_data_size);
    }
}



// DB = 0x80
// REQUIRES: VBlank or Force-Blank
// Uses DMA channel 0
#[mem8, idx16]
inline func update_oam__vblank() {

    // ::ANNOY snes.ppu.oam_address_hl address is wrong (should be 0x2102)
    *(&snes.ppu.oam_address_l as *u16) = xx = 0;

    snes.dma0.control = a = snes.dma.CONTROL_MODE_A;
    snes.dma0.mdma_dest = a = <:&snes.ppu.oam_write_data;
    snes.dma0.src_address_hl = xx = &buffer as u16;
    snes.dma0.src_address_bank = a = #:far &buffer;
    snes.dma0.mdma_size_hl = xx = sizeof(typeof(buffer)) + sizeof(typeof(hiTableBuffer));

    snes.dma.mdma_enable = a = snes.dma.ENABLE_0;
}



// DB = 0x7e
#[mem8, idx16]
func reset_buffers() {
    xx = (N_OBJECTS - 1) * sizeof(OamEntry);
    bufferPos = xx;
    oldBufferPos = xx;

    a = OFFSCREEN_YPOS;
    do {
        // ::ANNOY cannot do `buffer[unaligned xx].yPos = a;` ::

        (&buffer[0].yPos)[unaligned xx] = a;

        // subtract 4
        xx--; xx--; xx--; xx--;
    } while !negative;


    // ::ANNOY cannot run this loop backwards::
    for xx in 0 .. sizeof(typeof(hiTableBuffer)) - 1 {
        hiTableBuffer[xx] = a = 0xff;
    }

    hiTableQueue = a = HI_TABLE_QUEUE_INIT_VALUE;
    hiTableBufferPos = xx = sizeof(typeof(hiTableBuffer)) - 1;
}



// KEEP: Y
// DB = 0x7e
#[idx16]
inline func _decrement_buffer_index(pos : u16 in xx) : u16 in xx {
    // xx -= sizeof(OamEntry);
    xx--;
    xx--;
    xx--;
    xx--;

    return xx;
}



// Update `hiTableBuffer` and reset the `hiTableQueue`
// KEEP: X and Y
// DB = 0x7e
#[mem8, idx16]
func _hiTableQueue_full() {
    push16(xx);

    xx = hiTableBufferPos;

    hiTableBuffer[xx] = a = hiTableQueue;
    xx--;

    hiTableBufferPos = xx;


    hiTableQueue = a = HI_TABLE_QUEUE_INIT_VALUE;

    xx = pop16();
}



// NOTE: Resets the buffer positions.
// MUST be called before any MetaSprites are drawn.
// DB = 0x7e
#[mem8, idx16]
inline func draw_shadows() {
    // KEEP: X and Y
    #[mem8, idx16]
    inline func _update_hi_table_size_small() {
        hiTableQueue <<= 1;
    }


    // KEEP: X and Y
    #[mem8, idx16]
    inline func _update_hi_table_x9(x9 : bool in carry) {
        // Invert carry flag
        a = 0;
        a +#= 0xff;
        a >>>= 1;

        hiTableQueue <<<<#= 1;
        if carry {
            _hiTableQueue_full();
        }
    }

    // KEEP: X and Y
    #[mem8, idx16]
    inline func _update_hi_table_x9_0() {
        hiTableQueue <<= 1;
        if carry {
            _hiTableQueue_full();
        }
    }


    // Reset buffer positions
    hiTableQueue = a = HI_TABLE_QUEUE_INIT_VALUE;
    hiTableBufferPos = xx = sizeof(typeof(hiTableBuffer)) - 1;

    // xx = bufferPos
    xx = INITIAL_BUFFER_POS;


    // yy = entity pos
    yy = entities.SoA.LAST_INDEX;
    ^do {
        a = entities.SoA.shadowSize[unaligned yy] as u8;
        if !zero {
            _update_hi_table_size_small();

            if a == entities.ShadowSize.SMALL as u8 {
                // ::ANNOY cannot do `buffer[xx].xPos = a`::
                // ::ANNOY cannot do `u8_array[xx + 4] = a`::

                // yPos
                (&buffer[0].yPos as *u8)[xx] = a = entities.SoA.yPos_px[unaligned yy] - 4;
                // char
                (&buffer[0].char as *u8)[xx] = SHADOW_SMALL_CHAR;
                // attr
                (&buffer[0].attr as *u8)[xx] = a = SHADOW_ATTR;

                // xPos
                (&buffer[0].xPos as *u8)[xx] = a = entities.SoA.xPos_px[unaligned yy] + (-4 as u8);
                _update_hi_table_x9(carry);
            }
            else {
                if a == entities.ShadowSize.MEDIUM as u8 {
                    a = SHADOW_MEDIUM_CHAR;
                }
                else {
                    a = SHADOW_LARGE_CHAR;
                }
                // char
                (&buffer[ 0].char as *u8)[xx] = a;
                (&buffer[-1].char as *u8)[xx] = a;

                // yPos
                a = entities.SoA.yPos_px[unaligned yy] - 4;
                (&buffer[ 0].yPos as *u8)[xx] = a;
                (&buffer[-1].yPos as *u8)[xx] = a;

                // attr
                (&buffer[ 0].attr as *u8)[xx] = a = SHADOW_ATTR | OAM_H_FLIP;
                (&buffer[-1].attr as *u8)[xx] = a = SHADOW_ATTR;

                // xPos
                (&buffer[ 0].xPos as *u8)[xx] = a = entities.SoA.xPos_px[unaligned yy];
                _update_hi_table_x9_0();

                _update_hi_table_size_small();
                // carry clear from shift in _update_hi_table_size_small()
                (&buffer[-1].xPos as *u8)[xx] = a = entities.SoA.xPos_px[unaligned yy] +# (-8 as u8);
                _update_hi_table_x9(carry);


                xx = _decrement_buffer_index(xx);
            }

            xx = _decrement_buffer_index(xx);
        }


        yy--;
        yy--;
    } while !negative;


    bufferPos = xx;
}



#[mem8, idx16]
inline func finalize_buffer() {
    xx = bufferPos;
    if !negative {
        // ::ANNOY greater-than comparison `>` operator is not allowed in conditional::
        // ::: `if xx > oldBufferPos {``
        if { cmp(xx, oldBufferPos); } && carry && !zero {
            // The previous frame had more sprites onscreen the this frame.
            // Move them offscreen.
            do {
                (&buffer[0].yPos)[unaligned xx] = a = OFFSCREEN_YPOS;

                // subtract 4
                xx = _decrement_buffer_index(xx);
            } while xx != oldBufferPos;

            xx = bufferPos;
        }
    }
    oldBufferPos = xx;


    a = hiTableQueue;
    if a != HI_TABLE_QUEUE_INIT_VALUE {
        // hiTableQueue is not empty.

        // fill buffer
        do {
            a <<= 2;
        } while !carry;

        xx = hiTableBufferPos;
        hiTableBuffer[xx] = a;
    }
}


// Entity Functions
// ================


// Draw the entity's MetaSprite frame
//
// DB = 0x7e
#[mem8, idx8]
inline func _draw_entity__inline(entityId : u8 in y) {

    // Calculate MetaSprite position

    <:xPos = a = entities.SoA.xPos_px[unaligned y];
    >:xPos = 0;

    <:yPos = a = entities.SoA.yPos_px[unaligned y] - entities.SoA.zPos[unaligned y];
    a = 0;
    >:yPos = a = a -# 0;


    a = entities.SoA.metaSpriteFrame[unaligned y];

    mem16_idx16();
    #[mem16, idx16] {

        // Calculate MetaSprite Frame Address
        aa = aa & 0xff;

        // Safe: (aa << 1) will never set carry
        xx = aa = (aa << 1) +# entities.SoA.metaSpriteFrameTable[unaligned yy];
        aa = MetaSpriteFrameTableOffset[unaligned xx];

        xx = yy;
        yy = aa;


        mem8();
        #[mem8, idx16] {
            entities.SoA.ms_draw_function[unaligned xx](yy, xPos, yPos);
        }
    }
    mem8_idx8();
}



// MetaSprite Patterns
// ===================

namespace drawing_functions {

// ::TODO do a thorough test of the drawing functions and confirm partially off-screen sprites works correctly::


// Subtract the MsDataFormat offset from the MetaSprite position.
//
// KEEP: X and Y
// DB = 0x7e
#[mem8, idx16]
inline func _subtract_ms_offset_from_position(msFrame : u16 in xx, xPos : u16 in xPos, yPos : u16 in yPos) {

    <:xPos = a = <:xPos - MsDataFormat.xOffset[unaligned xx];
    if !carry {
        (>:xPos)--;
    }

    <:yPos = a = <:yPos - MsDataFormat.yOffset[unaligned xx];
    if !carry {
        (>:yPos)--;
    }
}



// KEEP: X and Y
// DB = 0x7e
#[mem8, idx16]
inline func _update_hi_table_size_small() {
    hiTableQueue <<= 1;
}



// KEEP: X and Y
// DB = 0x7e
#[mem8, idx16]
inline func _update_hi_table_size_large() {
    carry = true;
    hiTableQueue <<<<#= 1;
}



// KEEP: X and Y
// DB = 0x7e
#[mem8, idx16]
inline func _update_hi_table_x8(x8 : bool in carry) {
    hiTableQueue <<<<#= 1;
    if carry {
        _hiTableQueue_full();
    }
}

// KEEP: X and Y
#[mem8, idx16]
inline func _update_hi_table_x8_invert(x8 : bool in carry) {
    // Invert carry flag
    a = 0;
    a +#= 0xff;
    a >>>= 1;

    _update_hi_table_x8(carry);
}



// KEEP: X and Y
// DB = 0x7e
#[mem8, idx16]
inline func _update_hi_table_x8_xPos() {
    a = >:xPos >>> 1;
    _update_hi_table_x8(carry);
}



// KEEP: X and Y
// DB = 0x7e
#[mem8, idx16]
inline func _update_hi_table_x8_0() {
    hiTableQueue <<= 1;
    if carry {
        _hiTableQueue_full();
    }
}



// One sprite:
//  * 1st sprite (Large)
//
// ┌─┐
// │ │
// └─┘
//
// DB = 0x7e
#[mem8, idx16]
func square_single16(msFrame : u16 in yy, xPos : u16 in xPos, yPos : u16 in yPos) {
    xx = yy;

    yy = bufferPos;
    if !negative {
        // size
        _update_hi_table_size_large();

        (&buffer[0].xPos)[unaligned yy] = a = <:xPos - MsDataFormat.xOffset[unaligned xx];
        a = >:xPos -# 0;
        cmp(a, 1);
        _update_hi_table_x8(carry);


        a = <:yPos - MsDataFormat.yOffset[unaligned xx];
        if carry {
            if a >= (256 - 16 - 1) {
                a = 256 - 16;
            }
        }
        else {
            if a < (256 - 16) {
                a = 256 - 16;
            }
        }
        (&buffer[0].yPos)[unaligned yy] = a;

        mem16();
        #[mem16] {
            (&buffer[ 0].char as *u16)[unaligned yy] = aa = MsDataFormat.charAttr0[unaligned xx];
        }
        mem8();

        yy--;
        yy--;
        yy--;
        yy--;
        bufferPos = yy;
    }
}



// Two sprites, 16x8 px rectangle:
//  * 1st Sprite (small)
//  * 2nd Sprite (small)
//
// ┌┬┐
// └┴┘
//
// DB = 0x7e
#[mem8, idx16]
func rect_16x8_two(msFrame : u16 in yy, xPos : u16 in xPos, yPos : u16 in yPos) {
    xx = yy;

    _subtract_ms_offset_from_position(xx, xPos, yPos);

    yy = bufferPos;
    return if negative || yy < (2 - 1) * sizeof(OamEntry);


    a = <:xPos;
    (&buffer[ 0].xPos)[unaligned yy] = a;

    _update_hi_table_size_small();
    _update_hi_table_x8_xPos();

    _update_hi_table_size_small();
    (&buffer[-1].xPos)[unaligned yy] = a = <:xPos + 8;
    a = (>:xPos +# 0) >>> 1;
    _update_hi_table_x8(carry);


    mem16();
    #[mem16] {
        aa = yPos;
        if aa >= DISPLAY_HEIGHT && aa < -16 as u16 {
            aa = -16 as u16;
        }
        (&buffer[ 0].yPos as *u16)[unaligned yy] = aa;
        (&buffer[-1].yPos as *u16)[unaligned yy] = aa;


        (&buffer[ 0].char as *u16)[unaligned yy] = aa = MsDataFormat.charAttr0[unaligned xx];
        (&buffer[-1].char as *u16)[unaligned yy] = aa = MsDataFormat.charAttr1[unaligned xx];

        yy = aa = yy - 2 * sizeof(OamEntry);
    }
    mem8();

    bufferPos = yy;
}



// Two sprites, 8x16 rectangle:
//  * 1st Sprite: small
//  * 2nd Sprite: small
//
// ┌┐
// ├┤
// └┘
//
// DB = 0x7e
#[mem8, idx16]
func rect_8x16_two(msFrame : u16 in yy, xPos : u16 in xPos, yPos : u16 in yPos) {
    xx = yy;

    _subtract_ms_offset_from_position(xx, xPos, yPos);

    yy = bufferPos;
    return if negative || yy < (2 - 1) * sizeof(OamEntry);


    a = <:xPos;
    (&buffer[ 0].xPos)[unaligned yy] = a;
    (&buffer[-1].xPos)[unaligned yy] = a;

    _update_hi_table_size_small();
    _update_hi_table_x8_xPos();

    _update_hi_table_size_small();
    _update_hi_table_x8_xPos();


    mem16();
    #[mem16] {
        aa = yPos;
        if aa >= DISPLAY_HEIGHT && aa < -16 as u16 {
            aa = -16 as u16;
        }
        (&buffer[ 0].yPos as *u16)[unaligned yy] = aa;

        aa = yPos + 8;
        if aa >= DISPLAY_HEIGHT && aa < -16 as u16 {
            aa = -16 as u16;
        }
        (&buffer[-1].yPos as *u16)[unaligned yy] = aa;


        (&buffer[ 0].char as *u16)[unaligned yy] = aa = MsDataFormat.charAttr0[unaligned xx];
        (&buffer[-1].char as *u16)[unaligned yy] = aa = MsDataFormat.charAttr1[unaligned xx];

        yy = aa = yy - 2 * sizeof(OamEntry);
    }
    mem8();

    bufferPos = yy;
}



// Two sprites, 16x32 rectangle:
//  * 1st Sprite: Large
//  * 2nd Sprite: Large
//
// ┌─┐
// │ │
// ├─┤
// │ │
// └─┘
//
// DB = 0x7e
#[mem8, idx16]
func rect_16x32_two(msFrame : u16 in yy, xPos : u16 in xPos, yPos : u16 in yPos) {
    xx = yy;

    _subtract_ms_offset_from_position(xx, xPos, yPos);

    yy = bufferPos;
    return if negative || yy < (2 - 1) * sizeof(OamEntry);


    a = <:xPos;
    (&buffer[ 0].xPos)[unaligned yy] = a;
    (&buffer[-1].xPos)[unaligned yy] = a;

    _update_hi_table_size_large();
    _update_hi_table_x8_xPos();

    _update_hi_table_size_large();
    _update_hi_table_x8_xPos();


    mem16();
    #[mem16] {
        aa = yPos;
        if aa >= DISPLAY_HEIGHT && aa < -16 as u16 {
            aa = -16 as u16;
        }
        (&buffer[ 0].yPos as *u16)[unaligned yy] = aa;

        aa = yPos + 16;
        if aa >= DISPLAY_HEIGHT && aa < -16 as u16 {
            aa = -16 as u16;
        }
        (&buffer[-1].yPos as *u16)[unaligned yy] = aa;


        (&buffer[ 0].char as *u16)[unaligned yy] = aa = MsDataFormat.charAttr0[unaligned xx];
        (&buffer[-1].char as *u16)[unaligned yy] = aa = MsDataFormat.charAttr1[unaligned xx];

        yy = aa = yy - 2 * sizeof(OamEntry);
    }
    mem8();

    bufferPos = yy;
}



// Three sprites, 16x24 px rectangle:
//  * 1st Sprite (large)
//  * 2nd Sprite (small)
//  * 3rd Sprite (small)
//
// ┌─┐
// │ │
// ├┬┤
// └┴┘
//
// DB = 0x7e
#[mem8, idx16]
func rect_16x24_three(msFrame : u16 in yy, xPos : u16 in xPos, yPos : u16 in yPos) {
    xx = yy;

    _subtract_ms_offset_from_position(xx, xPos, yPos);

    yy = bufferPos;
    return if negative || yy < (3 - 1) * sizeof(OamEntry);


    a = <:xPos;
    (&buffer[ 0].xPos)[unaligned yy] = a;
    (&buffer[-1].xPos)[unaligned yy] = a;

    _update_hi_table_size_large();
    _update_hi_table_x8_xPos();

    _update_hi_table_size_small();
    _update_hi_table_x8_xPos();


    _update_hi_table_size_small();

    (&buffer[-2].xPos)[unaligned yy] = a = (&buffer[ 0].xPos)[unaligned yy] + 8;
    a = (>:xPos +# 0) >>> 1;
    _update_hi_table_x8(carry);


    mem16();
    #[mem16] {
        aa = yPos;
        if aa >= DISPLAY_HEIGHT && aa < -16 as u16 {
            aa = -16 as u16;
        }
        (&buffer[ 0].yPos as *u16)[unaligned yy] = aa;

        aa = yPos + 16;
        if aa >= DISPLAY_HEIGHT && aa < -16 as u16 {
            aa = -16 as u16;
        }
        (&buffer[-1].yPos as *u16)[unaligned yy] = aa;
        (&buffer[-2].yPos as *u16)[unaligned yy] = aa;


        (&buffer[ 0].char as *u16)[unaligned yy] = aa = MsDataFormat.charAttr0[unaligned xx];
        (&buffer[-1].char as *u16)[unaligned yy] = aa = MsDataFormat.charAttr1[unaligned xx];
        (&buffer[-2].char as *u16)[unaligned yy] = aa = MsDataFormat.charAttr2[unaligned xx];

        yy = aa = yy - 3 * sizeof(OamEntry);
    }
    mem8();

    bufferPos = yy;
}



// Four sprites, 16x24 rect + an extra small sprite on the side:
//  * 1st Sprite (large)
//  * 2nd Sprite (small)
//  * 3rd Sprite (small)
//  * 4th Sprite (small - onto side)
//
// ┌─┐
// │ ├┐
// ├┬┼┘
// └┴┘
//
// DB = 0x7e
#[mem8, idx16]
func rect_16x24_and_extra(msFrame : u16 in yy, xPos : u16 in xPos, yPos : u16 in yPos) {
    xx = yy;

    _subtract_ms_offset_from_position(xx, xPos, yPos);

    yy = bufferPos;
    return if negative || yy < (4 - 1) * sizeof(OamEntry);


    a = <:xPos;
    (&buffer[ 0].xPos)[unaligned yy] = a;
    (&buffer[-1].xPos)[unaligned yy] = a;

    _update_hi_table_size_large();
    _update_hi_table_x8_xPos();

    _update_hi_table_size_small();
    _update_hi_table_x8_xPos();


    _update_hi_table_size_small();

    (&buffer[-2].xPos)[unaligned yy] = a = <:xPos + 8;
    a = (>:xPos +# 0) >>> 1;
    _update_hi_table_x8(carry);

    _update_hi_table_size_small();

    (&buffer[-3].xPos)[unaligned yy] = a = <:xPos + 16;
    a = (>:xPos +# 0) >>> 1;
    _update_hi_table_x8(carry);


    mem16();
    #[mem16] {
        aa = yPos;
        if aa >= DISPLAY_HEIGHT && aa < -16 as u16 {
            aa = -16 as u16;
        }
        (&buffer[ 0].yPos as *u16)[unaligned yy] = aa;

        aa = yPos + 16;
        if aa >= DISPLAY_HEIGHT && aa < -16 as u16 {
            aa = -16 as u16;
        }
        (&buffer[-1].yPos as *u16)[unaligned yy] = aa;
        (&buffer[-2].yPos as *u16)[unaligned yy] = aa;

        aa = yPos + 8;
        if aa >= DISPLAY_HEIGHT && aa < -16 as u16 {
            aa = -16 as u16;
        }
        (&buffer[-3].yPos as *u16)[unaligned yy] = aa;


        (&buffer[ 0].char as *u16)[unaligned yy] = aa = MsDataFormat.charAttr0[unaligned xx];
        (&buffer[-1].char as *u16)[unaligned yy] = aa = MsDataFormat.charAttr1[unaligned xx];
        (&buffer[-2].char as *u16)[unaligned yy] = aa = MsDataFormat.charAttr2[unaligned xx];
        (&buffer[-3].char as *u16)[unaligned yy] = aa = MsDataFormat.charAttr3[unaligned xx];

        yy = aa = yy - 4 * sizeof(OamEntry);
    }
    mem8();

    bufferPos = yy;
}

}

}
}



// Moving this here prevents an
// "encountered a reference to `var metasprites.xPos` before its type was known" error.
import "entities/_variables";

