// Copyright (c) 2021, Marcus Rowe <undisbeliever@gmail.com>.
// Distributed under The MIT License, see the LICENSE file for more details.

import "../memmap";

import "_variables";
import "_common";
import "_base";
import "_vision_cone";


import "../../gen/entities";


namespace entities {
namespace crossbow_man {


let SPEED = 0x00aa;

let ANIMATION_DELAY = 15;
let ANIMATION_FRAME_MASK = 0x3;

// Delay between seeing player and firing bolt in frames
let ATTACK_DELAY          = 10;

// Delay between firing bolt and the next action in frames
let ATTACK_RECOVERY_DELAY = 30;



// State must be in the same order as the MetaSprite frames
enum State : u8 {
    WALK_SOUTH      =  0,
    WALK_NORTH      =  2,
    WALK_EAST       =  4,
    WALK_WEST       =  6,
    ATTACKING       =  8,
    ATTACK_RECOVERY = 10,
    HURT            = 12,
};

let N_DIRECTIONS = 4;


let SoA_state            = SoA.state_0_l as *State;
let SoA_direction        = SoA.state_0_h as *State;

let SoA_animationCounter = SoA.state_1_l;

// Countdown timer until the next action when attacking
// (display frame countdown timer)
let SoA_boltTimer        = SoA.state_1_h;



in code {


// Entity process routine.
//
// Called when the entity is spawned
//
// DB = 0x7e
#[mem8, idx8]
func init(entityId : u8 in x, parameter : u8 in y) {

    if y == init_parameter.left as u8 {
        set_direction_east(x);
    }
    else if y == init_parameter.right as u8 {
        set_direction_west(x);
    }
    else if y == init_parameter.up as u8 {
        set_direction_north(x);
    }
    else {
        set_direction_south(x);
    }
}



// Entity process routine.
//
// Called once per frame.
//
// DB = 0x7e
#[mem8, idx8]
func process(entityId : u8 in x) : bool in carry {

    x = base.process_collisions(x);


    if collisionState $ CollisionState.PLAYER_WEAPON_BIT {
        x = set_state__hurt(x);
    }


    // ::TODO add reaction when colliding with player hurtbox ::


    y = x;
    x = SoA_state[y] as u8;
    return process__state_functions[unaligned x]();
}


const process__state_functions = [
    process__walk_south,
    process__walk_north,
    process__walk_east,
    process__walk_west,
    process__attacking,
    process__attack_recovery,
    process__hurt,
];



// DB = 0x7e
#[mem8, idx8]
func process__walk_south() : bool in carry {
    x = currentEntityId;


    // Check for a tile collision in the previous frame
    a = SoA.movementState[x];
    if a & MovementState.X_AXIS_COLLISION != 0 {
        ^return set_direction_east(x);
    }
    else if a & MovementState.Y_AXIS_COLLISION != 0 {
        ^return set_direction_north(x);
    }


    carry = vision_cone.test_down(x);
    if carry {
        ^return set_state__attacking(x);
    }


    // ::TODO check for solid tile 2 tiles below the entity ::
    // ::TODO lean left or right if player to the left/right ::
    // ::TODO check for player and change state to FIRING_BOLT_SOUTH ::


    return _update_walk_animation(x);
}



// DB = 0x7e
#[mem8, idx8]
func process__walk_north() : bool in carry {
    x = currentEntityId;


    // Check for a tile collision in the previous frame
    a = SoA.movementState[x];
    if a & MovementState.X_AXIS_COLLISION != 0 {
        ^return set_direction_west(x);
    }
    else if a & MovementState.Y_AXIS_COLLISION != 0 {
        ^return set_direction_south(x);
    }


    carry = vision_cone.test_up(x);
    if carry {
        ^return set_state__attacking(x);
    }


    // ::TODO check for solid tile 2 tiles above the entity ::
    // ::TODO lean left or right if player to the left/right ::
    // ::TODO check for player and change state to FIRING_BOLT_NORTH ::


    return _update_walk_animation(x);
}



// DB = 0x7e
#[mem8, idx8]
func process__walk_east() : bool in carry {
    x = currentEntityId;


    // Check for a tile collision in the previous frame
    a = SoA.movementState[x];
    if a & MovementState.X_AXIS_COLLISION != 0 {
        ^return set_direction_west(x);
    }
    else if a & MovementState.Y_AXIS_COLLISION != 0 {
        ^return set_direction_north(x);
    }


    carry = vision_cone.test_right(x);
    if carry {
        ^return set_state__attacking(x);
    }


    // ::TODO check for solid tile 2 tiles to the right of the entity ::
    // ::TODO lean up or down if player to the up/down ::
    // ::TODO check for player and change state to FIRING_BOLT_EAST ::


    return _update_walk_animation(x);
}



// DB = 0x7e
#[mem8, idx8]
func process__walk_west() : bool in carry {
    x = currentEntityId;


    // Check for a tile collision in the previous frame
    a = SoA.movementState[x];
    if a & MovementState.X_AXIS_COLLISION != 0 {
        ^return set_direction_east(x);
    }
    else if a & MovementState.Y_AXIS_COLLISION != 0 {
        ^return set_direction_south(x);
    }


    carry = vision_cone.test_left(x);
    if carry {
        ^return set_state__attacking(x);
    }


    // ::TODO check for solid tile 2 tiles to the left of the entity ::
    // ::TODO lean up or down if player to the up/down ::
    // ::TODO check for player and change state to FIRING_BOLT_WEST ::


    return _update_walk_animation(x);
}





// returns true
//
// DB = 0x7e
#[mem8, idx8]
func _update_walk_animation(entityId : u8 in x) : bool in carry {
let _tmp = <:dpTmp0;

    SoA_animationCounter[x]--;
    if negative {
        SoA_animationCounter[x] = a = ANIMATION_DELAY - 1;

        // Increment animation Frame
        a = SoA.metaSpriteFrame[x];
        a++;
        _tmp = a = a & ANIMATION_FRAME_MASK;

        SoA.metaSpriteFrame[x] = a = (SoA.metaSpriteFrame[x] & (ANIMATION_FRAME_MASK ^ 0xff)) | _tmp;
    }

    return true;
}




// DB = 0x7e
#[mem8, idx8]
func set_direction_south(entityId : u8 in x) : bool in carry {
    SoA_state[x] = State.WALK_SOUTH;
    SoA_direction[x] = State.WALK_SOUTH;

    SoA.metaSpriteFrame[x] = ms_frames.south0;
    SoA_animationCounter[x] = 0;

    mem16();
    #[mem16] {
        SoA.xVelocity[unaligned x] = 0;
        SoA.yVelocity[unaligned x] = aa = SPEED as u16;
    }
    mem8();

    return true;
}



// DB = 0x7e
#[mem8, idx8]
func set_direction_north(entityId : u8 in x) : bool in carry {
    a = State.WALK_NORTH as u8;
    SoA_state[x] = a as State;
    SoA_direction[x] = a as State;

    SoA.metaSpriteFrame[x] = a = ms_frames.north0;
    SoA_animationCounter[x] = 0;

    mem16();
    #[mem16] {
        SoA.xVelocity[unaligned x] = 0;
        SoA.yVelocity[unaligned x] = aa = -SPEED as u16;
    }
    mem8();

    return true;
}



// DB = 0x7e
#[mem8, idx8]
func set_direction_east(entityId : u8 in x) : bool in carry {
    a = State.WALK_EAST as u8;
    SoA_state[x] = a as State;
    SoA_direction[x] = a as State;

    SoA.metaSpriteFrame[x] = a = ms_frames.east0;
    SoA_animationCounter[x] = 0;

    mem16();
    #[mem16] {
        SoA.xVelocity[unaligned x] = aa = SPEED;
        SoA.yVelocity[unaligned x] = 0;
    }
    mem8();

    return true;
}



// db = 0x7e
#[mem8, idx8]
func set_direction_west(entityid : u8 in x) : bool in carry {
    a = State.WALK_WEST as u8;
    SoA_state[x] = a as State;
    SoA_direction[x] = a as State;

    SoA.metaSpriteFrame[x] = a = ms_frames.west0;
    SoA_animationCounter[x] = 0;

    mem16();
    #[mem16] {
        SoA.xVelocity[unaligned x] = aa = -SPEED as u16;
        SoA.yVelocity[unaligned x] = 0;
    }
    mem8();

    return true;
}



// Attacking
// =========



// KEEP: X
// DB = 0x7e
#[mem8, idx8]
func set_state__attacking(entityId : u8 in x) : bool in carry {
    a = State.ATTACKING as u8;
    SoA_state[x] = a as State;

    SoA_boltTimer[x] = a = ATTACK_DELAY;

    mem16();
    #[mem16] {
        entities.SoA.xVelocity[unaligned x] = 0;
        entities.SoA.yVelocity[unaligned x] = 0;
    }
    mem8();

    return true;
}



// Fire a bolt on the next frame.
//
// KEEP: X
// DB = 0x7e
#[mem8, idx8]
inline func _set_state__attacking__immediate(entityId : u8 in x) {
    a = State.ATTACKING as u8;
    SoA_state[x] = a as State;

    SoA_boltTimer[x] = 0;
}



// DB = 0x7e
#[mem8, idx8]
func process__attacking() : bool in carry {
    x = currentEntityId;

    a = SoA_boltTimer[x];
    if !zero {
        a--;
        SoA_boltTimer[x] = a;
    }
    else {
        // Fire bolt
        a = SoA_direction[x] as u8;
        if a < N_DIRECTIONS * 2 {
            y = a = a >>> 1;

            entities.spawn_entity(a = SoA.xPos_px[x],
                                  a = SoA.yPos_px[x],
                                  a = EntityTypes.bolt as u8,
                                  y);

            x = currentEntityId;
        }

        _set_state__attack_recovery(x);
    }

    return true;
}



// Attack Recovery
// ===============


// KEEP: X
// DB = 0x7e
#[mem8, idx8]
inline func _set_state__attack_recovery(entityId : u8 in x) {

    a = State.ATTACK_RECOVERY as u8;
    SoA_state[x] = a as State;

    SoA_boltTimer[x] = a = ATTACK_RECOVERY_DELAY;
}



// DB = 0x7e
#[mem8, idx8]
func process__attack_recovery() : bool in carry {
    x = currentEntityId;

    a = SoA_boltTimer[x];
    if !zero {
        a--;
        SoA_boltTimer[x] = a;
    }
    else {
        // Bolt recovery ended
        // Check if player is still inside the vision cone

        a = SoA_direction[x] as u8;

        if a == State.WALK_EAST as u8 {
            carry = vision_cone.test_right(x);
            if !carry {
                ^return set_direction_east(x);
            }
        }
        else if a == State.WALK_WEST as u8 {
            carry = vision_cone.test_left(x);
            if !carry {
                ^return set_direction_west(x);
            }
        }
        else if a == State.WALK_NORTH as u8 {
            carry = vision_cone.test_up(x);
            if !carry {
                ^return set_direction_north(x);
            }
        }
        else {
            carry = vision_cone.test_down(x);
            if !carry {
                ^return set_direction_south(x);
            }
        }

        // Player is still in vision code, fire bolt on next frame
        _set_state__attacking__immediate(x);
    }

    return true;
}



// Hurt
// ====

// KEEP: X
// DB = 0x7e
#[mem8, idx8]
func set_state__hurt(entityId : u8 in x) : u8 in x {
    a = State.HURT as u8;
    SoA_state[x] = a as State;

    return x;
}



// DB = 0x7e
#[mem8, idx8]
func process__hurt() : bool in carry {
    x = currentEntityId;

    // ::TODO add reaction ::

    mem16();
    #[mem16] {
        entities.SoA.xVelocity[unaligned x] = 0;
        entities.SoA.yVelocity[unaligned x] = 0;
    }
    mem8();

    return true;
}


}

}
}

