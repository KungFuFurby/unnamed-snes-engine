// Copyright (c) 2021, Marcus Rowe <undisbeliever@gmail.com>.
// Distributed under The MIT License, see the LICENSE file for more details.

import "../memmap";

import "_variables";
import "_common";
import "_base";
import "_vision_cone";

import "../player";

import "../../gen/entities";


namespace entities {
namespace crossbow_man {


let SPEED = 0x00aa;

let ANIMATION_DELAY = 15;
let ANIMATION_FRAME_MASK = 0x3;

// Delay between seeing player and firing bolt in frames
let ATTACK_DELAY          = 10;

// Delay between firing bolt and the next action in frames
let ATTACK_RECOVERY_DELAY = 30;

let HURT_KNOCKBACK_TIME_IN_FRAMES = 10;
let BLOCKING_KNOCKBACK_TIME_IN_FRAMES = 12;

let HURT_COOLDOWN_DELAY = 40;




// State must be in the same order as the MetaSprite frames
enum State : u8 {
    WALK_SOUTH      =  0,
    WALK_NORTH      =  2,
    WALK_EAST       =  4,
    WALK_WEST       =  6,
    ATTACKING       =  8,
    ATTACK_RECOVERY = 10,
    HURT            = 12,
    BLOCKING        = 14,
    HURT_COOLDOWN   = 16,
};


// Direction must be in the same order as the MetaSprite frames
enum Direction : u8 {
    SOUTH = 0,
    NORTH = 2,
    EAST  = 4,
    WEST  = 6,
};


let N_DIRECTIONS = 4;

let DIRECTION_MS_SHIFT = 2 - 1;

// ::TODO determine which frame (1 or 3) is the more correct firing stance::
let ATTACK_MS_FRAME = 1;


let SoA_state            = SoA.state_0_l as *State;
let SoA_walkingDirection = SoA.state_0_h as *Direction;
let SoA_facingDirection  = SoA.state_1_l as *Direction;

let SoA_animationCounter = SoA.state_1_h;


// Countdown timer until the next action when attacking
// (display frame countdown timer)
let SoA_boltTimer        = SoA.state_2_l;


// Countdown timer (when not attacking)
// (display frame countdown timer)
let SoA_countdownTimer   = SoA.state_2_h;


in code {


// Entity process routine.
//
// Called when the entity is spawned
//
// DB = 0x7e
#[mem8, idx8]
func init(entityId : u8 in y, parameter : u8 in x) {

    a = x <<< 1;
    ^return set_state__walk(y, a);
}



// Entity process routine.
//
// Called once per frame.
//
// DB = 0x7e
#[mem8, idx8]
func process(entityId : u8 in y) : bool in carry {

    y = base.process_collisions(y);


    if collisionState $ CollisionState.PLAYER_WEAPON_BIT {
        collided_with_player_weapon(y);
    }

    if collisionState $ CollisionState.PLAYER_HURTBOX_BIT {
        base.hurt_player__collision(y);

        // ::TODO add reaction when colliding with player hurtbox ::
    }


    x = SoA_state[y] as u8;
    return process__state_functions[unaligned x](y);
}



const process__state_functions = [
    process__walk_south,
    process__walk_north,
    process__walk_east,
    process__walk_west,
    process__attacking,
    process__attack_recovery,
    process__hurt,
    process__blocking,
    process__hurt_cooldown,
];



// DB = 0x7e
#[mem8, idx8]
func process__walk_south(entityId : u8 in y) : bool in carry {

    // Check for a tile collision in the previous frame
    a = SoA.movementState[y];
    if a & MovementState.X_AXIS_COLLISION != 0 {
        ^return set_direction_east(y);
    }
    else if a & MovementState.Y_AXIS_COLLISION != 0 {
        ^return set_direction_north(y);
    }


    carry = vision_cone.test_down(y);
    if carry {
        ^return set_state__attacking(y, Direction.SOUTH as u8);
    }
    carry = vision_cone.test_right(y);
    if carry {
        ^return set_state__attacking(y, Direction.EAST as u8);
    }
    carry = vision_cone.test_left(y);
    if carry {
        ^return set_state__attacking(y, Direction.WEST as u8);
    }


    // ::TODO check for solid tile 2 tiles below the entity ::
    // ::TODO lean left or right if player to the left/right ::
    // ::TODO check for player and change state to FIRING_BOLT_SOUTH ::


    ^return _update_walk_animation(y);
}



// DB = 0x7e
#[mem8, idx8]
func process__walk_north(entityId : u8 in y) : bool in carry {

    // Check for a tile collision in the previous frame
    a = SoA.movementState[y];
    if a & MovementState.X_AXIS_COLLISION != 0 {
        ^return set_direction_west(y);
    }
    else if a & MovementState.Y_AXIS_COLLISION != 0 {
        ^return set_direction_south(y);
    }


    carry = vision_cone.test_up(y);
    if carry {
        ^return set_state__attacking(y, Direction.NORTH as u8);
    }
    carry = vision_cone.test_right(y);
    if carry {
        ^return set_state__attacking(y, Direction.EAST as u8);
    }
    carry = vision_cone.test_left(y);
    if carry {
        ^return set_state__attacking(y, Direction.WEST as u8);
    }


    // ::TODO check for solid tile 2 tiles above the entity ::
    // ::TODO lean left or right if player to the left/right ::
    // ::TODO check for player and change state to FIRING_BOLT_NORTH ::


    ^return _update_walk_animation(y);
}



// DB = 0x7e
#[mem8, idx8]
func process__walk_east(entityId : u8 in y) : bool in carry {

    // Check for a tile collision in the previous frame
    a = SoA.movementState[y];
    if a & MovementState.X_AXIS_COLLISION != 0 {
        ^return set_direction_west(y);
    }
    else if a & MovementState.Y_AXIS_COLLISION != 0 {
        ^return set_direction_north(y);
    }


    carry = vision_cone.test_right(y);
    if carry {
        ^return set_state__attacking(y, Direction.EAST as u8);
    }
    carry = vision_cone.test_up(y);
    if carry {
        ^return set_state__attacking(y, Direction.NORTH as u8);
    }
    carry = vision_cone.test_down(y);
    if carry {
        ^return set_state__attacking(y, Direction.SOUTH as u8);
    }


    // ::TODO check for solid tile 2 tiles to the right of the entity ::
    // ::TODO lean up or down if player to the up/down ::
    // ::TODO check for player and change state to FIRING_BOLT_EAST ::


    return _update_walk_animation(y);
}



// DB = 0x7e
#[mem8, idx8]
func process__walk_west(entityId : u8 in y) : bool in carry {

    // Check for a tile collision in the previous frame
    a = SoA.movementState[y];
    if a & MovementState.X_AXIS_COLLISION != 0 {
        ^return set_direction_east(y);
    }
    else if a & MovementState.Y_AXIS_COLLISION != 0 {
        ^return set_direction_south(y);
    }


    carry = vision_cone.test_left(y);
    if carry {
        ^return set_state__attacking(y, Direction.WEST as u8);
    }
    carry = vision_cone.test_up(y);
    if carry {
        ^return set_state__attacking(y, Direction.NORTH as u8);
    }
    carry = vision_cone.test_down(y);
    if carry {
        ^return set_state__attacking(y, Direction.SOUTH as u8);
    }


    // ::TODO check for solid tile 2 tiles to the left of the entity ::
    // ::TODO lean up or down if player to the up/down ::
    // ::TODO check for player and change state to FIRING_BOLT_WEST ::


    return _update_walk_animation(y);
}





// returns true
//
// DB = 0x7e
#[mem8, idx8]
func _update_walk_animation(entityId : u8 in y) : bool in carry {
let _tmp = zpTmp_byte_0;

    a = SoA_animationCounter[y];
    if !zero {
        a--;
        SoA_animationCounter[y] = a;
    }
    else {
        SoA_animationCounter[y] = a = ANIMATION_DELAY;

        // Increment animation Frame
        a = SoA.metaSpriteFrame[y];
        a++;
        _tmp = a = a & ANIMATION_FRAME_MASK;

        SoA.metaSpriteFrame[y] = a = (SoA.metaSpriteFrame[y] & (ANIMATION_FRAME_MASK ^ 0xff)) | _tmp;
    }

    return true;
}


// DB = 0x7e
#[mem8, idx8]
func set_state__walk(entityId : u8 in y, direction : u8 in a) : bool in carry {

    if a == Direction.EAST as u8 {
        return set_direction_east(y);
    }
    else if a == Direction.WEST as u8 {
        return set_direction_west(y);
    }
    else if a == Direction.NORTH as u8 {
        return set_direction_north(y);
    }
    else {
        return set_direction_south(y);
    }

    return true;
}



// DB = 0x7e
#[mem8, idx8]
func set_direction_south(entityId : u8 in y) : bool in carry {
    x = y;

    SoA_state[x] = State.WALK_SOUTH;
    SoA_walkingDirection[x] = Direction.SOUTH;
    SoA_facingDirection[x] = Direction.SOUTH;

    SoA.metaSpriteFrame[x] = ms_frames.south0;
    SoA_animationCounter[x] = 0;

    mem16();
    #[mem16] {
        SoA.xVelocity[unaligned x] = 0;
        SoA.yVelocity[unaligned x] = aa = SPEED as u16;
    }
    mem8();

    return true;
}



// DB = 0x7e
#[mem8, idx8]
func set_direction_north(entityId : u8 in y) : bool in carry {
    x = y;

    a = State.WALK_NORTH as u8;
    SoA_state[x] = a as State;
    SoA_walkingDirection[x] = a as Direction;
    SoA_facingDirection[x] = a as Direction;

    SoA.metaSpriteFrame[x] = a = ms_frames.north0;
    SoA_animationCounter[x] = 0;

    mem16();
    #[mem16] {
        SoA.xVelocity[unaligned x] = 0;
        SoA.yVelocity[unaligned x] = aa = -SPEED as u16;
    }
    mem8();

    return true;
}



// DB = 0x7e
#[mem8, idx8]
func set_direction_east(entityId : u8 in y) : bool in carry {
    x = y;

    a = State.WALK_EAST as u8;
    SoA_state[x] = a as State;
    SoA_walkingDirection[x] = a as Direction;
    SoA_facingDirection[x] = a as Direction;

    SoA.metaSpriteFrame[x] = a = ms_frames.east0;
    SoA_animationCounter[x] = 0;

    mem16();
    #[mem16] {
        SoA.xVelocity[unaligned x] = aa = SPEED;
        SoA.yVelocity[unaligned x] = 0;
    }
    mem8();

    return true;
}



// db = 0x7e
#[mem8, idx8]
func set_direction_west(entityid : u8 in y) : bool in carry {
    x = y;

    a = State.WALK_WEST as u8;
    SoA_state[x] = a as State;
    SoA_walkingDirection[x] = a as Direction;
    SoA_facingDirection[x] = a as Direction;

    SoA.metaSpriteFrame[x] = a = ms_frames.west0;
    SoA_animationCounter[x] = 0;

    mem16();
    #[mem16] {
        SoA.xVelocity[unaligned x] = aa = -SPEED as u16;
        SoA.yVelocity[unaligned x] = 0;
    }
    mem8();

    return true;
}



// Attacking
// =========



// KEEP: Y
// DB = 0x7e
#[mem8, idx8]
func set_state__attacking(entityId : u8 in y, direction : u8 in a) : bool in carry {

    SoA_facingDirection[y] = a as Direction;

    SoA.metaSpriteFrame[y] = a = (a <<< DIRECTION_MS_SHIFT) + ATTACK_MS_FRAME;


    a = State.ATTACKING as u8;
    SoA_state[y] = a as State;

    SoA_boltTimer[y] = a = ATTACK_DELAY;

    mem16();
    #[mem16] {
        x = y;
        entities.SoA.xVelocity[unaligned x] = 0;
        entities.SoA.yVelocity[unaligned x] = 0;
    }
    mem8();

    return true;
}



// Fire a bolt on the next frame.
//
// KEEP: Y
// DB = 0x7e
#[mem8, idx8]
inline func _set_state__attacking__immediate(entityId : u8 in y) {
    a = State.ATTACKING as u8;
    SoA_state[y] = a as State;

    x = y;
    SoA_boltTimer[x] = 0;
}



// DB = 0x7e
#[mem8, idx8]
func process__attacking(entityId : u8 in y) : bool in carry {

    a = SoA_boltTimer[y];
    if !zero {
        a--;
        SoA_boltTimer[y] = a;
    }
    else {
        // Fire bolt
        a = SoA_facingDirection[y] as u8;
        if a < N_DIRECTIONS * 2 {
            x = a = a >>> 1;

            entities.spawn_entity(a = SoA.xPos_px[y],
                                  a = SoA.yPos_px[y],
                                  a = EntityTypes.bolt_angled as u8,
                                  x);

            y = currentEntityId;
        }

        _set_state__attack_recovery(y);
    }

    return true;
}



// Attack Recovery
// ===============


// KEEP: Y
// DB = 0x7e
#[mem8, idx8]
inline func _set_state__attack_recovery(entityId : u8 in y) {

    a = State.ATTACK_RECOVERY as u8;
    SoA_state[y] = a as State;

    SoA_boltTimer[y] = a = ATTACK_RECOVERY_DELAY;
}



// DB = 0x7e
#[mem8, idx8]
func process__attack_recovery(entityId : u8 in y) : bool in carry {

    a = SoA_boltTimer[y];
    if !zero {
        a--;
        SoA_boltTimer[y] = a;
    }
    else {
        // Bolt recovery ended
        // Check if player is still inside the vision cone

        a = SoA_facingDirection[y] as u8;
        if a == Direction.EAST as u8 {
            carry = vision_cone.test_right(y);
            if !carry {
                return _attack_recovery_ended(y);
            }
        }
        else if a == Direction.WEST as u8 {
            carry = vision_cone.test_left(y);
            if !carry {
                return _attack_recovery_ended(y);
            }
        }
        else if a == Direction.NORTH as u8 {
            carry = vision_cone.test_up(y);
            if !carry {
                return _attack_recovery_ended(y);
            }
        }
        else {
            carry = vision_cone.test_down(y);
            if !carry {
                return _attack_recovery_ended(y);
            }
        }

        // Player is still in vision code, fire bolt on next frame
        _set_state__attacking__immediate(y);
    }

    return true;
}



// DB = 0x7e
#[mem8, idx8]
func _attack_recovery_ended(enttyId : u8 in y) : bool in carry {
    // Continue walking in the same direction the enemy was walking before they saw the player.
    ^return set_state__walk(y, SoA_walkingDirection[y] as u8);
}



// Hurt
// ====



// KEEP: Y
//
// DB = 0x7e
#[mem8, idx8]
func collided_with_player_weapon(entityId : u8 in y) {
    // Change state to HURT if player is not facing the enemy's shield.

    x = player.facingDirection;

    a = SoA_facingDirection[y] as u8;
    if a == Direction.EAST as u8 {
        if x != player.FacingDirection.LEFT as u8 {
            return set_state__hurt(y);
        }
    }
    else if a == Direction.WEST as u8 {
        if x != player.FacingDirection.RIGHT as u8 {
            return set_state__hurt(y);
        }
    }
    else if a == Direction.NORTH as u8 {
        if x != player.FacingDirection.DOWN as u8 {
            return set_state__hurt(y);
        }
    }
    else {
        // Direction.SOUTH
        if x != player.FacingDirection.UP as u8 {
            return set_state__hurt(y);
        }
    }

    return set_state__blocking(y);
}



// ASSUMES: entity collided with sword hitbox and `collisionCentre` is valid.
//
// KEEP: Y
//
// DB = 0x7e
#[mem8, idx8]
func set_state__hurt(entityId : u8 in y) {
    a = State.HURT as u8;
    SoA_state[y] = a as State;

    SoA_countdownTimer[y] = a = HURT_KNOCKBACK_TIME_IN_FRAMES;

    ^return base.take_damage_from_player_sword_with_knockback(y, base.SwordCollisionSpeed.EXTRA_FAST);
}



// DB = 0x7e
#[mem8, idx8]
func process__hurt(entityId : u8 in y) : bool in carry {

    a = SoA_countdownTimer[y];
    if !zero {
        a--;
        SoA_countdownTimer[y] = a;
    }
    else {
        ^return set_state__hurt_cooldown(y);
    }

    return true;
}



// Blocking
// ========



// ASSUMES: entity collided with sword hitbox and `collisionCentre` is valid.
//
// KEEP: Y
//
// DB = 0x7e
#[mem8, idx8]
func set_state__blocking(entityId : u8 in y) {
    a = State.BLOCKING as u8;
    SoA_state[y] = a as State;

    SoA_countdownTimer[y] = a = BLOCKING_KNOCKBACK_TIME_IN_FRAMES;

    ^return base.set_velocity_after_player_sword_collision(y, base.SwordCollisionSpeed.SLOWER);
}


let process__blocking = process__hurt;



// Hurt Cool-down
// ==============

// KEEP: Y
// DB = 0x7e
#[mem8, idx8]
func set_state__hurt_cooldown(entityId : u8 in y) : bool in carry {
    a = State.HURT_COOLDOWN as u8;
    SoA_state[y] = a as State;

    mem16();
    #[mem16] {
        x = y;
        SoA.xVelocity[unaligned x] = 0;
        SoA.yVelocity[unaligned x] = 0;
    }
    mem8();

    SoA_countdownTimer[y] = a = HURT_COOLDOWN_DELAY;

    return true;
}



// DB = 0x7e
#[mem8, idx8]
func process__hurt_cooldown(entityId : u8 in y) : bool in carry {

    a = SoA_countdownTimer[y];
    if !zero {
        a--;
        SoA_countdownTimer[y] = a;
    }
    else {

        ^return set_state__walk(y, SoA_walkingDirection[y] as u8);
    }

    return true;
}



}

}
}

