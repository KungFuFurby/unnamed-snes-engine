// Copyright (c) 2021, Marcus Rowe <undisbeliever@gmail.com>.
// Distributed under The MIT License, see the LICENSE file for more details.

import "../memmap";

import "_variables";

import "../metatiles";
import "../../wiz/common/snes/snes";
import "../../gen/metasprites/common";


namespace entities {
namespace player {


let ms_draw_function = ms.common.Player.draw_function;
let ms_frame_table = ms.common.Player.frame_table;


let PLAYER_ENTITY_ID = 0;


let ATTACK_BUTTON_H = snes.joy.mask_h.Y;


// (8:8 unsigned fixed point)
let WALK_VELOCITY = 0x0160;


// (pixels)
let HURT_DIAGONAL_CHECK = 2;

// (8:8 unsigned fixed point)
let HURT_PUSHBACK_VELOCITY = 0x0055;


// Pixels the player is to transverse before incrementing `animationFrame`
// (8:8 unsigned fixed point)
let WALK_ANIMATION_FRAME_DISTANCE = 0x0980;

let ATTACK_ANIMATION_FRAME_DELAY = 4;


// (frames)
let HURT_STATE_DURATION     = 15;


let N_WALK_FRAMES           = 4;

let FIRST_ATTACK_FRAME      = 4;
let N_ATTACK_FRAMES         = 4;


// ::TODO draw hurt frame ::
let HURT_ANIMATION_FRAME    = 2;



// Hardcoded player hurtbox offsets
let HURTBOX_LEFT_OFFSET = 3;
let HURTBOX_RIGHT_OFFSET = 3;
let HURTBOX_TOP_OFFSET = 2;
let HURTBOX_BOTTOM_OFFSET = 2;


// The direction the player is facing
// (used to calculate `metaSpriteFrame`)
enum FacingDirection : u8 {
    DOWN,
    UP,
    RIGHT,
    LEFT,
};

let FACING_DIRECTION_SHIFT = 3;



enum State : u8 {
    WALKING,
    ATTACKING,
    HURT,
};



let xPos = entities.SoA.xPos[0];
let yPos = entities.SoA.yPos[0];

let xVelocity = entities.SoA.xVelocity[0];
let yVelocity = entities.SoA.yVelocity[0];

let movementState = entities.SoA.movementState[0];


let state                 = <:entities.SoA.state_0[0];
let facingDirection       = >:entities.SoA.state_0[0];

// Current animation frame
let animationFrame        = <:entities.SoA.state_1[0];

// Timer used to delay the next animation frame
// (0:8:8 fixed point)
let animationFrameDelay = entities.SoA.state_2[0];



// DATA
// ====

in rodata0 {


// ::TODO improve sword hitbox::

// Hitbox
//
// NOTE: if the `top` byte of hitbox is 0 then there is no hitbox.
//
// (SoA x 4 signed 8 bit integer)
namespace Hitbox {
    //                      south,        attack_south,         north,        attack_north,         east,         attack_east,          west,         attack_west
    const _top    : [i8] = [ 0, 0, 0, 0,    -7,  -3,  -1,  -1,   0, 0, 0, 0,   -13, -15, -17, -17,   0, 0, 0, 0,    -5,  -5,  -5,  -5,   0, 0, 0, 0,    -5,  -5,  -5,  -5,  ];
    const _bottom : [i8] = [ 0, 0, 0, 0,     2,   6,  10,  10,   0, 0, 0, 0,    -6,  -6,  -5,  -5,   0, 0, 0, 0,     2,   2,   2,   2,   0, 0, 0, 0,     2,   2,   2,   2,  ];
    const _left   : [i8] = [ 0, 0, 0, 0,   -12, -11,  -4,  -3,   0, 0, 0, 0,     4,   4,  -2,  -2,   0, 0, 0, 0,     0,   2,   2,   2,   0, 0, 0, 0,    -5, -13, -15, -15,  ];
    const _right  : [i8] = [ 0, 0, 0, 0,    -3,  -4,   2,   2,   0, 0, 0, 0,    15,  12,   4,   3,   0, 0, 0, 0,     5,  13,  15,  15,   0, 0, 0, 0,     0,  -2,  -2,  -2,  ];


    let top    = far &_top as far *const i8;
    let bottom = far &_bottom as far *const i8;
    let left   = far &_left as far *const i8;
    let right  = far &_right as far *const i8;
}

}


// CODE
// ====



in code {



// Initialize player.
//
// Only called once at the start of the game.
//
// DB = 0x7e
#[mem8, idx8]
inline func init() {

    a = ShadowSize.MEDIUM as u8;
    entities.SoA.shadowSize[0] = a as ShadowSize;

    xPos.px = a = 128;
    yPos.px = a = 112;

    SoA.tileHitbox_halfWidth[0] = a = 6;
    SoA.tileHitbox_halfHeight[0] = a = 3;


    mem16();
    #[mem16] {
        entities.SoA.xVelocity[0] = 0;
        entities.SoA.yVelocity[0] = 0;
    }
    mem8();


    facingDirection = a = FacingDirection.UP as u8;

    set_state__walking();

    update_metasprite_frame();
}



// Entity process routine.
//
// Called once per frame.
//
// INPUT: entityId (x) is always 0
//
// DB = 0x7e
#[mem8, idx8]
func process(entityId : u8 in x) {

    a = state as u8;
    if a == State.ATTACKING as u8 {
        process__attack();
    }
    else if a == State.HURT as u8 {
        process__hurt();
    }
    else {
        // state == WALKING
        process__walking();
    }

    metatiles.move_entity_and_collision_test(PLAYER_ENTITY_ID);


    // Update animation
    a = state as u8;
    if a == State.ATTACKING as u8 {
        update_animation__attacking();
    }
    else if a == State.HURT as u8 {
        update_animation__hurt();
    }
    else {
        // state == WALKING
        update_animation__walking();
    }
}



// Called whenever an entity collides with the player's hurtbox.
//
// PARAM: entityId - the entity that collided with `playerHurtbox`.
//
// DB = 0x7e
#[mem8, idx8]
inline func hurtbox_collided_with_entity__inline(entityId : u8 in x) {
    a = state as u8;
    if a != State.HURT as u8 {
        _set_state__hurt(x, a);
    }
}



// Called whenever an entity collides with the player's hitbox.
//
// PARAM: entityId - the entity that collided with `playerHitbox`.
//
// DB = 0x7e
#[mem8, idx8]
inline func hitbox_collided_with_entity__inline(entityId : u8 in x) {
    // ::TODO implement::
}




// Collisions
// ==========


// Update `playerHurtbox`.
//
// Called once per frame
//
// DB = 0x7e
#[mem8, idx8]
inline func update_player_hurtbox() {
    a = xPos.px - player.HURTBOX_LEFT_OFFSET;
    if !carry {
        a = 0;
    }
    playerHurtbox.left = a;

    a = xPos.px + player.HURTBOX_RIGHT_OFFSET;
    if carry {
        a = 0xff;
    }
    playerHurtbox.right = a;

    a = yPos.px - player.HURTBOX_TOP_OFFSET;
    if !carry {
        a = 0;
    }
    playerHurtbox.top = a;

    a = yPos.px + player.HURTBOX_BOTTOM_OFFSET;
    if carry {
        a = 0xff;
    }
    playerHurtbox.bottom = a;
}



// Update player hitbox
//
// Called once per frame
//
// DB = 0x7e
#[mem8, idx8]
inline func update_player_hitbox() {
    x = entities.SoA.metaSpriteFrame[PLAYER_ENTITY_ID];


    a = Hitbox.top[x] as u8;
    if zero {
        a = 0xff;
        playerHitbox.top = a;
        playerHitbox.bottom = 0;
        playerHitbox.left = a;
        playerHitbox.right = 0;

        return;
    }


    // Add i8 signed Hitbox.top[x] to player's u8 unsigned Y position (with clamping)
    // a = top
    if negative {
        a += yPos.px;
        if !carry {
            a = 0;
        }
    }
    else {
        a += yPos.px;
        if carry {
            a = 0xff;
        }
    }
    playerHitbox.top = a;


    a = Hitbox.bottom[x] as u8;
    if negative {
        a += yPos.px;
        if !carry {
            a = 0;
        }
    }
    else {
        a += yPos.px;
        if carry {
            a = 0xff;
        }
    }
    playerHitbox.bottom = a;

    a = Hitbox.left[x] as u8;
    if negative {
        a += xPos.px;
        if !carry {
            a = 0;
        }
    }
    else {
        a += xPos.px;
        if carry {
            a = 0xff;
        }
    }
    playerHitbox.left = a;


    a = Hitbox.right[x] as u8;
    if negative {
        a += xPos.px;
        if !carry {
            a = 0;
        }
    }
    else {
        a += xPos.px;
        if carry {
            a = 0xff;
        }
    }
    playerHitbox.right = a;
}




// PROCESS MOVEMENT
// ================


// Process player direction and update velocity.
//
// DB = 0x7e
#[mem8, idx8]
func process_dpad_update_velocity() {

    // ::TODO add proper controller support::
    a = *far &snes.joy.pad1_h;

    if a & snes.joy.mask_h.UP != 0 {
        if a & snes.joy.mask_h.LEFT != 0 {
            ^return process_direction_north_west();
        }
        if a & snes.joy.mask_h.RIGHT != 0 {
            ^return process_direction_north_east();
        }
        ^return process_direction_north();
    }

    if a & snes.joy.mask_h.DOWN != 0 {
        if a & snes.joy.mask_h.LEFT != 0 {
            ^return process_direction_south_west();
        }
        if a & snes.joy.mask_h.RIGHT != 0{
            ^return process_direction_south_east();
        }
        ^return process_direction_south();
    }

    if a & snes.joy.mask_h.LEFT != 0 {
        ^return process_direction_west();
    }

    if a & snes.joy.mask_h.RIGHT != 0{
        ^return process_direction_east();
    }

    return process_direction_stationary();
}



// DB = 0x7e
#[mem8, idx8]
func process_direction_stationary() {
    // Do not change facingDirection

    zero_x_velocity();
    zero_y_velocity();
}



// DB = 0x7e
#[mem8, idx8]
func process_direction_north() {
    facingDirection = a = FacingDirection.UP as u8;

    zero_x_velocity();
    decrement_y_velocity();
}



// DB = 0x7e
#[mem8, idx8]
func process_direction_north_east() {
    a = facingDirection;
    if a == FacingDirection.LEFT as u8 {
        facingDirection = a = FacingDirection.UP as u8;
    }
    if a == FacingDirection.DOWN as u8 {
        facingDirection = a = FacingDirection.RIGHT as u8;
    }

    increment_x_velocity();
    decrement_y_velocity();
}



// DB = 0x7e
#[mem8, idx8]
func process_direction_east() {
    facingDirection = a = FacingDirection.RIGHT as u8;

    increment_x_velocity();
    zero_y_velocity();
}



// DB = 0x7e
#[mem8, idx8]
func process_direction_south_east() {
    a = facingDirection;
    if a == FacingDirection.LEFT as u8 {
        facingDirection = a = FacingDirection.DOWN as u8;
    }
    if a == FacingDirection.UP as u8 {
        facingDirection = a = FacingDirection.RIGHT as u8;
    }

    increment_x_velocity();
    increment_y_velocity();
}



// DB = 0x7e
#[mem8, idx8]
func process_direction_south() {
    facingDirection = a = FacingDirection.DOWN as u8;

    zero_x_velocity();
    increment_y_velocity();
}



// DB = 0x7e
#[mem8, idx8]
func process_direction_south_west() {
    a = facingDirection;
    if a == FacingDirection.RIGHT as u8 {
        facingDirection = a = FacingDirection.DOWN as u8;
    }
    if a == FacingDirection.UP as u8 {
        facingDirection = a = FacingDirection.LEFT as u8;
    }

    decrement_x_velocity();
    increment_y_velocity();
}



// DB = 0x7e
#[mem8, idx8]
func process_direction_west() {
    facingDirection = a = FacingDirection.LEFT as u8;

    decrement_x_velocity();
    zero_y_velocity();
}



// DB = 0x7e
#[mem8, idx8]
func process_direction_north_west() {
    a = facingDirection;
    if a == FacingDirection.RIGHT as u8 {
        facingDirection = a = FacingDirection.UP as u8;
    }
    if a == FacingDirection.DOWN as u8 {
        facingDirection = a = FacingDirection.LEFT as u8;
    }

    decrement_x_velocity();
    decrement_y_velocity();
}



// DB = 0x7e
#[mem8, idx8]
func decrement_x_velocity() {

    // ::TODO add acceleration and friction::
    <:xVelocity = a = <:-WALK_VELOCITY;
    >:xVelocity = a = >:-WALK_VELOCITY;
}



// DB = 0x7e
#[mem8, idx8]
func zero_x_velocity() {

    // ::TODO add friction::
    <:xVelocity = 0;
    >:xVelocity = 0;
}



// DB = 0x7e
#[mem8, idx8]
func increment_x_velocity() {

    // ::TODO add acceleration and friction::
    <:xVelocity = a = <:WALK_VELOCITY;
    >:xVelocity = a = >:WALK_VELOCITY;
}



// DB = 0x7e
#[mem8, idx8]
func decrement_y_velocity() {

    // ::TODO add acceleration and friction::
    <:yVelocity = a = <:-WALK_VELOCITY;
    >:yVelocity = a = >:-WALK_VELOCITY;
}



// DB = 0x7e
#[mem8, idx8]
func zero_y_velocity() {

    // ::TODO add friction::
    <:yVelocity = 0;
    >:yVelocity = 0;
}



// DB = 0x7e
#[mem8, idx8]
func increment_y_velocity() {

    // ::TODO add acceleration and friction::
    <:yVelocity = a = <:WALK_VELOCITY;
    >:yVelocity = a = >:WALK_VELOCITY;
}



// WALKING STATE
// =============


// DB = 0x7e
#[mem8, idx8]
func set_state__walking() {
    state = State.WALKING as u8;


    animationFrame = 0;

    <:animationFrameDelay = 0;
    >:animationFrameDelay = 0;
}



// DB = 0x7e
#[mem8, idx8]
func process__walking() {
    process_dpad_update_velocity();


    // ::TODO add proper controller support::
    a = *far &snes.joy.pad1_h;
    if a & ATTACK_BUTTON_H != 0 {
        set_state__attacking();
    }
}



// Update animation frame for WALKING state.
//
// DB = 0x7e
#[mem8, idx8]
func update_animation__walking() {

let _tmp = dpTmp0;

    mem16();
    #[mem16] {

        // aa = max(abs(xVelocity), abs(yVelocity))
        {
            aa = xVelocity;
            if negative {
                // negate
                aa ^= 0xffff;
                aa++;
            }
            _tmp = aa;

            aa = yVelocity;
            if negative {
                // negate
                aa ^= 0xffff;
                aa++;
            }

            if aa < _tmp {
                aa = _tmp;
            }
        }

        if aa == 0 {
            // No movement: force standing frame

            animationFrame = y = 0;
            animationFrameDelay = 0;
        }
        else {
            // Movement

            aa += animationFrameDelay;
            if aa >= WALK_ANIMATION_FRAME_DISTANCE {
                aa = 0;

                // increment animationFrame (with wrapping)
                y = animationFrame;
                y++;
                if y >= N_WALK_FRAMES {
                    y = 0;
                }
                animationFrame = y;
            }

            animationFrameDelay = aa;
        }
    }
    mem8();

    return update_metasprite_frame();
}



// Calculate metaSpriteFrame value
//
// DB = 0x7e
#[mem8, idx8]
func update_metasprite_frame() {

    a = ((facingDirection as u8) <<< FACING_DIRECTION_SHIFT) | animationFrame;

    entities.SoA.metaSpriteFrame[PLAYER_ENTITY_ID] = a;
}



// ATTACKING STATE
// ===============


// DB = 0x7e
#[mem8, idx8]
func set_state__attacking() {
    state = a = State.ATTACKING as u8;

    // Stand still while attacking
    <:xVelocity = 0;
    >:xVelocity = 0;
    <:yVelocity = 0;
    >:yVelocity = 0;

    animationFrame = a = FIRST_ATTACK_FRAME;
    <:animationFrameDelay = a = ATTACK_ANIMATION_FRAME_DELAY - 1;
}



// DB = 0x7e
#[mem8, idx8]
func process__attack() {

    a = animationFrame;
    if a == FIRST_ATTACK_FRAME + N_ATTACK_FRAMES {
        ^return set_state__walking();
    }
}



// DB = 0x7e
#[mem8, idx8]
func update_animation__attacking() {

    (<:animationFrameDelay)--;
    if negative {
        <:animationFrameDelay = a = ATTACK_ANIMATION_FRAME_DELAY - 1;

        animationFrame++;
    }

    return update_metasprite_frame();
}



// HURT STATE
// ==========


// DB = 0x7e
#[mem8, idx8]
func _set_state__hurt(entityId : u8 in x, oldState : u8 in a) {
    state = a = State.HURT as u8;


    // ::TODO improve pushback direction test ::

    a = xPos.px;
    if a >= SoA.xPos_px[unaligned x] {
        a = >:HURT_PUSHBACK_VELOCITY;
        y = <:HURT_PUSHBACK_VELOCITY;
    }
    else {
        a = >:(-HURT_PUSHBACK_VELOCITY);
        y = <:(-HURT_PUSHBACK_VELOCITY);
    }
    >:xVelocity = a;
    <:xVelocity = y;

    a = yPos.px;
    if a >= SoA.yPos_px[unaligned x] {
        a = >:HURT_PUSHBACK_VELOCITY;
        y = <:HURT_PUSHBACK_VELOCITY;
    }
    else {
        a = >:(-HURT_PUSHBACK_VELOCITY);
        y = <:(-HURT_PUSHBACK_VELOCITY);
    }
    >:yVelocity = a;
    <:yVelocity = y;


    <:animationFrameDelay = a = HURT_STATE_DURATION;


    animationFrame = a = HURT_ANIMATION_FRAME;
    ^return update_metasprite_frame();
}



// DB = 0x7e
#[mem8, idx8]
func process__hurt() {
    // Frozen until `animationFrameDelay` ends
    (<:animationFrameDelay)--;
    if negative {
        set_state__walking();
    }
}



// DB = 0x7e
#[mem8, idx8]
func update_animation__hurt() {
}


}

}
}

