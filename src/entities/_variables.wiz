// Copyright (c) 2021, Marcus Rowe <undisbeliever@gmail.com>.
// Distributed under The MIT License, see the LICENSE file for more details.

import "../memmap";

namespace entities {
    let N_ENTITIES = 12;

    struct pos {
        sx : u8,
        px : u8
    };

    enum ShadowSize : u8 {
        // Deleted entities MUST NOT have a shadow
        NONE,

        SMALL,
        MEDIUM,
        LARGE,
    };

    namespace MovementState {
        let RIGHT_COLLISION = 1 << 0;
        let LEFT_COLLISION  = 1 << 1;
        let UP_COLLISION    = 1 << 2;
        let DOWN_COLLISION  = 1 << 3;

        let X_AXIS_COLLISION = RIGHT_COLLISION | LEFT_COLLISION;
        let Y_AXIS_COLLISION = UP_COLLISION | DOWN_COLLISION;
    };

    struct _ShadowAndBlank {
        shadowSize : ShadowSize,

        // ::TODO use this variable for something::
        _blank : u8
    };

    struct _u8pair {
        first : u8,
        second : u8,
    }

    // Entity 0 is always the player
    namespace SoA {
        let LAST_INDEX = (N_ENTITIES - 1) * 2;

        in shadow {
            // Process function for the entity.  Called once per frame by the undo loop.
            //
            // INPUT: X = entityId: index into `entities.SoA` Structure-of-Arrays.
            // RETURN: carry set if entity is still active in the next frame.
            //
            // DB = 0x7e
            #[mem8, idx8]
            var process_function : [func(entityId : u8 in x) : bool in carry ; N_ENTITIES];


            // Metasprite draw function.
            //
            // INPUT: Y = entityId: index into `entities.SoA` Structure-of-Arrays.
            //
            // DB = 0x7e
            #[mem8, idx8]
            var ms_draw_function : [func(entityId : u16 in yy) ; N_ENTITIES];
        }

        in wram7e {
            var xPos : [pos ; N_ENTITIES];
            let xPos_u16 = &xPos[0].sx as *u16;
            let xPos_sx = &xPos[0].sx as *u8;
            let xPos_px = &xPos[0].px as *u8;

            var yPos : [pos ; N_ENTITIES];
            let yPos_u16 = &yPos[0].sx as *u16;
            let yPos_sx = &yPos[0].sx as *u8;
            let yPos_px = &yPos[0].px as *u8;


            var _shadowAndBlank : [_ShadowAndBlank ; N_ENTITIES];
            let shadowSize = &_shadowAndBlank[0].shadowSize as *ShadowSize;


            // MetaSprite frame table address.
            // Points to a addr table of `metasprites.MsDataFormat` data structure
            var metaSpriteFrameTable : [u16 ; N_ENTITIES];

            // Current MetaSprite frame.
            // Points to a `metasprites.MsDataFormat` data structure
            var metaSpriteFrame : [u16 ; N_ENTITIES];


            // Signed 16 bit X velocity
            var xVelocity : [ u16 ; N_ENTITIES ];
            let xVelocity_sx = &<:xVelocity[0] as *u8;
            let xVelocity_px = &>:xVelocity[0] as *u8;

            // Signed 16 bit Y velocity
            var yVelocity : [ u16 ; N_ENTITIES ];
            let yVelocity_sx = &<:yVelocity[0] as *u8;
            let yVelocity_px = &>:yVelocity[0] as *u8;


            var tileHitbox : [ _u8pair ; N_ENTITIES ];
            let tileHitbox_halfWidth  = &tileHitbox[0].first as *u8;
            let tileHitbox_halfHeight = &tileHitbox[0].second as *u8;


            var _movementStateAndBlank : [ u16 ; N_ENTITIES ];

            // Updated by `metatiles.move_entity_and_collision_test`
            // (bitfield of `entities.MovementState`)
            let movementState = &<:_movementStateAndBlank[0] as *u8;


            // Variables used to store the entity's state between `process_function` calls
            //
            // NOTE: if I add more states here then I need to clear them in `spawn_entity`
            var state_0 : [ u16 ; N_ENTITIES ];
            var state_1 : [ u16 ; N_ENTITIES ];
            var state_2 : [ u16 ; N_ENTITIES ];
            var state_3 : [ u16 ; N_ENTITIES ];
            var state_4 : [ u16 ; N_ENTITIES ];
            var state_5 : [ u16 ; N_ENTITIES ];
            var state_6 : [ u16 ; N_ENTITIES ];
            var state_7 : [ u16 ; N_ENTITIES ];


            // Split state variables into low/high pairs (to easily allocate a byte variable)
            let state_0_l = &<:state_0[0] as *u8;
            let state_0_h = &>:state_0[0] as *u8;

            let state_1_l = &<:state_1[0] as *u8;
            let state_1_h = &>:state_1[0] as *u8;

            let state_2_l = &<:state_2[0] as *u8;
            let state_2_h = &>:state_2[0] as *u8;

            let state_3_l = &<:state_3[0] as *u8;
            let state_3_h = &>:state_3[0] as *u8;
        }
    }


    in wram7e {
        // Mapping of active and unused entities (excluding player).
        //
        // indexes 0 to `activeEntitiesTablePos - 1` (inclusive) are active entityIds.
        // indexes `activeEntitiesTablePos` to `ACTIVE_ENTITIES_TABLE__LAST_POS` (inclusive) are unused entities.
        //
        // This table will never include the player entity (entityId 0)
        //
        // (list of SoA indexes)
        var activeEntitiesTable : [u8 ; N_ENTITIES - 1];

        // The mid-point separating active and unused entities in `activeEntitiesTable`.
        //
        // This value is set to 0 if no entities are active.
        // This value is set to `ACTIVE_ENTITIES_TABLE__LAST_POS` when no more entities can be created.
        //
        // (index into activeEntitiesTable)
        var activeEntitiesTablePos : u8;

        let ACTIVE_ENTITIES_TABLE__LAST_POS = sizeof(typeof(activeEntitiesTable)) - 1;
    }
}


