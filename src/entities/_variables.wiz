// Copyright (c) 2021, Marcus Rowe <undisbeliever@gmail.com>.
// Distributed under The MIT License, see the LICENSE file for more details.

import "../memmap";
import "../metasprites";


namespace entities {
    let N_ENTITIES = 12;

    struct pos {
        sx : u8,
        px : u8
    };

    enum ShadowSize : u8 {
        // Deleted entities MUST NOT have a shadow
        NONE,

        SMALL,
        MEDIUM,
        LARGE,
    };

    namespace MovementState {
        let RIGHT_COLLISION = 1 << 0;
        let LEFT_COLLISION  = 1 << 1;
        let UP_COLLISION    = 1 << 2;
        let DOWN_COLLISION  = 1 << 3;

        let X_AXIS_COLLISION = RIGHT_COLLISION | LEFT_COLLISION;
        let Y_AXIS_COLLISION = UP_COLLISION | DOWN_COLLISION;
    };

    namespace CollisionState {
        let PLAYER_WEAPON   = 1 << 7;
        let PLAYER_HURTBOX  = 1 << 6;

        let PLAYER_WEAPON_BIT   = 7;
        let PLAYER_HURTBOX_BIT  = 6;
    };


    struct _u8pair {
        first : u8,
        second : u8,
    };

    struct U8Aabb {
        left : u8,
        right : u8,
        top : u8,
        bottom : u8,
    };


    in zeropage {
        // The entityId of the current entity
        //
        // This variable is only valid during an entity's process function.
        //
        // (byte index)
        var currentEntityId : u8;


        // The player's hurtbox
        var playerHurtbox : U8Aabb;

        // The player's hitbox
        var playerHitbox : U8Aabb;



        // Collision flags
        // (bitfield of `entities.CollisionState`)
        var collisionState : u8;
    }


    // Entity 0 is always the player
    namespace SoA {
        let LAST_INDEX = (N_ENTITIES - 1) * 2;

        in shadow {
            // Process function for the entity.  Called once per frame by the undo loop.
            //
            // INPUT: X = entityId: index into `entities.SoA` Structure-of-Arrays.
            // RETURN: carry set if entity is still active in the next frame.
            //
            // NOTE: `currentEntityId` will contain a copy of `entityId` to provide an easy
            //       way to restore the X register if it gets overwritten.
            //
            // NOTE: The player entity (entityId 0) MUST NOT change this variable.
            //
            // DB = 0x7e
            #[mem8, idx8]
            var process_function : [func(entityId : u8 in x) : bool in carry ; N_ENTITIES];


            // Metasprite draw function.
            //
            // INPUT: Y = entityId: index into `entities.SoA` Structure-of-Arrays.
            //
            // DB = 0x7e
            #[mem8, idx8]
            var ms_draw_function : [func(msFrame : u16 in yy, xPos : u16 in metasprites.xPos, yPos : u16 in metasprites.yPos) ; N_ENTITIES];
        }

        in wram7e {
            var xPos : [pos ; N_ENTITIES];
            let xPos_u16 = &xPos[0].sx as *u16;
            let xPos_sx = &xPos[0].sx as *u8;
            let xPos_px = &xPos[0].px as *u8;

            var yPos : [pos ; N_ENTITIES];
            let yPos_u16 = &yPos[0].sx as *u16;
            let yPos_sx = &yPos[0].sx as *u8;
            let yPos_px = &yPos[0].px as *u8;


            var _zPosAndShadow : [_u8pair ; N_ENTITIES];

            // Z position of the entity
            // (byte)
            let zPos = &_zPosAndShadow[0].first as *u8;


            // The size of the shadow underneath the entity
            let shadowSize = &_zPosAndShadow[0].second as *ShadowSize;


            // MetaSprite frame table address.
            // Points to a addr table of `metasprites.MsDataFormat` data structure
            var metaSpriteFrameTable : [u16 ; N_ENTITIES];


            var __msFrameAndBlank : [ _u8pair ; N_ENTITIES];

            // Current MetaSprite frame.
            //
            // You SHOULD NOT be writing to this variable.
            // Instead you SHOULD call `metasprites.set_entity_frame()` to change
            // the entity's MetaSprite frame.
            //
            // This value is safe to read.
            //
            // (byte)
            let metaSpriteFrame = &__msFrameAndBlank[0].first as *u8;


            // Signed 16 bit X velocity
            var xVelocity : [ u16 ; N_ENTITIES ];
            let xVelocity_sx = &<:xVelocity[0] as *u8;
            let xVelocity_px = &>:xVelocity[0] as *u8;

            // Signed 16 bit Y velocity
            var yVelocity : [ u16 ; N_ENTITIES ];
            let yVelocity_sx = &<:yVelocity[0] as *u8;
            let yVelocity_px = &>:yVelocity[0] as *u8;


            var tileHitbox : [ _u8pair ; N_ENTITIES ];
            let tileHitbox_halfWidth  = &tileHitbox[0].first as *u8;
            let tileHitbox_halfHeight = &tileHitbox[0].second as *u8;


            var _movementStateAndBlank : [ u16 ; N_ENTITIES ];

            // Updated by `metatiles.move_entity_and_collision_test` or `entities.base.process_collisions`
            // (bitfield of `entities.MovementState`)
            let movementState = &<:_movementStateAndBlank[0] as *u8;


            var _healthAndIframeCounter : [ _u8pair ; N_ENTITIES ];

            // Entity health
            let health = &_healthAndIframeCounter[0].first as *u8;

            // Updated by `base.process_collisions`
            // Invincibility frames counter
            let iframeCounter = &_healthAndIframeCounter[0].second as *u8;


            // Variables used to store the entity's state between `process_function` calls
            //
            // NOTE: if I add more states here then I need to clear them in `spawn_entity`
            var state_0 : [ u16 ; N_ENTITIES ];
            var state_1 : [ u16 ; N_ENTITIES ];
            var state_2 : [ u16 ; N_ENTITIES ];
            var state_3 : [ u16 ; N_ENTITIES ];
            var state_4 : [ u16 ; N_ENTITIES ];
            var state_5 : [ u16 ; N_ENTITIES ];
            var state_6 : [ u16 ; N_ENTITIES ];
            var state_7 : [ u16 ; N_ENTITIES ];


            // Split state variables into low/high pairs (to easily allocate a byte variable)
            let state_0_l = &<:state_0[0] as *u8;
            let state_0_h = &>:state_0[0] as *u8;

            let state_1_l = &<:state_1[0] as *u8;
            let state_1_h = &>:state_1[0] as *u8;

            let state_2_l = &<:state_2[0] as *u8;
            let state_2_h = &>:state_2[0] as *u8;

            let state_3_l = &<:state_3[0] as *u8;
            let state_3_h = &>:state_3[0] as *u8;
        }
    }


    in wram7e {
        // Mapping of active and unused entities (including player).
        //
        // indexes 0 to `numberOfActiveEntities - 1` (inclusive) are active entityIds.
        // indexes `numberOfActiveEntities` to `ACTIVE_ENTITIES_TABLE__LAST_POS` (inclusive) are unused entities.
        //
        // (list of SoA indexes)
        var activeEntitiesTable : [u8 ; N_ENTITIES];


        // The number of active entities.
        //
        // This variable is used as the mid-point separating active and unused entities in `activeEntitiesTable`.
        //
        // This variable is set to 1 if only the player entity is active.
        // This variable is set to `ACTIVE_ENTITIES_TABLE__LAST_POS` when no more entities can be created.
        //
        // This variable MUST NEVER BE zero.
        //
        // (byte counter)
        var numberOfActiveEntities : u8;


        let ACTIVE_ENTITIES_TABLE__LAST_POS = sizeof(typeof(activeEntitiesTable)) - 1;
    }
}


