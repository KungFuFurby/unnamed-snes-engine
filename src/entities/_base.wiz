// Copyright (c) 2022, Marcus Rowe <undisbeliever@gmail.com>.
// Distributed under The MIT License, see the LICENSE file for more details.


import "../memmap";

import "_variables";
import "_common";

import "dead";


import "../metatiles";
import "../metasprites";
import "../common/math";


import "../../gen/cosine-tables";


let N_INVINCIBILITY_FRAMES = 20;




namespace entities {
namespace base {


in zeropage {
    // Centre of the collision (if one occurs)
    var collisionCentre_x : u8;
    var collisionCentre_y : u8;
}


in rodata0 {
    // Table of Cosine tables for each `set_velocity_after_player_sword_collision` collisionSpeed.
    const _SwordStrikeCosineTables : [*[ i16 ; 32 ]] = [
        CosineTables.SwordStrike_Slower         as *[i16 ; 32],
        CosineTables.SwordStrike_Slow           as *[i16 ; 32],
        CosineTables.SwordStrike_Medium         as *[i16 ; 32],
        CosineTables.SwordStrike_Fast           as *[i16 ; 32],
        CosineTables.SwordStrike_ExtraFast      as *[i16 ; 32],
        CosineTables.SwordStrike_FastFastFast   as *[i16 ; 32],
    ];
    let SwordStrikeCosineTables = far &_SwordStrikeCosineTables as far *const * const i16;
};


// Named Indexes into `SwordStrikeCosineTables`
namespace SwordCollisionSpeed {
    let SLOWER         = 0;
    let SLOW           =  2;
    let MEDIUM         =  4;
    let FAST           =  6;
    let EXTRA_FAST     =  8;
    let FAST_FAST_FAST = 10;
}


in code {



// Hurt the player from a collision.
//
// KEEP: Y
//
// DB = 0x7e
#[mem8, idx8]
#[fallthrough]
func hurt_player__collision(entityId : u8 in y) {

    a = SoA.attackPower[y];
}

// Hurt the player from a collision with a custom attack power stat.
//
// KEEP: Y
//
// DB = 0x7e
#[mem8, idx8]
func hurt_player__collision__attack_power(entityId : u8 in y, attackPower : u8 in a) {

let _tmp = <:dpTmp0;

    x = SoA.iframeCounter[player.PLAYER_ENTITY_ID];
    if zero {
        // ::TODO add different types of attacks and defences::

        _tmp = a;

        a = player.health - _tmp;
        if !carry {
            a = 0;
        }
        player.health = a;


        player.set_state_hurt__enemy_collision__inline(y);

        y = currentEntityId;
    }
}



// Take damage from the player's sword.
//
// KEEP: Y
//
// DB = 0x7e
#[mem8, idx8]
func take_damage_from_player_sword(entityId : u8 in y) {

    // ::TODO add different types of attacks and defences::

    // NOTE: If I change this function I MUST also change `take_damage_from_player_sword_with_knockback`

    a = SoA.health[y] - entities.player.swordAttackPower;
    if !carry {
        a = 0;
    }

    if zero {
        ^return entities.dead.change_to_dead_entity(y);
    }

    SoA.health[y] = a;
}



// Take damage from the player's sword and then call `set_velocity_after_player_sword_collision`.
//
// ASSUMES: entity collided with sword hitbox and `collisionCentre` is valid.
//
// KEEP: Y
//
// DB = 0x7e
#[mem8, idx8, fallthrough]
func take_damage_from_player_sword_with_knockback(entityId : u8 in y, collisionSpeed : u8 in x) {

    // ::TODO add different types of attacks and defences::


    // NOTE: If I change this function I MUST also change `take_damage_from_player_sword`

    // MUST NOT modify X

    a = SoA.health[y] - entities.player.swordAttackPower;
    if !carry {
        a = 0;
    }

    if zero {
        ^return entities.dead.change_to_dead_entity(y);
    }

    SoA.health[y] = a;

    return set_velocity_after_player_sword_collision(y, x);
}



// Change velocity of the entity based on the collisionCentre.
//
// ASSUMES: entity collided with sword hitbox and `collisionCentre` is valid.
//
// ASSUMES: collisionSpeed is a valid index into SwordStrikeCosineTables.
//
// PARAM: collisionSpeed - index into SwordStrikeCosineTables.
//
// KEEP: Y
//
// DB = 0x7e
#[mem8, idx8]
func set_velocity_after_player_sword_collision(entityId : u8 in y, collisionSpeed : u8 in x) {
let _farPtr = (*(&dpTmp_farPtr as *far *u16));

    mem16();
    #[mem16] {
        *(&_farPtr as *u16) = aa = SwordStrikeCosineTables[unaligned x] as u16;
        #:_farPtr = x = #:far &_SwordStrikeCosineTables;
    }
    mem8();

    y = x = calc_angle_32x2(a = player.xPos.px,
                            a = player.yPos.px,
                            collisionCentre_x,
                            collisionCentre_y);

    x = currentEntityId;

    mem16();
    #[mem16] {
        SoA.xVelocity[unaligned x] = aa = _farPtr[unaligned y];

        #[idx16] {
            yy = aa = (yy + CosineTables.SINE_OFFSET) & CosineTables.TABLE_MASK;
        }

        SoA.yVelocity[unaligned x] = aa = _farPtr[unaligned y];
    }
    mem8();

    y = x;
}





// Test for player collisions and tile collisions.
//
// The results of the collision tests will be stored in `collisionState`.
//
// If there is a player collision, the `entities.player.hitbox_collided_with_entity__inline()`
// or `entities.player.hurtbox_collided_with_entity__inline()` function will be called.
//
// Also updates `SoA.movementState`, `SoA.iframeCounter` and `SoA.health`.
//
// ASSUMES `entityId` is not player.
//
// KEEP: Y
// RETURN: collisionState
//
// DB = 0x7e
#[mem8, idx8]
func process_collisions(entityId : u8 in y) : u8 in y {

    y = metatiles.move_entity_and_collision_test__bounded(y);


    a = SoA.iframeCounter[y];
    if zero {
        // Only test for a player collision if not in iframe

        // Calculate entity's msFrameAddr
        // Extend 8 bit metaSpriteFrame to 16 bit AA
        #[mem16] {
            // DP = 0
            aa = direct_page;
        }
        a = entities.SoA.metaSpriteFrame[y];

        mem16_idx16();
        #[mem16, idx16] {
            // Safe: (aa << 1) will never set carry
            xx = aa = (aa << 1) +# entities.SoA.metaSpriteFrameTable[unaligned yy];
            xx = aa = metasprites.MetaSpriteFrameTableOffset[unaligned xx];
        }
        mem8();


        #[mem8, idx16] {
            // xx = msFrameAddr
            // yy = entityId

            carry = __test__entity_hurtbox__player_hitbox(yy, xx);
            if carry {
                // collided with player's attack

                mem8_idx8();
                #[mem8, idx8] {
                    entities.player.hitbox_collided_with_entity__inline(y);
                    y = currentEntityId;

                    // ::TODO Different iframe intervals for different entities::
                    // ::TODO Different iframe intervals for NTSC/PAL::
                    SoA.iframeCounter[y] = a = N_INVINCIBILITY_FRAMES;


                    // ::TODO decrement health::


                    collisionState = a = CollisionState.PLAYER_WEAPON;

                    return y;
                }
            }

            carry = __test__entity_hitbox__player_hurtbox(yy, xx);
            if carry {
                // Collided with player's hurtbox

                mem8_idx8();
                #[mem8, idx8] {
                    collisionState = a = CollisionState.PLAYER_HURTBOX;

                    return y;
                }
            }
        }
        mem8_idx8();
    }
    else {
        SoA.iframeCounter[y] = --a;
    }


    collisionState = 0;

    return y;
}



// COLLISION TESTS
// ===============


// Add the entity's unsigned xPos to a signed i8 accumulator with clamping.
//
// ASSUMES: negative flag contains the MSB of A (the previous instruction is an `lda`).
//
// KEEP: xx & yy
//
// DB = 0x7e
#[mem8, idx16]
inline func __add_xPos_to_i8a_clamp(a : u8 in a, n : bool in negative, entityId : u16 in yy) : u8 in a {
    if negative {
        a += entities.SoA.xPos_px[yy];
        return a if carry;
            a = 0;
    }
    else {
        a += entities.SoA.xPos_px[yy];
        return a if !carry;
            a = 0xff;
    }

    return a;
}


// Add the entity's unsigned yPos to a signed i8 accumulator with clamping.
//
// ASSUMES: negative flag contains the MSB of A (the previous instruction is an `lda`).
//
// KEEP: xx & yy
//
// DB = 0x7e
#[mem8, idx16]
inline func __add_yPos_to_i8a_clamp(i8a : u8 in a, n : bool in negative, entityId : u16 in yy) : u8 in a {
    if negative {
        a += entities.SoA.yPos_px[yy];
        return a if carry;
            a = 0;
    }
    else {
        a += entities.SoA.yPos_px[yy];
        return a if !carry;
            a = 0xff;
    }

    return a;
}



// Test for a collision between an entity's hurtbox and the player's hurtbox.
//
// NOTE: This function will NOT call the player collided callback.
//
// ASSUMES `entityId` is not player.
//
// KEEP: xx & yy
// RETURN: true if there is a collision
//
// DB = 0x7e
#[mem8, idx16]
func __test__entity_hitbox__player_hurtbox(entityId : u16 in yy, msFrameAddr : u16 in xx) : bool in carry {

let _hb_left   = <:dpTmp0;
let _hb_right  = <:dpTmp1;
let _hb_top    = <:dpTmp2;
let _tmp       = <:dpTmp3;


    // calculate entity hitbox left
    // Add i8 signed offset to entity's u8 unsigned position (with clamping)
    a = metasprites.MsDataFormat.hitbox_left[xx] as u8;
    if negative {
        // Putting the no-hitbox test here as it is faster.
        if a == metasprites.MsDataFormat.NO_AABB_VALUE {
            // MS frame has no hitbox
            return false;
        }

        a += entities.SoA.xPos_px[yy];
        if !carry {
            a = 0;
        }
    }
    else {
        a += entities.SoA.xPos_px[yy];
        if carry {
            a = 0xff;
        }
    }

    ^if a < playerHurtbox.right {
        _hb_left = a;

        a = metasprites.MsDataFormat.hitbox_right[xx] as u8;
        a = __add_xPos_to_i8a_clamp(a, negative, yy);
        if a >= playerHurtbox.left {
            _hb_right = a;

            a = metasprites.MsDataFormat.hitbox_top[xx] as u8;
            a = __add_yPos_to_i8a_clamp(a, negative, yy);
            if a < playerHurtbox.bottom {
                _hb_top = a;

                a = metasprites.MsDataFormat.hitbox_bottom[xx] as u8;
                a = __add_yPos_to_i8a_clamp(a, negative, yy);
                if a >= playerHurtbox.top {
                    // Calculate collision centre and return true
                    //   centre_y = avg(min(hb_bottom, player_bottom), max(hb_top, player_top))
                    //   centre_x = avg(min(hb_right, player_right), max(hb_left, player_left))

                    // a = _hb_bottom;
                    if a >= playerHurtbox.bottom {
                        a = playerHurtbox.bottom;
                    }
                    _tmp = a;

                    a = _hb_top;
                    if a < playerHurtbox.top {
                        a = playerHurtbox.top;
                    }
                    collisionCentre_y = a = (a + _tmp) >>>># 1;

                    a = _hb_right;
                    if a >= playerHurtbox.right {
                        a = playerHurtbox.right;
                    }
                    _tmp = a;

                    a = _hb_left;
                    if a < playerHurtbox.left {
                        a = playerHurtbox.left;
                    }
                    collisionCentre_x = a = (a + _tmp) >>>># 1;

                    return true;
                }
            }
        }
    }

    return false;
}



// Test for a collision between an entity's hurtbox and the player's hitbox.
//
// NOTE: This function will NOT call the player collided callback.
//
// ASSUMES `entityId` is not player.
//
// KEEP: xx & yy
// RETURN: true if there is a collision
//
// DB = 0x7e
#[mem8, idx16]
func __test__entity_hurtbox__player_hitbox(entityId : u16 in yy, msFrameAddr : u16 in xx) : bool in carry {

let _hb_left   = <:dpTmp0;
let _hb_right  = <:dpTmp1;
let _hb_top    = <:dpTmp2;
let _tmp       = <:dpTmp3;


    // calculate entity hurtbox left
    // Add i8 signed offset to entity's u8 unsigned position (with clamping)
    a = metasprites.MsDataFormat.hurtbox_left[xx] as u8;
    if negative {
        // Putting the no-hitbox test here as it is faster.
        if a == metasprites.MsDataFormat.NO_AABB_VALUE {
            // MS frame has no hitbox
            return false;
        }

        a += entities.SoA.xPos_px[yy];
        if !carry {
            a = 0;
        }
    }
    else {
        a += entities.SoA.xPos_px[yy];
        if carry {
            a = 0xff;
        }
    }

    ^if a < playerHitbox.right {
        _hb_left = a;

        a = metasprites.MsDataFormat.hurtbox_right[xx] as u8;
        a = __add_xPos_to_i8a_clamp(a, negative, yy);
        if a >= playerHitbox.left {
            _hb_right = a;

            a = metasprites.MsDataFormat.hurtbox_top[xx] as u8;
            a = __add_yPos_to_i8a_clamp(a, negative, yy);
            if a < playerHitbox.bottom {
                _hb_top = a;

                a = metasprites.MsDataFormat.hurtbox_bottom[xx] as u8;
                a = __add_yPos_to_i8a_clamp(a, negative, yy);
                if a >= playerHitbox.top {
                    // Calculate collision centre and return true
                    //   centre_y = avg(min(hb_bottom, player_bottom), max(hb_top, player_top))
                    //   centre_x = avg(min(hb_right, player_right), max(hb_left, player_left))

                    // a = _hb_bottom;
                    if a >= playerHitbox.bottom {
                        a = playerHitbox.bottom;
                    }
                    _tmp = a;

                    a = _hb_top;
                    if a < playerHitbox.top {
                        a = playerHitbox.top;
                    }
                    collisionCentre_y = a = (a + _tmp) >>>># 1;

                    a = _hb_right;
                    if a >= playerHitbox.right {
                        a = playerHitbox.right;
                    }
                    _tmp = a;

                    a = _hb_left;
                    if a < playerHitbox.left {
                        a = playerHitbox.left;
                    }
                    collisionCentre_x = a = (a + _tmp) >>>># 1;

                    return true;
                }
            }
        }
    }

    return false;
}

}

}
}


// Fix circular import
import "player";

