// Copyright (c) 2022, Marcus Rowe <undisbeliever@gmail.com>.
// Distributed under The MIT License, see the LICENSE file for more details.


import "../memmap";

import "_variables";
import "_common";


import "../metatiles";
import "../metasprites";


let N_INVINCIBILITY_FRAMES = 20;




namespace entities {
namespace base {


in zeropage {
    // Centre of the collision (if one occurs)
    var collisionCentre_x : u8;
    var collisionCentre_y : u8;
}


in code {



// Test for player collisions and tile collisions.
//
// The results of the collision tests will be stored in `collisionState`.
//
// If there is a player collision, the `entities.player.hitbox_collided_with_entity__inline()`
// or `entities.player.hurtbox_collided_with_entity__inline()` function will be called.
//
// Also updates `SoA.movementState`, `SoA.iframeCounter` and `SoA.health`.
//
// ASSUMES `entityId` is not player.
//
// KEEP: X
// RETURN: collisionState
//
// DB = 0x7e
#[mem8, idx8]
func process_collisions(entityId : u8 in x) : u8 in x {

    x = metatiles.move_entity_and_collision_test(x);


    a = SoA.iframeCounter[x];
    if zero {
        // Only test for a player collision if not in iframe

        y = x;

        // Calculate entity's msFrameAddr
        // Extend 8 bit metaSpriteFrame to 16 bit AA
        #[mem16] {
            // DP = 0
            aa = direct_page;
        }
        a = entities.SoA.metaSpriteFrame[x];

        mem16_idx16();
        #[mem16, idx16] {
            // Safe: (aa << 1) will never set carry
            xx = aa = (aa << 1) +# entities.SoA.metaSpriteFrameTable[unaligned xx];
            xx = aa = metasprites.MetaSpriteFrameTableOffset[unaligned xx];
        }
        mem8();


        #[mem8, idx16] {
            // xx = msFrameAddr
            // yy = entityId

            carry = __test__entity_hurtbox__player_hitbox(yy, xx);
            if carry {
                // collided with player's attack

                mem8_idx8();
                #[mem8, idx8] {
                    entities.player.hitbox_collided_with_entity__inline(y);
                    x = currentEntityId;

                    // ::TODO Different iframe intervals for different entities::
                    // ::TODO Different iframe intervals for NTSC/PAL::
                    SoA.iframeCounter[x] = a = N_INVINCIBILITY_FRAMES;


                    // ::TODO decrement health::


                    collisionState = a = CollisionState.PLAYER_WEAPON;

                    return x;
                }
            }

            carry = __test__entity_hitbox__player_hurtbox(yy, xx);
            if carry {
                // Collided with player's hurtbox

                mem8_idx8();
                #[mem8, idx8] {
                    entities.player.hurtbox_collided_with_entity__inline(y);
                    x = currentEntityId;

                    collisionState = a = CollisionState.PLAYER_HURTBOX;

                    return x;
                }
            }
        }
        mem8_idx8();

        // Restore entityId to X register
        x = y;
    }
    else {
        SoA.iframeCounter[x] = --a;
    }


    collisionState = 0;

    return x;
}



// COLLISION TESTS
// ===============


// Add the entity's unsigned xPos to a signed i8 accumulator with clamping.
//
// ASSUMES: negative flag contains the MSB of A (the previous instruction is an `lda`).
//
// KEEP: xx & yy
//
// DB = 0x7e
#[mem8, idx16]
inline func __add_xPos_to_i8a_clamp(a : u8 in a, n : bool in negative, entityId : u16 in yy) : u8 in a {
    if negative {
        a += entities.SoA.xPos_px[yy];
        return a if carry;
            a = 0;
    }
    else {
        a += entities.SoA.xPos_px[yy];
        return a if !carry;
            a = 0xff;
    }

    return a;
}


// Add the entity's unsigned yPos to a signed i8 accumulator with clamping.
//
// ASSUMES: negative flag contains the MSB of A (the previous instruction is an `lda`).
//
// KEEP: xx & yy
//
// DB = 0x7e
#[mem8, idx16]
inline func __add_yPos_to_i8a_clamp(i8a : u8 in a, n : bool in negative, entityId : u16 in yy) : u8 in a {
    if negative {
        a += entities.SoA.yPos_px[yy];
        return a if carry;
            a = 0;
    }
    else {
        a += entities.SoA.yPos_px[yy];
        return a if !carry;
            a = 0xff;
    }

    return a;
}



// Test for a collision between an entity's hurtbox and the player's hurtbox.
//
// NOTE: This function will NOT call the player collided callback.
//
// ASSUMES `entityId` is not player.
//
// KEEP: xx & yy
// RETURN: true if there is a collision
//
// DB = 0x7e
#[mem8, idx16]
func __test__entity_hitbox__player_hurtbox(entityId : u16 in yy, msFrameAddr : u16 in xx) : bool in carry {

let _hb_left   = <:dpTmp0;
let _hb_right  = <:dpTmp1;
let _hb_top    = <:dpTmp2;
let _tmp       = <:dpTmp3;


    // calculate entity hitbox left
    // Add i8 signed offset to entity's u8 unsigned position (with clamping)
    a = metasprites.MsDataFormat.hitbox_left[xx] as u8;
    if negative {
        // Putting the no-hitbox test here as it is faster.
        if a == metasprites.MsDataFormat.NO_AABB_VALUE {
            // MS frame has no hitbox
            return false;
        }

        a += entities.SoA.xPos_px[yy];
        if !carry {
            a = 0;
        }
    }
    else {
        a += entities.SoA.xPos_px[yy];
        if carry {
            a = 0xff;
        }
    }

    ^if a < playerHurtbox.right {
        _hb_left = a;

        a = metasprites.MsDataFormat.hitbox_right[xx] as u8;
        a = __add_xPos_to_i8a_clamp(a, negative, yy);
        if a >= playerHurtbox.left {
            _hb_right = a;

            a = metasprites.MsDataFormat.hitbox_top[xx] as u8;
            a = __add_yPos_to_i8a_clamp(a, negative, yy);
            if a < playerHurtbox.bottom {
                _hb_top = a;

                a = metasprites.MsDataFormat.hitbox_bottom[xx] as u8;
                a = __add_yPos_to_i8a_clamp(a, negative, yy);
                if a >= playerHurtbox.top {
                    // Calculate collision centre and return true
                    //   centre_y = avg(min(hb_bottom, player_bottom), max(hb_top, player_top))
                    //   centre_x = avg(min(hb_right, player_right), max(hb_left, player_left))

                    // a = _hb_bottom;
                    if a >= playerHurtbox.bottom {
                        a = playerHurtbox.bottom;
                    }
                    _tmp = a;

                    a = _hb_top;
                    if a < playerHurtbox.top {
                        a = playerHurtbox.top;
                    }
                    collisionCentre_y = a = (a + _tmp) >>>># 1;

                    a = _hb_right;
                    if a >= playerHurtbox.right {
                        a = playerHurtbox.right;
                    }
                    _tmp = a;

                    a = _hb_left;
                    if a < playerHurtbox.left {
                        a = playerHurtbox.left;
                    }
                    collisionCentre_x = a = (a + _tmp) >>>># 1;

                    return true;
                }
            }
        }
    }

    return false;
}



// Test for a collision between an entity's hurtbox and the player's hitbox.
//
// NOTE: This function will NOT call the player collided callback.
//
// ASSUMES `entityId` is not player.
//
// KEEP: xx & yy
// RETURN: true if there is a collision
//
// DB = 0x7e
#[mem8, idx16]
func __test__entity_hurtbox__player_hitbox(entityId : u16 in yy, msFrameAddr : u16 in xx) : bool in carry {

let _hb_left   = <:dpTmp0;
let _hb_right  = <:dpTmp1;
let _hb_top    = <:dpTmp2;
let _tmp       = <:dpTmp3;


    // calculate entity hurtbox left
    // Add i8 signed offset to entity's u8 unsigned position (with clamping)
    a = metasprites.MsDataFormat.hurtbox_left[xx] as u8;
    if negative {
        // Putting the no-hitbox test here as it is faster.
        if a == metasprites.MsDataFormat.NO_AABB_VALUE {
            // MS frame has no hitbox
            return false;
        }

        a += entities.SoA.xPos_px[yy];
        if !carry {
            a = 0;
        }
    }
    else {
        a += entities.SoA.xPos_px[yy];
        if carry {
            a = 0xff;
        }
    }

    ^if a < playerHitbox.right {
        _hb_left = a;

        a = metasprites.MsDataFormat.hurtbox_right[xx] as u8;
        a = __add_xPos_to_i8a_clamp(a, negative, yy);
        if a >= playerHitbox.left {
            _hb_right = a;

            a = metasprites.MsDataFormat.hurtbox_top[xx] as u8;
            a = __add_yPos_to_i8a_clamp(a, negative, yy);
            if a < playerHitbox.bottom {
                _hb_top = a;

                a = metasprites.MsDataFormat.hurtbox_bottom[xx] as u8;
                a = __add_yPos_to_i8a_clamp(a, negative, yy);
                if a >= playerHitbox.top {
                    // Calculate collision centre and return true
                    //   centre_y = avg(min(hb_bottom, player_bottom), max(hb_top, player_top))
                    //   centre_x = avg(min(hb_right, player_right), max(hb_left, player_left))

                    // a = _hb_bottom;
                    if a >= playerHitbox.bottom {
                        a = playerHitbox.bottom;
                    }
                    _tmp = a;

                    a = _hb_top;
                    if a < playerHitbox.top {
                        a = playerHitbox.top;
                    }
                    collisionCentre_y = a = (a + _tmp) >>>># 1;

                    a = _hb_right;
                    if a >= playerHitbox.right {
                        a = playerHitbox.right;
                    }
                    _tmp = a;

                    a = _hb_left;
                    if a < playerHitbox.left {
                        a = playerHitbox.left;
                    }
                    collisionCentre_x = a = (a + _tmp) >>>># 1;

                    return true;
                }
            }
        }
    }

    return false;
}

}

}
}


