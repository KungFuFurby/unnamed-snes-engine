// Copyright (c) 2021, Marcus Rowe <undisbeliever@gmail.com>.
// Distributed under The MIT License, see the LICENSE file for more details.

import "../memmap";

import "../../gen/entity-data";

import "../metasprites";
import "_variables";
import "player";


namespace entities {

let N_ENTITY_TYPES = sizeof(typeof(entity_rom_data.init_functions)) / 2;


in zeropage {
    var __currentEntityTablePos : u8;
}


in code {


// Initialize the entity subsystem
//
// DB = 0x7e
#[mem8, idx8]
func init() {
    mem16();
    #[mem16] {
        // Set player's process function to a blank function.
        // Required as the player is processed before `process_active_entities()` is called.
        aa = _blank_player_function as u16;
        entities.SoA.process_function[0] = aa as func(u8 in x) : bool in carry;

        // Set player's ms_draw function
        aa = entities.player.ms_draw_function as u16;
        entities.SoA.ms_draw_function[0] = aa as func(u16 in yy, u16 in metasprites.xPos, u16 in metasprites.yPos);

        entities.SoA.metaSpriteFrameTable[0] = aa = &entities.player.ms_frame_table as u16;


        // Set all process_functions to blank (except player)
        aa = _blank_entity_function as u16;

        x = entities.SoA.LAST_INDEX;
        do {
            // Reset process function
            entities.SoA.process_function[unaligned x] = aa as func(u8 in x) : bool in carry;
            entities.SoA.ms_draw_function[unaligned x] = aa as func(u16 in yy, u16 in metasprites.xPos, u16 in metasprites.yPos);

            // Clear entity shadow
            (&entities.SoA._shadowSizeAndMsFrame as *u16)[unaligned x] = 0;

            x--;
            x--;
        } while !zero;
    }
    mem8();


    // Populate `activeEntitiesTable`
    {
        numberOfActiveEntities = a = 1;

        a = SoA.LAST_INDEX;
        x = ACTIVE_ENTITIES_TABLE__LAST_POS;

        do {
            activeEntitiesTable[x] = a;

            a--;
            a--;

            x--;
        }
        while !negative;
    }
}



// Spawn entity
//
// NOTE: This function may fail if `entityType` is invalid or there are no more unused entityIds.
//
// DB = 0x7e
#[mem8, idx8]
func spawn_entity(xPos : u8 in <:dpTmp0, yPos : u8 in >:dpTmp0, entityType : u8 in a, initParameter : u8 in y) {
let _init_function_u16 = dpTmp1;
let _init_function_ptr = _init_function_u16 as func(u8 in y, u8 in x);

    ^if a < N_ENTITY_TYPES {

        // Retrieve the next unused entity from the `activeEntitiesTable` (if one is available)
        x = numberOfActiveEntities;
        ^if x < sizeof(typeof(activeEntitiesTable)) {
            // This code path MUST spawn an entity
            push8(y);

            y = activeEntitiesTable[x];
            // Y = entityId

            // mark entity active
            numberOfActiveEntities = ++x;

            x = a = a <<< 1;

            mem16();
            #[mem16] {
                _init_function_u16 = aa = (far &entity_rom_data.init_functions as far *u16)[unaligned x];

                (&entities.SoA.process_function[0] as *u16)[unaligned y] = aa = (far &entity_rom_data.process_functions as far *u16)[unaligned x];
                (&entities.SoA._visionAB[0] as *u16)[unaligned y] = aa = entity_rom_data.vision_ab[unaligned x];

                (&entities.SoA._zPosAndBlank[0] as *u16)[unaligned y] = aa = entity_rom_data.initial_zpos_and_blank[unaligned x];

                (&entities.SoA._healthAndAttackPower[0] as *u16)[unaligned y] = aa = entity_rom_data.health_and_attack_power[unaligned x];

                aa = (far &entity_rom_data.metasprite_framesets as far *u16)[unaligned x];
            }

            mem16_idx16();
            #[mem16, idx16] {
                // MetaSprite Data
                xx = aa;

                (&entities.SoA._shadowSizeAndMsFrame[0] as *u16)[unaligned yy] = aa = metasprites.MsFsData.shadowSize__u16[unaligned xx] & 0xff;
                (&entities.SoA.tileHitbox[0].first as *u16)[unaligned yy] = aa = metasprites.MsFsData.tileHitbox[unaligned xx];

                (&<:entities.SoA.ms_draw_function[0] as *u16)[unaligned yy] = aa = metasprites.MsFsData.drawFunction[unaligned xx];
                (&<:entities.SoA.metaSpriteFrameTable[0] as *u16)[unaligned yy] = aa = metasprites.MsFsData.frameTable[unaligned xx];
            }
            idx8();

            #[mem16, idx8] {
                // Clear unused data
                // Required: No `stz.w addr,y` instruction.
                x = y;

                entities.SoA.xVelocity[unaligned x] = 0;
                entities.SoA.yVelocity[unaligned x] = 0;

                (&entities.SoA._movementStateAndIframeCounter as *u16)[unaligned x] = 0;

                entities.SoA.state_0[unaligned x] = 0;
                entities.SoA.state_1[unaligned x] = 0;
                entities.SoA.state_2[unaligned x] = 0;
                entities.SoA.state_3[unaligned x] = 0;
                entities.SoA.state_4[unaligned x] = 0;
                entities.SoA.state_5[unaligned x] = 0;
                entities.SoA.state_6[unaligned x] = 0;
                entities.SoA.state_7[unaligned x] = 0;
            }
            mem8_idx8();

            // x & y = entityId

            a = xPos;
            entities.SoA.previousXpos[x] = a;
            entities.SoA.xPos_px[x] = a;
            entities.SoA.xPos_sx[x] = 0;

            a = yPos;
            entities.SoA.previousYpos[x] = a;
            entities.SoA.yPos_px[x] = a;
            entities.SoA.yPos_sx[x] = 0;

            // Call spawn function
            x = pop8();
            return _init_function_ptr(y, x);
        }
    }
}



// Execute the process routine in all active entities
//
// DB = 0x7e
#[mem8, idx8]
inline func process_active_entities()
{
let _tmp = <:dpTmp0;

    x = numberOfActiveEntities;
    if !zero {
        do {
            x--;
            __currentEntityTablePos = x;

            y = activeEntitiesTable[x];
            currentEntityId = y;
            x = y;
            carry = entities.SoA.process_function[unaligned x](y);
            if !carry {
                // Entity no longer active


                // Remove entity from active entities list, preserving active entity order.
                //
                // Preserving entity order should be friendlier to `sort_active_entities()`.
                numberOfActiveEntities--;

                y = currentEntityId;

                mem16();
                #[mem16] {
                    // ASSUMES numberOfActiveEntities <= ACTIVE_ENTITIES_TABLE__LAST_POS
                    // ASSUMES numberOfActiveEntities < sizeof(activeEntitiesTable)

                    // Must not change Y

                    x = __currentEntityTablePos;
                    if x < numberOfActiveEntities {
                        do {
                            // Swap activeEntitiesTable[x] and activeEntitiesTable[x + 1]
                            aa = (&activeEntitiesTable as *u16)[unaligned x];
                            swap_bytes(aa);
                            (&activeEntitiesTable as *u16)[unaligned x] = aa;

                            x++;
                        } while x < numberOfActiveEntities;
                    }


                    // Set process_function and ms_draw_function to a blank function (just in case they are accidentally called)
                    aa = _blank_entity_function as u16;
                    entities.SoA.process_function[unaligned y] = aa as func(u8 in x) : bool in carry;
                    entities.SoA.ms_draw_function[unaligned y] = aa as func(u16 in yy, u16 in metasprites.xPos, u16 in metasprites.yPos);
                }
                mem8();


                // Do not draw a shadow on unused entities.
                //
                // Y is currentEntityId;
                a = metasprites.ShadowSize.NONE as u8;
                SoA.shadowSize[unaligned y] = a as metasprites.ShadowSize;
            }

            x = __currentEntityTablePos;
        } while !zero;
    }
}



// Execute the ms_draw_function for all active entities (excluding player)
//
// DB = 0x7e
#[mem8, idx8]
inline func draw_active_entities()
{
    x = 0;
    if x < numberOfActiveEntities {
        do {
            __currentEntityTablePos = x;

            metasprites._draw_entity__inline(y = activeEntitiesTable[x]);

            x = __currentEntityTablePos;
            x++;
        } while x < numberOfActiveEntities;
    }
}



// Sort the active entities by their Y position.
//
// This function is not inline so I can measure its CPU usage with Mesen-S.
//
// Insertion sort.
//
// DB = 0x7e
#[mem8, idx8]
func sort_active_entities()
{
    // Thanks Wikipedia for the Insertion sort algorithm.
    //
    // "Insertion sort."  Wikipedia, The Free Encyclopedia.
    // https://en.wikipedia.org/wiki/Insertion_sort#Algorithm
    // (accessed October 16, 2021).


let _entityId = >:dpTmp0;
let _yPosToCompare = <:dpTmp0;


    // A = yPos to compare
    // X = index into activeEntitiesTable
    // Y = index into entities SoA


    x = 1;
    if x < numberOfActiveEntities {
        do {
            y = activeEntitiesTable[x];
            a = entities.SoA.yPos_px[y];

            _entityId = y;

            y = (&activeEntitiesTable[-1])[x];
            if a < entities.SoA.yPos_px[y] {
                __currentEntityTablePos = x;

                _yPosToCompare = a;

                do {
                    // ::ANNOY no `sty addr,x` instruction on the 65816::
                    // If I could use `sty addr,x` then I could remove `_yPosToCompare` and store it in A.
                    activeEntitiesTable[x] = a = y;

                    x--;
                    break if zero;

                    a = _yPosToCompare;

                    y = (&activeEntitiesTable[-1])[x];
                } while a < entities.SoA.yPos_px[y];


                activeEntitiesTable[x] = a = _entityId;

                x = __currentEntityTablePos;
            }

            x++;
        } while x < numberOfActiveEntities;
    }
}



// A blank entity process function that returns false (entity no-longer active)
//
// DB = 0x7e
func _blank_entity_function() : bool in carry {
    return false;
}


// A special blank entity process function that return true (entity is always active)
//
// Used by entities that are processed outside of `process_active_entities()`.
//
// DB = 0x7e
func _blank_player_function() : bool in carry {
    return true;
}


}

}

