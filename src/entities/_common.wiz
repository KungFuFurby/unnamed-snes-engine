// Copyright (c) 2021, Marcus Rowe <undisbeliever@gmail.com>.
// Distributed under The MIT License, see the LICENSE file for more details.

import "../memmap";

import "../../gen/entity-data";

import "../metasprites";
import "_variables";
import "player";


namespace entities {

let N_ENTITY_TYPES = sizeof(typeof(entities.entity_data.process_function_l));


in zeropage {
    var __currentEntityTablePos : u8;
}


in code {


// Initialize the entity subsystem
//
// DB = 0x7e
#[mem8, idx8]
func init() {
    mem16();
    #[mem16] {
        // Set player's process function
        aa = entities.player.process as u16;
        entities.SoA.process_function[0] = aa as func(u8 in x) : bool in carry;

        // Set player's ms_draw function
        aa = entities.player.ms_draw_function as u16;
        entities.SoA.ms_draw_function[0] = aa as func(u16 in yy, u16 in metasprites.xPos, u16 in metasprites.yPos);


        // Set all process_functions to blank (except player)
        aa = _blank_entity_function as u16;

        x = entities.SoA.LAST_INDEX;
        do {
            // Reset process function
            entities.SoA.process_function[unaligned x] = aa as func(u8 in x) : bool in carry;
            entities.SoA.ms_draw_function[unaligned x] = aa as func(u16 in yy, u16 in metasprites.xPos, u16 in metasprites.yPos);

            // Clear entity shadow
            (&entities.SoA._zPosAndShadow as *u16)[unaligned x] = 0;

            x--;
            x--;
        } while !zero;
    }
    mem8();


    // Populate `activeEntitiesTable`
    {
        activeEntitiesTablePos = 0;

        a = SoA.LAST_INDEX;
        x = ACTIVE_ENTITIES_TABLE__LAST_POS;

        do {
            activeEntitiesTable[x] = a;

            a--;
            a--;

            x--;
        }
        while !negative;
    }
}



// Spawn entity
//
// NOTE: This function may fail if `entityType` is invalid or there are no more unused entityIds.
//
// DB = 0x7e
#[mem8, idx8]
func spawn_entity(xPos : u8 in <:dpTmp0, yPos : u8 in >:dpTmp0, entityType : u8 in a, initParameter : u8 in y) {
let _init_function_u16 = dpTmp1;
let _init_function_ptr = _init_function_u16 as func(u8 in x, u8 in y);

    ^if a < N_ENTITY_TYPES {

        // Retrieve the next unused entity from the `activeEntitiesTable` (if one is available)
        x = activeEntitiesTablePos;
        ^if x < sizeof(typeof(activeEntitiesTable)) {
            // This code path MUST spawn an entity
            push8(y);

            y = activeEntitiesTable[x];
            // mark entity active
            activeEntitiesTablePos = ++x;


            x = a;

            // Y = entityId
            // X = entity Data Index

            (&<:entities.SoA.process_function[0] as *u8)[y] = a = (far &entities.entity_data.process_function_l as far *u8)[x];
            (&>:entities.SoA.process_function[0] as *u8)[y] = a = (far &entities.entity_data.process_function_h as far *u8)[x];

            (&<:entities.SoA.ms_draw_function[0] as *u8)[y] = a = (far &entities.entity_data.ms_draw_function_l as far *u8)[x];
            (&>:entities.SoA.ms_draw_function[0] as *u8)[y] = a = (far &entities.entity_data.ms_draw_function_h as far *u8)[x];

            (&<:entities.SoA.metaSpriteFrameTable[0] as *u8)[y] = a = (far &entities.entity_data.ms_frame_table_l as far *u8)[x];
            (&>:entities.SoA.metaSpriteFrameTable[0] as *u8)[y] = a = (far &entities.entity_data.ms_frame_table_h as far *u8)[x];

            a = (far &entities.entity_data.shadow_size as far *u8)[x];
            entities.SoA.shadowSize[y] = a as entities.ShadowSize;

            entities.SoA.zPos[y] = a = (far &entities.entity_data.initial_zpos as far *u8)[x];
            entities.SoA.tileHitbox_halfWidth[y] = a = (far &entities.entity_data.tile_hitbox_half_width as far *u8)[x];
            entities.SoA.tileHitbox_halfHeight[y] = a = (far &entities.entity_data.tile_hitbox_half_height as far *u8)[x];

            <:_init_function_u16 = a = (far &entities.entity_data.init_function_l as far *u8)[x];
            >:_init_function_u16 = a = (far &entities.entity_data.init_function_h as far *u8)[x];


            // Clear unused data
            x = y;

            entities.SoA.xPos_sx[x] = 0;
            entities.SoA.xPos_px[x] = a = xPos;
            entities.SoA.yPos_sx[x] = 0;
            entities.SoA.yPos_px[x] = a = yPos;

            mem16();
            #[mem16] {
                entities.SoA.xVelocity[unaligned x] = 0;
                entities.SoA.yVelocity[unaligned x] = 0;

                entities.SoA._movementStateAndBlank[unaligned x] = 0;

                entities.SoA.state_0[unaligned x] = 0;
                entities.SoA.state_1[unaligned x] = 0;
                entities.SoA.state_2[unaligned x] = 0;
                entities.SoA.state_3[unaligned x] = 0;
                entities.SoA.state_4[unaligned x] = 0;
                entities.SoA.state_5[unaligned x] = 0;
                entities.SoA.state_6[unaligned x] = 0;
                entities.SoA.state_7[unaligned x] = 0;
            }
            mem8();


            // Call spawn function
            y = pop8();
            return _init_function_ptr(x, y);
        }
    }
}



// Execute the process routine in all active entities (excluding player)
//
// DB = 0x7e
#[mem8, idx8]
inline func process_active_entities()
{
let _tmp = <:dpTmp0;

    y = activeEntitiesTablePos;
    if !zero {
        do {
            y--;
            __currentEntityTablePos = y;

            x = activeEntitiesTable[y];
            currentEntityId = x;
            carry = entities.SoA.process_function[unaligned x](x);
            if !carry {
                x = activeEntitiesTablePos;
                x--;
                activeEntitiesTablePos = x;
                if !zero {
                    // Remove entity from active pool
                    y = __currentEntityTablePos;

                    _tmp = a = activeEntitiesTable[y];
                    activeEntitiesTable[y] = a = activeEntitiesTable[x];
                    activeEntitiesTable[x] = a = _tmp;

                    x = a;
                }

                x = currentEntityId;
                SoA.shadowSize[unaligned x] = ShadowSize.NONE;

                // Set process_function and ms_draw_function to a blank function (just in case they are accidentally called)
                mem16();
                #[mem16] {
                    aa = _blank_entity_function as u16;
                    entities.SoA.process_function[unaligned x] = aa as func(u8 in x) : bool in carry;
                    entities.SoA.ms_draw_function[unaligned x] = aa as func(u16 in yy, u16 in metasprites.xPos, u16 in metasprites.yPos);
                }
                mem8();
            }

            y = __currentEntityTablePos;
        } while !zero;
    }
}



// Execute the ms_draw_function for all active entities (excluding player)
//
// DB = 0x7e
#[mem8, idx8]
inline func draw_active_entities()
{
    x = activeEntitiesTablePos;
    if !zero {
        do {
            x--;
            __currentEntityTablePos = x;

            metasprites._draw_entity__inline(y = activeEntitiesTable[x]);

            x = __currentEntityTablePos;
        } while !zero;
    }
}



// DB = 0x7e
func _blank_entity_function() {
}

}

}

