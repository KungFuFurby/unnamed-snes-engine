// Copyright (c) 2021, Marcus Rowe <undisbeliever@gmail.com>.
// Distributed under The MIT License, see the LICENSE file for more details.

import "../memmap";

import "_variables";
import "_common";


import "../metatiles";
import "../metasprites";

import "../../gen/entities";


namespace entities {
namespace bouncing_off_walls {


let SoA_iframeCounter    = SoA.state_0_l;

let SoA_animationCounter = SoA.state_0_h;


let SPEED = 0x0120;

let N_I_FRAMES = 20;


let ANIMATION_DELAY = 4;
let ANIMATION_FRAME_MASK = 0x7;


in code {


// Entity process routine.
//
// Called when the entity is spawned
//
// DB = 0x7e
#[mem8, idx8]
func init(entityId : u8 in x, parameter : u8 in y) {
    mem16();
    #[mem16] {
        // Set starting velocity depending on `parameter`

        aa = 0;
        if y < init_parameter.up as u8 || y == init_parameter.down_right as u8 {
            aa = SPEED;
        }
        else if y >= init_parameter.up_left as u8 && y < init_parameter.down as u8 {
            aa = -SPEED as u16;
        }
        SoA.xVelocity[unaligned x] = aa;

        aa = 0;
        if y >= init_parameter.down_left as u8 {
            aa = SPEED;
        }
        else if y >= init_parameter.up_right as u8 && y < init_parameter.left as u8 {
            aa = -SPEED as u16;
        }
        SoA.yVelocity[unaligned x] = aa;
    }
    mem8();

    SoA.metaSpriteFrame[unaligned x] = ms_frames.frame0;
}



// Entity process routine.
//
// Called once per frame.
//
// DB = 0x7e
#[mem8, idx8]
func process(entityId : u8 in x) : bool in carry {
    metatiles.move_entity_and_collision_test(x);

    _process_collisions(x);


    // Process animation
    SoA_animationCounter[x]--;
    if negative {
        SoA_animationCounter[x] = a = ANIMATION_DELAY - 1;

        // Increment animation Frame
        a = SoA.metaSpriteFrame[x];
        a++;
        SoA.metaSpriteFrame[x] = a = a & ANIMATION_FRAME_MASK;
    }


    return true;
}



// Test and react to player collisions and tile collisions.
//
// KEEP: X
//
// DB = 0x7e
#[mem8, idx8]
inline func _process_collisions(entityId : u8 in x) : u8 in x {

    a = SoA_iframeCounter[x];
    if zero {
        // Only test for a player collision if not in iframe

        carry = entities.test_tilebox__player_hitbox(x);
        if carry {
            // collided with player's attack - bounce entity off player

            SoA_iframeCounter[x] = a = N_I_FRAMES;

            // ::TODO decrement health::

            // ::TODO add reaction::
            mem16();
            #[mem16] {
                SoA.xVelocity[unaligned x] = 0;
                SoA.yVelocity[unaligned x] = 0;
            }
            mem8();

            return x;
        }

        carry = entities.test_tile_hitbox_player_hurtbox(x);
        if carry {
            mem16();
            #[mem16] {
                SoA.xVelocity[unaligned x] = aa = 0 - SoA.xVelocity[unaligned x];
                SoA.yVelocity[unaligned x] = aa = 0 - SoA.yVelocity[unaligned x];
            }
            mem8();

            return x;
        }
    }
    else {
        SoA_iframeCounter[x] = --a;
    }


    // Check for a tile collision

    a = SoA.movementState[x];
    if a & MovementState.X_AXIS_COLLISION != 0 {
        mem16();
        #[mem16] {
            SoA.xVelocity[unaligned x] = aa = 0 - SoA.xVelocity[unaligned x];
        }
        mem8();
    }

    a = SoA.movementState[x];
    if a & MovementState.Y_AXIS_COLLISION != 0 {
        mem16();
        #[mem16] {
            SoA.yVelocity[unaligned x] = aa = 0 - SoA.yVelocity[unaligned x];
        }
        mem8();
    }

    return x;
}


}

}
}

