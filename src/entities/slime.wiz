// Copyright (c) 2022, Marcus Rowe <undisbeliever@gmail.com>.
// Distributed under The MIT License, see the LICENSE file for more details.

import "../memmap";

import "_variables";
import "_base";

import "../rng";

import "../../gen/entities";


namespace entities {
namespace slime {


let CRAWL_SPEED = 0x0080;


let STARTING_CHANGE_DIRECTION_DELAY = 60 * 3;

// The sum of these two constants must be <= 0xff
let MIN_CHANGE_DIRECTION_DELAY = 90;
let CHANNGE_DIRECTION_DELAY_RANDOM_MASK = 0x7f;


let ANIMATION_DELAY = 13;
let ANIMATION_FRAME_MASK = 0x3;
let CRAWL_ANIMATION_FRAME_SHIFT = 2;

let HURT_KNOCKBACK_TIME_IN_FRAMES = 30;
let KNOCKBACK_POWER = base.SwordCollisionSpeed.MEDIUM; // 4x CRAWL_SPEED (0x0200)


enum Direction : u8 {
    LEFT,
    RIGHT,
    UP,
    DOWN,
};

let DIRECTION_MASK = 3;


enum State : u8 {
    CRAWL   = 0,
    HURT = 2,
};


let SoA_state            = SoA.state_0_l as *State;
let SoA_direction        = SoA.state_0_h as *Direction;

let SoA_animationCounter = SoA.state_1_l;

let SoA_changeDirectionTimer = SoA.state_2_l;



in code {


// Entity process routine.
//
// Called when the entity is spawned
//
// DB = 0x7e
#[mem8, idx8]
func init(entityId : u8 in y, parameter : u8 in x) {

    a = x;
    if a >= 4 {
        a = rng.random();
    }
    set_direction(y, a);

    SoA_changeDirectionTimer[y] = a = STARTING_CHANGE_DIRECTION_DELAY;

    x = y;
    SoA_state[x] = State.CRAWL;
}



// Entity process routine.
//
// Called once per frame.
//
// DB = 0x7e
#[mem8, idx8]
func process(entityId : u8 in y) : bool in carry {

    y = base.process_collisions(y);


    if collisionState $ CollisionState.PLAYER_WEAPON_BIT {
        set_state__hurt(y);
    }

    if collisionState $ CollisionState.PLAYER_HURTBOX_BIT {
        base.hurt_player__collision(y);

        // ::TODO add reaction when colliding with player hurtbox ::
    }


    x = SoA_state[y] as u8;
    return process__state_functions[unaligned x](y);
}


const process__state_functions = [
    process__crawl,
    process__hurt,
];



// Crawling
// ========


// DB = 0x7e
#[mem8, idx8]
func set_state__crawl(entityId : u8 in y) : bool in carry {
    a = State.CRAWL as u8;
    SoA_state[y] = a as State;

    return true;
}



// DB = 0x7e
#[mem8, idx8]
func process__crawl(entityId : u8 in y) : bool in carry {
let _tmp = <:dpTmp0;


    a = SoA.movementState[y];
    if !zero {
        // Must test for collision in the direction of movement
        // to prevent the slime getting stuck on corners/walls after a sword collision.
        x = SoA_direction[y] as u8;

        a = DirectionMovementState[x];
        a &= SoA.movementState[y];
        if !zero {
            // Collided with wall (in the direction of movement)
            // 180 degree turn
            a = (SoA_direction[y] as u8) ^ 1;
            return set_direction(y, a);
        }
    }


    // Randomly change direction when changeDirectionTimer reaches zero
    a = SoA_changeDirectionTimer[y];
    if !zero {
        a--;
        SoA_changeDirectionTimer[y] = a;
    }
    else {
        // Reset changeDirectionTimer to a random value
        a = rng.random();
        a = (a & CHANNGE_DIRECTION_DELAY_RANDOM_MASK) + MIN_CHANGE_DIRECTION_DELAY;
        SoA_changeDirectionTimer[y] = a;

        a = rng.random();
        return set_direction(y, a);
    }


    // Update crawl animation
    a = SoA_animationCounter[y];
    if !zero {
        a--;
        SoA_animationCounter[y] = a;
    }
    else {
        SoA_animationCounter[y] = a = ANIMATION_DELAY;

        // Increment animation Frame
        a = SoA.metaSpriteFrame[y];
        a++;
        _tmp = a = a & ANIMATION_FRAME_MASK;

        SoA.metaSpriteFrame[y] = a = (SoA.metaSpriteFrame[y] & (ANIMATION_FRAME_MASK ^ 0xff)) | _tmp;
    }

    return true;
}



// DB = 0x7e
#[mem8, idx8]
func set_direction(entityId : u8 in y, direction : u8 in a) : bool in carry {

    // Do not set `changeDirectionTimer` in this function.
    // Doing so can cause the slime to get stuck in tight corridors
    // (forever crawling left-right or up-down in a loop).


    a &= DIRECTION_MASK;

    SoA_direction[y] = a as Direction;

    x = a = a <<< 1;

    SoA.metaSpriteFrame[y] = a = a <<< (CRAWL_ANIMATION_FRAME_SHIFT - 1);
    SoA_animationCounter[y] = a = 0;

    mem16();
    #[mem16] {
        SoA.xVelocity[unaligned y] = aa = DirectionCrawlVelocity_X[unaligned x] as u16;
        SoA.yVelocity[unaligned y] = aa = DirectionCrawlVelocity_Y[unaligned x] as u16;
    }
    mem8();

    return true;
}



// Hurt
// ====

// ASSUMES: entity collided with sword hitbox and `collisionCentre` is valid.
//
// KEEP: Y
// DB = 0x7e
#[mem8, idx8]
func set_state__hurt(entityId : u8 in y) {
    a = State.HURT as u8;
    SoA_state[y] = a as State;

    a = HURT_KNOCKBACK_TIME_IN_FRAMES;
    SoA_animationCounter[y] = a;
    SoA.iframeCounter[y] = a;

    ^return base.take_damage_from_player_sword_with_knockback(y, KNOCKBACK_POWER);
}



// DB = 0x7e
#[mem8, idx8]
func process__hurt(entityId : u8 in y) : bool in carry {

    a = SoA_animationCounter[y];
    if !zero {
        a--;
        SoA_animationCounter[y] = a;
    }
    else {
        ^return set_state__crawl(y);
    }

    return true;
}

}


in rodata0 {

    const _DirectionCrawlVelocity_X : [i16 ; 4] = [ -CRAWL_SPEED,  CRAWL_SPEED,            0,            0 ];
    const _DirectionCrawlVelocity_Y : [i16 ; 4] = [             0,           0, -CRAWL_SPEED,  CRAWL_SPEED ];

    let DirectionCrawlVelocity_X = far &_DirectionCrawlVelocity_X as far *u16;
    let DirectionCrawlVelocity_Y = far &_DirectionCrawlVelocity_Y as far *i16;


    const _DirectionMovementState   : [u8 ; 4] = [
        MovementState.LEFT_COLLISION,
        MovementState.RIGHT_COLLISION,
        MovementState.UP_COLLISION,
        MovementState.DOWN_COLLISION,
    ];
    let DirectionMovementState = far &_DirectionMovementState as far *u8;
}

}
}

