// Copyright (c) 2021, Marcus Rowe <undisbeliever@gmail.com>.
// Distributed under The MIT License, see the LICENSE file for more details.

import "../memmap";

import "_variables";
import "_base";
import "player";

import "../common/math";

import "../../gen/entities";


namespace entities {
namespace swarming {


// ::TODO store speed in entity SoA::
let FACING_SPEED = 0x00c0;
let ALT_SPEED    = 0x0060;


let X_ALT_VELOCITY_THRESHOLD = 8;
let Y_ALT_VELOCITY_THRESHOLD = 2;

let X_TURN_THRESHOLD = 16;
let Y_TURN_THRESHOLD = 14;

let X_TURNAROUND_THRESHOLD = 21;
let Y_TURNAROUND_THRESHOLD = 28;


let ANIMATION_DELAY = 12;
let ANIMATION_FRAME_MASK = 0x3;


// State must be in the same order as the MetaSprite frames
enum State : u8 {
    FACING_SOUTH = 0,
    FACING_NORTH = 2,
    FACING_EAST = 4,
    FACING_WEST = 6,
    HURT      = 8,
};


let SoA_state            = SoA.state_0_l as *State;
let SoA_animationCounter = SoA.state_0_h;

// Offset between player's position and the entity's target.
let SoA_targetOffset_x   = SoA.state_1_l as *i8;
let SoA_targetOffset_y   = SoA.state_1_h as *i8;


// Location to swarm to.
//
// Will be invalidated on a function call outside this entity.
//
// (u8 position)
let _target_x = <:dpTmp0;
let _target_y = >:dpTmp0;

// Absolute difference between target and entity position.
//
// Will be invalidated on a function call outside this entity.
//
// (2x u8)
let _absDifference_x = <:dpTmp1;
let _absDifference_y = >:dpTmp1;



in wram7e {
    // Index into the last entry read in `OffsetTable_x` and `OffsetTable_y`.
    var offsetTableIndex : u8;
}


in rodata0 {
    // SoA table of player/target offsets.
    //
    // Values were generated and shuffled using a python script.
    const _OffsetTable_x : [ i8 ; 64 ] = [-4, 11, -6, -4, 14, -10, 5, -9, 7, -6, 9, -2, 1, 4, -8, -5, 11, -5, 2, -11, 1, -6, 9, -3, -1, -1, 3, 6, 2, 8, 11, -2, 14, -13, -2, -7, 2, 6, 6, 7, 1, -1, -7, -4, -9, -9, -11, 5, -14, 10, 2, 4, 13, -14, -9, -2, 4, -11, -8, 9, 9, 8, -7, 7];
    const _OffsetTable_y : [ i8 ; 64 ] = [-1, 6, 8, -11, -1, 8, -7, -2, -2, -8, -6, 10, -6, 1, 4, 7, 2, -4, 10, -6, -8, 10, -1, -7, 6, 11, 7, -8, -3, 9, -2, -6, 3, 5, -10, -6, 6, 8, -10, 1, -11, 8, -1, 5, 6, 1, -2, 4, 1, -8, -10, -5, -5, -3, -5, 3, 11, 2, -9, 2, 5, -4, 2, 6];

    let OffsetTable_x = far &_OffsetTable_x as far *const i8;
    let OffsetTable_y = far &_OffsetTable_y as far *const i8;
}


in code {


// Transforms an entity into a spawning entity.
//
// ASSUMES: entityId is an active entity.
//
// Always returns true.
//
// DB = 0x7e
#[mem8, idx8]
func change_to_swarming_entity(entityId : u8 in x) : bool in carry {
    mem16();
    #[mem16] {
        (&SoA.process_function[0] as *u16)[unaligned x] = aa = &process as u16;
    }
    mem8();

    init(x, y);

    return true;
}



// Entity process routine.
//
// Called when the entity is spawned
//
// DB = 0x7e
#[mem8, idx8]
func init(entityId : u8 in x, parameter : u8 in y) {

    y = x;
    {
        // Read the next value in OffsetTable
        x = offsetTableIndex;
        x++;
        if x >= sizeof(typeof(OffsetTable_x)) + 1{
            x = 0;
        }
        offsetTableIndex = x;

        a = OffsetTable_x[x] as u8;
        SoA_targetOffset_x[y] = a as i8;

        a = OffsetTable_y[x] as u8;
        SoA_targetOffset_y[y] = a as i8;
    }
    x = y;


    // Determine which direction best faces the player.

    a = SoA.xPos_px[x] - player.xPos.px;
    if negative {
        a = negate8(a);
    }
    _absDifference_x = a;

    a = SoA.yPos_px[x] - player.yPos.px;
    if negative {
        a = negate8(a);
    }

    if a >= _absDifference_x {
        a = SoA.yPos_px[x];
        if a >= player.yPos.px {
            ^return set_direction_north(x);
        }
        else {
            ^return set_direction_south(x);
        }
    }
    else {
        a = SoA.xPos_px[x];
        if a >= player.xPos.px {
            ^return set_direction_west(x);
        }
        else {
            ^return set_direction_east(x);
        }
    }
}



// Entity process routine.
//
// Called once per frame.
//
// DB = 0x7e
#[mem8, idx8]
func process(entityId : u8 in x) : bool in carry {

    x = base.process_collisions(x);


    if collisionState $ CollisionState.PLAYER_WEAPON_BIT {
        x = set_state__hurt(x);
    }


    // Add offset to player position to create target position (with wrapping)
    a = SoA_targetOffset_x[x] as u8;
    if negative {
        a += player.xPos.px;
        if !carry { a = 0; }
    }
    else {
        a += player.xPos.px;
        if carry { a = 0xff; }
    }
    _target_x = a;

    a = SoA_targetOffset_y[x] as u8;
    if negative {
        a += player.yPos.px;
        if !carry { a = 0; }
    }
    else {
        a += player.yPos.px;
        if carry { a = 0xff; }
    }
    _target_y = a;


    a = SoA.xPos_px[x] - _target_x;
    if negative {
        a = negate8(a);
    }
    _absDifference_x = a;

    a = SoA.yPos_px[x] - _target_y;
    if negative {
        a = negate8(a);
    }
    _absDifference_y = a;


    y = x;
    x = SoA_state[y] as u8;
    return process__state_functions[unaligned x](y);
}


const process__state_functions = [
    process__facing_south,
    process__facing_north,
    process__facing_east,
    process__facing_west,
    process__hurt,
];



// KEEP: x
//
// DB = 0x7e
#[mem8, idx8]
func _update_velocity__facing_north_or_south(entityId : u8 in x) {
    y = a = SoA.xPos_px[unaligned x] - _target_x;

    mem16();
    #[mem16] {
        aa = 0;

        // carry contains comparison from subtraction above
        if carry {
            if y >= X_ALT_VELOCITY_THRESHOLD + 1 {
                aa = -ALT_SPEED as u16;
            }
        }
        else {
            if y < -X_ALT_VELOCITY_THRESHOLD as u8 {
                aa = ALT_SPEED;
            }
        }

        SoA.xVelocity[unaligned x] = aa;
    }
    mem8();
}



// KEEP: x
//
// DB = 0x7e
#[mem8, idx8]
func _update_velocity__facing_east_or_west(entityId : u8 in x) {
    y = a = SoA.yPos_px[unaligned x] - _target_y;

    mem16();
    #[mem16] {
        aa = 0;

        // carry contains comparison from subtraction above
        if carry {
            if y >= Y_ALT_VELOCITY_THRESHOLD + 1 {
                aa = -ALT_SPEED as u16;
            }
        }
        else {
            if y < -Y_ALT_VELOCITY_THRESHOLD as u8 {
                aa = ALT_SPEED;
            }
        }

        SoA.yVelocity[unaligned x] = aa;
    }
    mem8();
}



// DB = 0x7e
#[mem8, idx8]
func process__facing_south(entityId : u8 in y) : bool in carry {
    x = y;


    a = _absDifference_y + Y_TURN_THRESHOLD;
    if a < _absDifference_x {
        ^return set_direction_east_or_west(x);
    }

    a = SoA.yPos_px[unaligned x];
    if a >= _target_y {
        a -= Y_TURNAROUND_THRESHOLD;
        if !carry { a = 0; }
        if a >= _target_y {
            ^return set_direction_north(x);
        }
    }

    _update_velocity__facing_north_or_south(x);

    ^return _update_walk_animation(x);
}



// DB = 0x7e
#[mem8, idx8]
func process__facing_north(entityId : u8 in y) : bool in carry {
    x = y;


    a = _absDifference_y + Y_TURN_THRESHOLD;
    if a < _absDifference_x {
        ^return set_direction_east_or_west(x);
    }

    a = SoA.yPos_px[unaligned x];
    if a < _target_y {
        a += Y_TURNAROUND_THRESHOLD;
        if carry { a = 0xff; }
        if a < _target_y {
            ^return set_direction_south(x);
        }
    }

    _update_velocity__facing_north_or_south(x);

    return _update_walk_animation(x);
}



// DB = 0x7e
#[mem8, idx8]
func process__facing_east(entityId : u8 in y) : bool in carry {
    x = y;


    a = _absDifference_x + X_TURN_THRESHOLD;
    if a < _absDifference_y {
        ^return set_direction_north_or_south(x);
    }

    a = SoA.xPos_px[unaligned x];
    if a >= _target_x {
        a -= X_TURNAROUND_THRESHOLD;
        if !carry { a = 0; }
        if a >= _target_x {
            ^return set_direction_west(x);
        }
    }

    _update_velocity__facing_east_or_west(x);

    return _update_walk_animation(x);
}



// DB = 0x7e
#[mem8, idx8]
func process__facing_west(entityId : u8 in y) : bool in carry {
    x = y;


    a = _absDifference_x + X_TURN_THRESHOLD;
    if a < _absDifference_y {
        ^return set_direction_north_or_south(x);
    }

    a = SoA.xPos_px[unaligned x];
    if a < _target_x {
        a += X_TURNAROUND_THRESHOLD;
        if carry { a = 0xff; }
        if a < _target_x {
            ^return set_direction_east(x);
        }
    }

    _update_velocity__facing_east_or_west(x);

    return _update_walk_animation(x);
}



// returns true
//
// DB = 0x7e
#[mem8, idx8]
func _update_walk_animation(entityId : u8 in x) : bool in carry {
let _tmp = <:dpTmp0;

    SoA_animationCounter[x]--;
    if negative {
        SoA_animationCounter[x] = a = ANIMATION_DELAY - 1;

        // Increment animation Frame
        a = SoA.metaSpriteFrame[x];
        a++;
        _tmp = a = a & ANIMATION_FRAME_MASK;

        SoA.metaSpriteFrame[x] = a = (SoA.metaSpriteFrame[x] & (ANIMATION_FRAME_MASK ^ 0xff)) | _tmp;
    }

    return true;
}



// DB = 0x7e
#[mem8, idx8]
func set_direction_south(entityId : u8 in x) : bool in carry {
    SoA_state[x] = State.FACING_SOUTH;

    SoA.metaSpriteFrame[x] = ms_frames.south0;
    SoA_animationCounter[x] = 0;

    mem16();
    #[mem16] {
        SoA.xVelocity[unaligned x] = 0;
        SoA.yVelocity[unaligned x] = aa = FACING_SPEED as u16;
    }
    mem8();

    return true;
}



// DB = 0x7e
#[mem8, idx8]
func set_direction_north(entityId : u8 in x) : bool in carry {
    a = State.FACING_NORTH as u8;
    SoA_state[x] = a as State;

    SoA.metaSpriteFrame[x] = a = ms_frames.north0;
    SoA_animationCounter[x] = 0;

    mem16();
    #[mem16] {
        SoA.xVelocity[unaligned x] = 0;
        SoA.yVelocity[unaligned x] = aa = -FACING_SPEED as u16;
    }
    mem8();

    return true;
}



// DB = 0x7e
#[mem8, idx8]
func set_direction_east(entityId : u8 in x) : bool in carry {
    a = State.FACING_EAST as u8;
    SoA_state[x] = a as State;

    SoA.metaSpriteFrame[x] = a = ms_frames.east0;
    SoA_animationCounter[x] = 0;

    mem16();
    #[mem16] {
        SoA.xVelocity[unaligned x] = aa = FACING_SPEED;
        SoA.yVelocity[unaligned x] = 0;
    }
    mem8();

    return true;
}



// DB = 0x7e
#[mem8, idx8]
func set_direction_west(entityId : u8 in x) : bool in carry {
    a = State.FACING_WEST as u8;
    SoA_state[x] = a as State;

    SoA.metaSpriteFrame[x] = a = ms_frames.west0;
    SoA_animationCounter[x] = 0;

    mem16();
    #[mem16] {
        SoA.xVelocity[unaligned x] = aa = -FACING_SPEED as u16;
        SoA.yVelocity[unaligned x] = 0;
    }
    mem8();

    return true;
}



// DB = 0x7e
#[mem8, idx8]
func set_direction_north_or_south(entityId : u8 in x) : bool in carry {
    a = SoA.yPos_px[x];

    return set_direction_south(x) if a < _target_y;
    return set_direction_north(x);
}



// DB = 0x7e
#[mem8, idx8]
func set_direction_east_or_west(entityId : u8 in x) : bool in carry {
    a = SoA.xPos_px[x];

    return set_direction_east(x) if a < _target_x;
    return set_direction_west(x);
}



// Hurt
// ====

// KEEP: X
// DB = 0x7e
#[mem8, idx8]
func set_state__hurt(entityId : u8 in x) : u8 in x {
    a = State.HURT as u8;
    SoA_state[x] = a as State;

    return x;
}



// DB = 0x7e
#[mem8, idx8]
func process__hurt(entityId : u8 in y) : bool in carry {
    x = y;

    // ::TODO add reaction ::

    mem16();
    #[mem16] {
        entities.SoA.xVelocity[unaligned x] = 0;
        entities.SoA.yVelocity[unaligned x] = 0;
    }
    mem8();

    return true;
}



}

}
}

