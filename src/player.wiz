// Copyright (c) 2021, Marcus Rowe <undisbeliever@gmail.com>.
// Distributed under The MIT License, see the LICENSE file for more details.

import "memmap";

import "entities/_variables";
import "entities/_common";
import "entities/_base";

import "joypad";
import "metatiles";
import "metasprites";
import "common/math";

import "../gen/metasprites/common";
import "../gen/entities";
import "../gen/cosine-tables";


namespace player {


let ms_draw_function = ms_framesets.common.Player.drawFunction;
let ms_frame_table = ms_framesets.common.Player.frameTable;



let INITIAL_SWORD_ATTACK_POWER = 2;

let INITIAL_HEALTH = 16;



// (8:8 unsigned fixed point)
let WALK_VELOCITY = 0x0180;


// Pixels the player is to transverse before incrementing `animationFrame`
// (8:8 unsigned fixed point)
let WALK_ANIMATION_FRAME_DISTANCE = 0x0980;

let ATTACK_ANIMATION_FRAME_DELAY = 3;


// (frames)
let HURT_STATE_DURATION             = 6;


// Number of iframes to give player after rolling back a room transition.
let N_IFRAMES_AFTER_ROOM_TRANSITION_ROLLBACK = 40;

// Number of iframes to give player after the hurt push-back ends
// SHOULD BE < HURT_STATE_DURATION.
let N_IFRAMES_AFTER_HURT_PUSHBACK   = 3;


// Number of iframes after the player has been attacked
let N_IFRAMES_AFTER_ATTACKED = 30;



let N_WALK_FRAMES           = 4;

let FIRST_ATTACK_FRAME      = 4;
let N_ATTACK_FRAMES         = 4;


// ::TODO draw hurt frame ::
let HURT_ANIMATION_FRAME    = 0;



// Hardcoded player hurtbox offsets
let HURTBOX_LEFT_OFFSET = 3;
let HURTBOX_RIGHT_OFFSET = 3;
let HURTBOX_TOP_OFFSET = 2;
let HURTBOX_BOTTOM_OFFSET = 2;


// Hardcoded tile hitbox
//
// NOTE: These values must be <= 8
//
// To increase the limit, the `test_if_player_touches_a_solid_tile`, `move_entity_and_collision_test__bounded` and
// `move_entity_and_collision_test__unbounded` functions will need to be edited.
let TILE_HITBOX_HALF_WIDTH = 6;
let TILE_HITBOX_HALF_HEIGHT = 3;


// The direction the player is facing
// (used to calculate `metaSpriteFrame`)
enum FacingDirection : u8 {
    DOWN,
    UP,
    RIGHT,
    LEFT,
};

let FACING_DIRECTION_SHIFT = 3;



enum State : u8 {
    WALKING,
    ATTACKING,
    HURT,
};



in zeropage {
    // The player's hurtbox
    var playerHurtbox : entities.U8Aabb;

    // The player's hitbox
    var playerHitbox : entities.U8Aabb;
}


in wram7e {
    // The amount of health on a full HP
    //
    // MUST be a multiple of 4
    var maxHealth : u8;
}



let xPos = entities.SoA.xPos[0];
let yPos = entities.SoA.yPos[0];
let zPos = entities.SoA.zPos[0];

let previousXpos = entities.SoA.previousXpos[0];
let previousYpos = entities.SoA.previousYpos[0];

let xVelocity = entities.SoA.xVelocity[0];
let yVelocity = entities.SoA.yVelocity[0];

let tileHitbox_halfWidth = entities.SoA.tileHitbox_halfWidth[0];
let tileHitbox_halfHeight = entities.SoA.tileHitbox_halfHeight[0];

let shadowSize = entities.SoA.shadowSize[0];

let metaSpriteFrameTable = entities.SoA.metaSpriteFrameTable[0];
let metaSpriteFrame = entities.SoA.metaSpriteFrame[0];

let movementState = entities.SoA.movementState[0];
let iframeCounter = entities.SoA.iframeCounter[0];

let health = entities.SoA.health[0];
let swordAttackPower = entities.SoA.attackPower[0];

let visionA = entities.SoA.visionA[0];
let visionB = entities.SoA.visionB[0];



let state                 = <:entities.SoA.state_0[0];
let facingDirection       = >:entities.SoA.state_0[0];

// Current animation frame
let animationFrame        = <:entities.SoA.state_1[0];

// Timer used to delay the next animation frame
// (0:8:8 fixed point)
let animationFrameDelay = entities.SoA.state_2[0];





// CODE
// ====


in code {



// Initialize player.
//
// Only called once at the start of the game.
//
// DB = 0x7e
#[mem8, idx8]
inline func init() {

    a = metasprites.ShadowSize.MEDIUM as u8;
    shadowSize = a as metasprites.ShadowSize;

    xPos.px = a = 128;
    yPos.px = a = 112;

    tileHitbox_halfWidth = a = TILE_HITBOX_HALF_WIDTH;
    tileHitbox_halfHeight = a = TILE_HITBOX_HALF_HEIGHT;


    mem16();
    #[mem16] {
        xVelocity = 0;
        yVelocity = 0;
    }
    mem8();


    facingDirection = a = FacingDirection.DOWN as u8;

    a = INITIAL_HEALTH;
    health = a;
    maxHealth = a;

    swordAttackPower = a = INITIAL_SWORD_ATTACK_POWER;


    set_state__walking();

    update_metasprite_frame();
}



// Entity process routine.
//
// Called once per frame.
//
// INPUT: entityId (Y) is always 0
//
// DB = 0x7e
#[mem8, idx8]
func process(entityId : u8 in y) {

    a = state as u8;
    if a == State.ATTACKING as u8 {
        process__attack();
    }
    else if a == State.HURT as u8 {
        process__hurt();
    }
    else {
        // state == WALKING
        process__walking();
    }

    metatiles.move_entity_and_collision_test__unbounded(PLAYER_ENTITY_ID);

    metatiles.process_interactive_tiles__player();


    // Update animation
    a = state as u8;
    if a == State.ATTACKING as u8 {
    }
    else if a == State.HURT as u8 {
        update_animation__hurt();
    }
    else {
        // state == WALKING
        update_animation__walking();
    }
}



// Called whenever an entity collides with the player's hitbox.
//
// PARAM: entityId - the entity that collided with `playerHitbox`.
//
// DB = 0x7e
#[mem8, idx8]
inline func hitbox_collided_with_entity__inline(enemyEntityId : u8 in y) {

    // ::TODO add a has-sword-particle flag to entity::

    entities.spawn_entity(a = entities.base.collisionCentre_x,
                          a = entities.base.collisionCentre_y,
                          a = entities.EntityTypes.sword_particles as u8,
                          y = 0);
}



// Set the player's velocity to zero
//
// DB = 0x7e
#[mem8, idx8]
func zero_velocity() {
    mem16();
    #[mem16] {
        xVelocity = 0;
        yVelocity = 0;
    }
    mem8();
}



// Enable invincibility frames (after rolling back a room transition)
//
// DB = 0x7e
#[mem8, idx8]
inline func set_iframes_after_room_transition_rollback() {
    iframeCounter = a = N_IFRAMES_AFTER_ROOM_TRANSITION_ROLLBACK;
}




// Collisions
// ==========


// Update player's hitbox and hurtbox
//
// DB = 0x7e
#[mem8, idx16]
inline func update_collision_boxes__inline() {
    // Extend 8 bit metaSpriteFrame to 16 bit AA
    #[mem16] {
        // DP = 0
        aa = direct_page;
    }
    a = metaSpriteFrame;

    mem16_idx16();
    #[mem16, idx16] {
        // Safe: (aa << 1) will never set carry
        xx = aa = (aa << 1) +# metaSpriteFrameTable;
        xx = aa = metasprites.MetaSpriteFrameTableOffset[unaligned xx];
    }
    mem8();

    // xx = msFrameAddr

    _update_player_hitbox(xx);
    _update_player_hurtbox(xx);
}



// Add the player's unsigned xPos to a signed i8 accumulator with clamping.
//
// ASSUMES: negative flag contains the MSB of A (the previous instruction is an `lda`).
//
// KEEP: xx & yy
//
// DB = 0x7e
#[mem8, idx16]
inline func __add_xPos_to_i8a_clamp(a : u8 in a, n : bool in negative) : u8 in a {
    if negative {
        a += xPos.px;
        return a if carry;
            a = 0;
    }
    else {
        a += xPos.px;
        return a if !carry;
            a = 0xff;
    }

    return a;
}


// Add the player's unsigned yPos to a signed i8 accumulator with clamping.
//
// ASSUMES: negative flag contains the MSB of A (the previous instruction is an `lda`).
//
// KEEP: xx & yy
//
// DB = 0x7e
#[mem8, idx16]
inline func __add_yPos_to_i8a_clamp(a : u8 in a, n : bool in negative) : u8 in a {
    if negative {
        a += yPos.px;
        return a if carry;
            a = 0;
    }
    else {
        a += yPos.px;
        return a if !carry;
            a = 0xff;
    }

    return a;
}



// Update player hitbox
//
// Called once per frame
//
// KEEP: xx
//
// DB = 0x7e
#[mem8, idx16]
inline func _update_player_hitbox(msFrameAddr : u16 in xx) {

    // Add i8 signed offset to player's u8 unsigned position (with clamping)

    a = metasprites.MsDataFormat.hitbox_left[xx] as u8;
    if negative {
        // Putting the no-hitbox test here as it is faster.
        if a == metasprites.MsDataFormat.NO_AABB_VALUE {
            // MS frame has no hitbox
            a = 0xff;
            playerHitbox.top = a;
            playerHitbox.bottom = 0;
            playerHitbox.left = a;
            playerHitbox.right = 0;
            return;
        }

        a += xPos.px;
        if !carry {
            a = 0;
        }
    }
    else {
        a += xPos.px;
        if carry {
            a = 0xff;
        }
    }
    playerHitbox.left = a;


    a = metasprites.MsDataFormat.hitbox_right[xx] as u8;
    __add_xPos_to_i8a_clamp(a, negative);
    playerHitbox.right = a;


    a = metasprites.MsDataFormat.hitbox_top[xx] as u8;
    __add_yPos_to_i8a_clamp(a, negative);
    playerHitbox.top = a;


    a = metasprites.MsDataFormat.hitbox_bottom[xx] as u8;
    __add_yPos_to_i8a_clamp(a, negative);
    playerHitbox.bottom = a;
}



// Update player hurtbox
//
// Called once per frame
//
// DB = 0x7e
#[mem8, idx16]
inline func _update_player_hurtbox(msFrameAddr : u16 in xx) {


    a = iframeCounter;
    if !zero {
        a--;
        iframeCounter = a;

        // player has no hurtbox
        a = 0xff;
        playerHurtbox.top = a;
        playerHurtbox.bottom = 0;
        playerHurtbox.left = a;
        playerHurtbox.right = 0;
    }
    else {
        // Add i8 signed offset to player's u8 unsigned position (with clamping)

        a = metasprites.MsDataFormat.hurtbox_left[xx] as u8;
        if negative {
            // Putting the no-hurtbox test here as it is faster.
            if a == metasprites.MsDataFormat.NO_AABB_VALUE {
                // MS frame has no hurtbox
                a = 0xff;
                playerHurtbox.top = a;
                playerHurtbox.bottom = 0;
                playerHurtbox.left = a;
                playerHurtbox.right = 0;
                return;
            }

            a += xPos.px;
            if !carry {
                a = 0;
            }
        }
        else {
            a += xPos.px;
            if carry {
                a = 0xff;
            }
        }
        playerHurtbox.left = a;


        a = metasprites.MsDataFormat.hurtbox_right[xx] as u8;
        __add_xPos_to_i8a_clamp(a, negative);
        playerHurtbox.right = a;


        a = metasprites.MsDataFormat.hurtbox_top[xx] as u8;
        __add_yPos_to_i8a_clamp(a, negative);
        playerHurtbox.top = a;

        a = metasprites.MsDataFormat.hurtbox_bottom[xx] as u8;
        __add_yPos_to_i8a_clamp(a, negative);
        playerHurtbox.bottom = a;
    }
}




// PROCESS MOVEMENT
// ================


// Process player direction and update velocity.
//
// DB = 0x7e
#[mem8, idx8]
func process_dpad_update_velocity() {

    a = joypad.current_h;

    if a & joypad.JOYH.UP != 0 {
        if a & joypad.JOYH.LEFT != 0 {
            ^return process_direction_north_west();
        }
        if a & joypad.JOYH.RIGHT != 0 {
            ^return process_direction_north_east();
        }
        ^return process_direction_north();
    }

    if a & joypad.JOYH.DOWN != 0 {
        if a & joypad.JOYH.LEFT != 0 {
            ^return process_direction_south_west();
        }
        if a & joypad.JOYH.RIGHT != 0{
            ^return process_direction_south_east();
        }
        ^return process_direction_south();
    }

    if a & joypad.JOYH.LEFT != 0 {
        ^return process_direction_west();
    }

    if a & joypad.JOYH.RIGHT != 0{
        ^return process_direction_east();
    }

    return process_direction_stationary();
}



// DB = 0x7e
#[mem8, idx8]
func process_direction_stationary() {
    // Do not change facingDirection

    zero_x_velocity();
    zero_y_velocity();
}



// DB = 0x7e
#[mem8, idx8]
func process_direction_north() {
    facingDirection = a = FacingDirection.UP as u8;

    zero_x_velocity();
    decrement_y_velocity();
}



// DB = 0x7e
#[mem8, idx8]
func process_direction_north_east() {
    a = facingDirection;
    if a == FacingDirection.LEFT as u8 {
        facingDirection = a = FacingDirection.UP as u8;
    }
    if a == FacingDirection.DOWN as u8 {
        facingDirection = a = FacingDirection.RIGHT as u8;
    }

    increment_x_velocity();
    decrement_y_velocity();
}



// DB = 0x7e
#[mem8, idx8]
func process_direction_east() {
    facingDirection = a = FacingDirection.RIGHT as u8;

    increment_x_velocity();
    zero_y_velocity();
}



// DB = 0x7e
#[mem8, idx8]
func process_direction_south_east() {
    a = facingDirection;
    if a == FacingDirection.LEFT as u8 {
        facingDirection = a = FacingDirection.DOWN as u8;
    }
    if a == FacingDirection.UP as u8 {
        facingDirection = a = FacingDirection.RIGHT as u8;
    }

    increment_x_velocity();
    increment_y_velocity();
}



// DB = 0x7e
#[mem8, idx8]
func process_direction_south() {
    facingDirection = a = FacingDirection.DOWN as u8;

    zero_x_velocity();
    increment_y_velocity();
}



// DB = 0x7e
#[mem8, idx8]
func process_direction_south_west() {
    a = facingDirection;
    if a == FacingDirection.RIGHT as u8 {
        facingDirection = a = FacingDirection.DOWN as u8;
    }
    if a == FacingDirection.UP as u8 {
        facingDirection = a = FacingDirection.LEFT as u8;
    }

    decrement_x_velocity();
    increment_y_velocity();
}



// DB = 0x7e
#[mem8, idx8]
func process_direction_west() {
    facingDirection = a = FacingDirection.LEFT as u8;

    decrement_x_velocity();
    zero_y_velocity();
}



// DB = 0x7e
#[mem8, idx8]
func process_direction_north_west() {
    a = facingDirection;
    if a == FacingDirection.RIGHT as u8 {
        facingDirection = a = FacingDirection.UP as u8;
    }
    if a == FacingDirection.DOWN as u8 {
        facingDirection = a = FacingDirection.LEFT as u8;
    }

    decrement_x_velocity();
    decrement_y_velocity();
}



// DB = 0x7e
#[mem8, idx8]
func decrement_x_velocity() {

    // ::TODO add acceleration and friction::
    <:xVelocity = a = <:-WALK_VELOCITY;
    >:xVelocity = a = >:-WALK_VELOCITY;
}



// DB = 0x7e
#[mem8, idx8]
func zero_x_velocity() {

    // ::TODO add friction::
    <:xVelocity = 0;
    >:xVelocity = 0;
}



// DB = 0x7e
#[mem8, idx8]
func increment_x_velocity() {

    // ::TODO add acceleration and friction::
    <:xVelocity = a = <:WALK_VELOCITY;
    >:xVelocity = a = >:WALK_VELOCITY;
}



// DB = 0x7e
#[mem8, idx8]
func decrement_y_velocity() {

    // ::TODO add acceleration and friction::
    <:yVelocity = a = <:-WALK_VELOCITY;
    >:yVelocity = a = >:-WALK_VELOCITY;
}



// DB = 0x7e
#[mem8, idx8]
func zero_y_velocity() {

    // ::TODO add friction::
    <:yVelocity = 0;
    >:yVelocity = 0;
}



// DB = 0x7e
#[mem8, idx8]
func increment_y_velocity() {

    // ::TODO add acceleration and friction::
    <:yVelocity = a = <:WALK_VELOCITY;
    >:yVelocity = a = >:WALK_VELOCITY;
}



// WALKING STATE
// =============


// DB = 0x7e
#[mem8, idx8]
func set_state__walking() {
    state = State.WALKING as u8;


    animationFrame = 0;

    <:animationFrameDelay = 0;
    >:animationFrameDelay = 0;
}



// DB = 0x7e
#[mem8, idx8]
func process__walking() {
    process_dpad_update_velocity();


    a = joypad.input_buffers.attack;
    if !zero {
        set_state__attacking();
    }
}



// Update animation frame for WALKING state.
//
// DB = 0x7e
#[mem8, idx8]
func update_animation__walking() {

let _tmp = zpTmp_word_0;

    mem16();
    #[mem16] {

        // aa = max(abs(xVelocity), abs(yVelocity))
        {
            aa = xVelocity;
            if negative {
                // negate
                aa ^= 0xffff;
                aa++;
            }
            _tmp = aa;

            aa = yVelocity;
            if negative {
                // negate
                aa ^= 0xffff;
                aa++;
            }

            if aa < _tmp {
                aa = _tmp;
            }
        }

        if aa == 0 {
            // No movement: force standing frame

            animationFrame = y = 0;
            animationFrameDelay = 0;
        }
        else {
            // Movement

            aa += animationFrameDelay;
            if aa >= WALK_ANIMATION_FRAME_DISTANCE {
                aa = 0;

                // increment animationFrame (with wrapping)
                y = animationFrame;
                y++;
                if y >= N_WALK_FRAMES {
                    y = 0;
                }
                animationFrame = y;
            }

            animationFrameDelay = aa;
        }
    }
    mem8();

    return update_metasprite_frame();
}



// Calculate metaSpriteFrame value
//
// DB = 0x7e
#[mem8, idx8]
func update_metasprite_frame() {

    a = ((facingDirection as u8) <<< FACING_DIRECTION_SHIFT) | animationFrame;

    metaSpriteFrame = a;
}



// ATTACKING STATE
// ===============


// DB = 0x7e
#[mem8, idx8]
func set_state__attacking() {
    state = a = State.ATTACKING as u8;

    // Stand still while attacking
    <:xVelocity = 0;
    >:xVelocity = 0;
    <:yVelocity = 0;
    >:yVelocity = 0;

    animationFrame = a = FIRST_ATTACK_FRAME;
    <:animationFrameDelay = a = ATTACK_ANIMATION_FRAME_DELAY - 1;
}



// DB = 0x7e
#[mem8, idx8]
func process__attack() {

    (<:animationFrameDelay)--;
    if negative {
        <:animationFrameDelay = a = ATTACK_ANIMATION_FRAME_DELAY - 1;

        a = animationFrame;
        a++;
        if a == FIRST_ATTACK_FRAME + N_ATTACK_FRAMES {
            ^return set_state__walking();
        }
        animationFrame = a;
    }

    update_metasprite_frame();
}



// HURT STATE
// ==========


// DB = 0x7e
#[mem8, idx8]
inline func set_state_hurt__enemy_collision__inline(enemyEntityId : u8 in y) {
    a = state as u8;
    if a != State.HURT as u8 {
        _set_state__hurt__enemy_collision(y);
    }
}



// DB = 0x7e
#[mem8, idx8]
func _set_state__hurt__enemy_collision(enemyEntityId : u8 in y) {
    state = a = State.HURT as u8;

    x = calc_angle_32x2(a = entities.SoA.previousXpos[unaligned y],
                        a = entities.SoA.previousYpos[unaligned y],
                        player.previousXpos,
                        player.previousYpos);

    mem16();
    #[mem16] {
        xVelocity = aa = CosineTables.PlayerHurtVelocity[unaligned x] as u16;

        #[idx16] {
            xx = aa = (xx + CosineTables.SINE_OFFSET) & CosineTables.TABLE_MASK;
        }

        yVelocity = aa = CosineTables.PlayerHurtVelocity[unaligned x] as u16;
    }
    mem8();


    iframeCounter = a = N_IFRAMES_AFTER_ATTACKED;

    <:animationFrameDelay = a = HURT_STATE_DURATION;


    animationFrame = a = HURT_ANIMATION_FRAME;
    ^return update_metasprite_frame();
}



// DB = 0x7e
#[mem8, idx8]
func process__hurt() {
    // Frozen until `animationFrameDelay` ends
    a = <:animationFrameDelay;
    if !zero {
        a--;
        <:animationFrameDelay = a;
    }
    else {
        a = iframeCounter;
        if zero {
            iframeCounter = a = N_IFRAMES_AFTER_HURT_PUSHBACK;
        }

        ^return set_state__walking();
    }
}



// DB = 0x7e
#[mem8, idx8]
func update_animation__hurt() {
}


}

}

