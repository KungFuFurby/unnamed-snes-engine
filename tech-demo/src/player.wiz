// Copyright (c) 2021, Marcus Rowe <undisbeliever@gmail.com>.
// Distributed under The MIT License, see the LICENSE file for more details.

import "memmap";

import "engine/entity_api";
import "entities/_base";

// ::TODO remove this import::
import "engine/game/entityloop";

import "engine/audio";
import "engine/common/math";
import "engine/game/gamestate";
import "engine/game/metatiles";
import "engine/game/metasprites";

import "joypad";

import "gen/enums";
import "gen/entities";
import "gen/cosine-tables";


namespace player {

// ::TODO adjust sword hitbox (I'm not sure if it is too big or not)::


// Address of the player's `metasprites.MsFramesetFormat` data
let MS_FS_DATA_ADDR = 0x0000;



let _set_ms_animation = metasprites.set_player_animation;
let _set_ms_animation_if_changed = metasprites.set_player_animation_if_changed;
let _is_ms_non_looping_animation_running = metasprites.is_player_non_looping_animation_running;



// The player state stored within the gamestate.
struct GameState__PlayerState {
    xPos                : u8,
    yPos                : u8,
    zPos                : u8,

    health              : u8,
    maxHealth           : u8,
    swordAttackPower    : u8,

    state               : u8,
    facingDirection     : u8,
};

let InitialPlayerState = GameState__PlayerState{

    xPos                = DISPLAY_WIDTH / 2,
    yPos                = DISPLAY_HEIGHT * 2 / 3,
    zPos                = 0,

    swordAttackPower    = 2,
    health              = 16,
    maxHealth           = 16,

    state               = State.WALKING as u8,
    facingDirection     = FacingDirection.UP as u8,
};


// If the player health is below this value, sound a different 'player hurt' sound effect.
let LOW_HEALTH_ALARM = 4;


// How far the player can enter a doorway before the game prevents the player from
// leaving by pressing an off-axis direction (ie, pressing left in an up doorway).
let DOORWAY_LEAVE_DISTANCE = 14;

// Offset to add to the `altAxisTarget` when entering a door from the left or right.
let DOORWAY_X_DIRECTION_OFFSET = 4;



// Distance between the player's y-position and the item above their head (if any)
let ITEM_ABOVE_HEAD_Y_OFFSET = 13;



// (8:8 unsigned fixed point)
let WALK_VELOCITY = 0x0180;


// (8:8 unsigned fixed point)
let DOORWAY_VELOCITY               = 0x0180;
let DOORWAY_DIAGONAL_MAIN_VELOCITY = 0x0040;
let DOORWAY_DIAGONAL_ALT_VELOCITY  = 0x00D0;

// Ensures player cannot spam attack inside a doorway and remain unhurt.
// (8:8 unsigned fixed point)
let ATTACKING_IN_DOORWAY_VELOCITY  = 0x0110 / 12;


// Knock back velocity when the player stationary and hurt by an environment hazard
// (7:8 unsigned fixed point)
let STATIONARY_PLAYER__ENVIRONMENTAL_DAMAGE_VELOCITY = 0x0180;


// Number of iframes to give player after rolling back a room transition.
let N_IFRAMES_AFTER_ROOM_TRANSITION_ROLLBACK = 40;


// Number of iframes after the player has been attacked
let N_IFRAMES_AFTER_ATTACKED = 40;

// Number of iframes after the player has been hurt by environmental damage
let N_IFRAMES_AFTER_ENVIRONMENTAL_DAMAGE = 30;


// Number of frames the player cannot move after being attacked by an enemy
let N_HURT_FRAMES__ENEMY = 6;

// Number of frames the player cannot move after being attacked by the environment
let N_HURT_FRAMES__ENVIRONMENT = 5;



// ::TODO draw hurt animation ::

let WALKING_MS_ANIMATION_OFFSET     = 0;
let ATTACKING_MS_ANIMATION_OFFSET   = 4;
let HURT_MS_ANIMATION_OFFSET        = 8;
let HOLDING_MS_ANIMATION_OFFSET     = 12;



// Hardcoded player hurtbox offsets
let HURTBOX_LEFT_OFFSET = 3;
let HURTBOX_RIGHT_OFFSET = 3;
let HURTBOX_TOP_OFFSET = 2;
let HURTBOX_BOTTOM_OFFSET = 2;


// Hardcoded tile hitbox
//
// NOTE: These values must be <= 8
//
// To increase the limit, the `test_if_player_touches_a_solid_tile`, `move_entity_and_collision_test__bounded` and
// `move_entity_and_collision_test__unbounded` functions will need to be edited.
let TILE_HITBOX_HALF_WIDTH = 6;
let TILE_HITBOX_HALF_HEIGHT = 3;


// The direction the player is facing
enum FacingDirection : u8 {
    DOWN,
    UP,
    RIGHT,
    LEFT,
};

let FACING_DIRECTION_SHIFT = 3;



enum State : u8 {
    WALKING                 =  0,
    ATTACKING               =  2,
    HURT                    =  4,
    WALK_THROUGH_DOORWAY    =  6,   // NOTE: Read by the monster_doors room event
    ATTACKING_IN_DOORWAY    =  8,   // NOTE: Read by the monster_doors room event
    HOLDING_BOMB            = 10,   // NOTE: Used by player_bomb entity
};



// Maximum number of frames for various states
// (used by the `watchdogTimer`)
namespace Watchdog {
    let MAX_ATTACK_FRAMES = 20;
    let MAX_HURT_STATE_FRAMES = 30;
}



in zeropage {
    // The player's hurtbox
    var playerHurtbox : entities.U8Aabb;

    // The player's hitbox
    var playerHitbox : entities.U8Aabb;
}


in wram7e_roomstate {
    // The amount of health on a full HP
    //
    // MUST be a multiple of 4
    var maxHealth : u8;



var state                   : u8 in entities.SoA.var_0_l[0];

var facingDirection         : u8 in entities.SoA.var_0_h[0];

// Used by the hurt state
var previousState           : u8 in entities.SoA.var_1_l[0];
var hurtTimer               : u8 in entities.SoA.var_1_h[0];


// Decremented once every frame.  If negative, player's state is reset.
var watchdogTimer           : u8 in entities.SoA.var_2_l[0];


// MetaSprite to draw above the player's head.
// Used by the `HOLDING_BOMB` state.
// (word address pointing to a `metasprites.MsDataFormat` data structure)
var itemAboveHead_msFrameAddr @ &entities.SoA.var_3[0] : u16;

}




// CODE
// ====


in code {



// Initialize player.
//
// Must be called after gamestate is setup.
//
// DB = 0x7e
#[mem8, idx8]
inline func init() {

    a = metasprites.ShadowSize.MEDIUM as u8;
    shadowSize = a as metasprites.ShadowSize;

    tileHitbox_halfWidth = a = TILE_HITBOX_HALF_WIDTH;
    tileHitbox_halfHeight = a = TILE_HITBOX_HALF_HEIGHT;


    mem16();
    #[mem16] {
        xVelocity = 0;
        yVelocity = 0;

        itemAboveHead_msFrameAddr = 0;
    }
    mem8();


    restore_player_state__inline();

    // Reset MetaSprite Animations
    init_metasprites();
}



// Initialise the player's MetaSprites.
//
// Called on init or when MetaSprite resources have changed.
//
// DB = 0x7e
#[mem8, idx8]
func init_metasprites() {
    // ASSUMES: player entityId is 0

    mem16();
    #[mem16] {
        // Set player's ms_draw function
        aa = ms_draw_function as u16;
        entities.SoA.ms_draw_function[0] = aa as func(u16 in yy, u16 in metasprites.xPos, u16 in metasprites.yPos);

        entities.SoA.metaSpriteFrameTable[0] = aa = metasprites.MsFsData.frameTable[unaligned MS_FS_DATA_ADDR];
        entities.SoA.msAnimationTable[0] = aa = metasprites.MsFsData.animationTable[unaligned MS_FS_DATA_ADDR];
    }
    mem8();

    metasprites.init_player_metasprite_animation__inline();

    metasprites.init_entity_metasprite_animation__after_init(PLAYER_ENTITY_ID);
}



// GAMESTATE FUNCTIONS
// ===================



// Save the player state into the GameStateData
//
// Called on a successful room transition.
//
// DB = 0x7e
#[mem8, idx8]
inline func save_player_state__inline() {
    gamestate.data.playerState.xPos = a = xPos.px;
    gamestate.data.playerState.yPos = a = yPos.px;
    gamestate.data.playerState.zPos = a = zPos;

    gamestate.data.playerState.health = a = health;
    gamestate.data.playerState.maxHealth = a = maxHealth;

    gamestate.data.playerState.swordAttackPower = a = swordAttackPower;

    a = state as u8;
    if a == State.HURT as u8 {
        // Ensure the previous state does not disappear when restoring a gamestate backup.
        //
        // (required to ensure a player holding a bomb in the HURT state will still hold the
        //  bomb when restoring the gamestate backup)
        a = previousState as u8;
    }
    gamestate.data.playerState.state = a;

    gamestate.data.playerState.facingDirection = a = facingDirection;
}



// Reset the player state
//
// Called by `gamestate.continue_game()`
//
// DB = 0x7e
#[mem8, idx8]
inline func continue_player_gamestate__inline() {

    gamestate.data.playerState.health = a = gamestate.data.playerState.maxHealth;

    gamestate.data.playerState.state = State.WALKING as u8;

    gamestate.data.playerState.facingDirection = a = InitialPlayerState.facingDirection;
}



// restore player state from the GameStateData
//
// DB = 0x7e
#[mem8, idx8]
inline func restore_player_state__inline() {
    xPos.sx = 0;
    xPos.px = a = gamestate.data.playerState.xPos;

    yPos.sx = 0;
    yPos.px = a = gamestate.data.playerState.yPos;

    zPos = a = gamestate.data.playerState.zPos;

    health = a = gamestate.data.playerState.health;
    maxHealth = a = gamestate.data.playerState.maxHealth;

    swordAttackPower = a = gamestate.data.playerState.swordAttackPower;

    facingDirection = a = gamestate.data.playerState.facingDirection & 3;


    a = gamestate.data.playerState.state;
    if a == State.WALK_THROUGH_DOORWAY as u8 || a == State.ATTACKING_IN_DOORWAY as u8 {
        set_state__walk_through_doorway__restore_player_state();
    }
    else if a == State.HOLDING_BOMB as u8 {
        set_state__holding_bomb__restore_player_state();
    }
    else {
        set_state__walking();
        _set_ms_animation(facingDirection);
    }
}



// METASPRITES
// ===========



// Metasprite drawing function.
//
// Draws the player and the `itemAboveHead_msFrameAddr` MetaSprite (if non-zero)
//
// DB = 0x7e
#[mem8, idx16]
func ms_draw_function(msFrame : u16 in yy, ms_xPos : u16 in metasprites.xPos, ms_yPos : u16 in metasprites.yPos) {

// Safe (for now) - MS drawing functions do not use zpTmp variables.
var _tmpX : u16 in zpTmp_word_0;
var _tmpY : u16 in zpTmp_word_1;

    // I need to save a copy of metasprite position
    // Required when holding items during room transitions (cannot calculate metasprite position from player position).
    _tmpX = xx = metasprites.xPos;
    _tmpY = xx = metasprites.yPos;

    metasprites.drawing_functions.dynamic_pattern(yy, metasprites.xPos, metasprites.yPos);

    // The metasprite drawing function changes the metasprite xPos/yPos variables


    yy = itemAboveHead_msFrameAddr;
    if !zero {
        mem16();
        #[mem16] {
            metasprites.xPos = aa = _tmpX;
            metasprites.yPos = aa = _tmpY - ITEM_ABOVE_HEAD_Y_OFFSET;
        }
        mem8();

        ^return metasprites.drawing_functions.dynamic_pattern(yy, metasprites.xPos, metasprites.yPos);
    }
}



// PROCESS FUNCTIONS
// =================


// Entity process routine.
//
// Called once per frame.
//
// REQUIRES: entities.currentEntityId = PLAYER_ENTITY_ID;
//
// DB = 0x7e
#[mem8, idx8]
inline func process() {

    // Decrement watchdog timer.
    //
    // This fixes a hard-lock that can occur when a state is waiting for a MetaSprite animation to
    // end and the current animation loops (and thus never ends).
    watchdogTimer--;
    if negative {
        a = state;
        if a == State.ATTACKING_IN_DOORWAY as u8 {
            set_state__walk_through_doorway__after_attacking_in_doorway();
        }
        else {
            set_state__walking();
        }
    }


    x = state as u8;
    process__state_functions[unaligned x]();
}


const process__state_functions = [
    process__walking,
    process__attacking,
    process__hurt,
    process__walk_through_doorway,
    process__attacking_in_doorway,
    process__holding_bomb,
];



// Called whenever an entity collides with the player's hitbox.
//
// PARAM: entityId - the entity that collided with `playerHitbox`.
//
// DB = 0x7e
#[mem8, idx8]
inline func hitbox_collided_with_entity__inline(enemyEntityId : u8 in y) {

    // ::TODO add a has-sword-particle flag to entity::

    entityloop.spawn_entity(a = entities.base.collisionCentre_x,
                            a = entities.base.collisionCentre_y,
                            a = entities.EntityTypes.sword_particles as u8,
                            y = 0);
}



// Set the player's velocity to zero
//
// DB = 0x7e
#[mem8, idx8]
func zero_velocity() {
    mem16();
    #[mem16] {
        xVelocity = 0;
        yVelocity = 0;
    }
    mem8();
}



// Move the player and process any tile collisions and interactive tiles.
//
// DB = 0x7e
#[mem8, idx8]
func move_player_with_tile_tests() {
    metatiles.move_entity_and_collision_test__unbounded(PLAYER_ENTITY_ID);
    metatiles.process_interactive_tiles__player();
}



// Add the player's velocity to the player's position (with bounds checking)
//
// NOTE: This function will not preform any collision checks or interactive tile tests.
//
// DB = 0x7e
#[mem8, idx8]
func add_velocity_to_positon_without_collsion_checks() {
    let MAX_Y_POS = DISPLAY_HEIGHT << 8;

    mem16();
    #[mem16] {
        aa = xVelocity;
        if negative {
            aa += entities.SoA.xPos_u16[PLAYER_ENTITY_ID];
            if !carry { aa = 0; }
        }
        else {
            aa += entities.SoA.xPos_u16[PLAYER_ENTITY_ID];
            if carry { aa = 0xff00; }
        }
        entities.SoA.xPos_u16[PLAYER_ENTITY_ID] = aa;


        aa = yVelocity;
        if negative {
            aa += entities.SoA.yPos_u16[PLAYER_ENTITY_ID];
            if !carry { aa = 0; }
        }
        else {
            aa += entities.SoA.yPos_u16[PLAYER_ENTITY_ID];
            if carry || aa >= MAX_Y_POS { aa = MAX_Y_POS; }
        }
        entities.SoA.yPos_u16[PLAYER_ENTITY_ID] = aa;
    }
    mem8_idx8();
}



// Enable invincibility frames (after rolling back a room transition)
//
// DB = 0x7e
#[mem8, idx8]
inline func set_iframes_after_room_transition_rollback() {
    iframeCounter = a = N_IFRAMES_AFTER_ROOM_TRANSITION_ROLLBACK;
}




// Collisions
// ==========


// Update player's hitbox and hurtbox
//
// DB = 0x7e
#[mem8, idx16]
inline func update_collision_boxes__inline() {
    xx = entities.SoA.msFrameAddr[PLAYER_ENTITY_ID];

    _update_player_hitbox(xx);
    _update_player_hurtbox(xx);
}



// Add the player's unsigned xPos to a signed i8 accumulator with clamping.
//
// ASSUMES: negative flag contains the MSB of A (the previous instruction is an `lda`).
//
// KEEP: xx & yy
//
// DB = 0x7e
#[mem8, idx16]
inline func __add_xPos_to_i8a_clamp(i8a : u8 in a, n : bool in negative) : u8 in a {
    if negative {
        a += xPos.px;
        return a if carry;
            a = 0;
    }
    else {
        a += xPos.px;
        return a if !carry;
            a = 0xff;
    }

    return a;
}


// Add the player's unsigned yPos to a signed i8 accumulator with clamping.
//
// ASSUMES: negative flag contains the MSB of A (the previous instruction is an `lda`).
//
// KEEP: xx & yy
//
// DB = 0x7e
#[mem8, idx16]
inline func __add_yPos_to_i8a_clamp(i8a : u8 in a, n : bool in negative) : u8 in a {
    if negative {
        a += yPos.px;
        return a if carry;
            a = 0;
    }
    else {
        a += yPos.px;
        return a if !carry;
            a = 0xff;
    }

    return a;
}



// Update player hitbox
//
// Called once per frame
//
// KEEP: xx
//
// DB = 0x7e
#[mem8, idx16]
inline func _update_player_hitbox(msFrameAddr : u16 in xx) {

    // Add i8 signed offset to player's u8 unsigned position (with clamping)

    a = metasprites.MsDataFormat.hitbox_left[xx] as u8;
    if negative {
        // Putting the no-hitbox test here as it is faster.
        if a == metasprites.MsDataFormat.NO_AABB_VALUE {
            // MS frame has no hitbox
            a = 0xff;
            playerHitbox.top = a;
            playerHitbox.bottom = 0;
            playerHitbox.left = a;
            playerHitbox.right = 0;
            return;
        }

        a += xPos.px;
        if !carry {
            a = 0;
        }
    }
    else {
        a += xPos.px;
        if carry {
            a = 0xff;
        }
    }
    playerHitbox.left = a;


    a = metasprites.MsDataFormat.hitbox_right[xx] as u8;
    __add_xPos_to_i8a_clamp(a, negative);
    playerHitbox.right = a;


    a = metasprites.MsDataFormat.hitbox_top[xx] as u8;
    __add_yPos_to_i8a_clamp(a, negative);
    playerHitbox.top = a;


    a = metasprites.MsDataFormat.hitbox_bottom[xx] as u8;
    __add_yPos_to_i8a_clamp(a, negative);
    playerHitbox.bottom = a;
}



// Update player hurtbox
//
// Called once per frame
//
// DB = 0x7e
#[mem8, idx16]
inline func _update_player_hurtbox(msFrameAddr : u16 in xx) {


    a = iframeCounter;
    if !zero {
        a--;
        iframeCounter = a;

        // player has no hurtbox
        a = 0xff;
        playerHurtbox.top = a;
        playerHurtbox.bottom = 0;
        playerHurtbox.left = a;
        playerHurtbox.right = 0;
    }
    else {
        // Add i8 signed offset to player's u8 unsigned position (with clamping)

        a = metasprites.MsDataFormat.hurtbox_left[xx] as u8;
        if negative {
            // Putting the no-hurtbox test here as it is faster.
            if a == metasprites.MsDataFormat.NO_AABB_VALUE {
                // MS frame has no hurtbox
                a = 0xff;
                playerHurtbox.top = a;
                playerHurtbox.bottom = 0;
                playerHurtbox.left = a;
                playerHurtbox.right = 0;
                return;
            }

            a += xPos.px;
            if !carry {
                a = 0;
            }
        }
        else {
            a += xPos.px;
            if carry {
                a = 0xff;
            }
        }
        playerHurtbox.left = a;


        a = metasprites.MsDataFormat.hurtbox_right[xx] as u8;
        __add_xPos_to_i8a_clamp(a, negative);
        playerHurtbox.right = a;


        a = metasprites.MsDataFormat.hurtbox_top[xx] as u8;
        __add_yPos_to_i8a_clamp(a, negative);
        playerHurtbox.top = a;

        a = metasprites.MsDataFormat.hurtbox_bottom[xx] as u8;
        __add_yPos_to_i8a_clamp(a, negative);
        playerHurtbox.bottom = a;
    }
}




// PROCESS MOVEMENT
// ================


// Process player direction and update velocity.
//
// DB = 0x7e
#[mem8, idx8]
func process_dpad_update_velocity() {

    a = joypad.current_h;

    if a & joypad.JOYH.UP != 0 {
        if a & joypad.JOYH.LEFT != 0 {
            ^return process_direction_north_west();
        }
        if a & joypad.JOYH.RIGHT != 0 {
            ^return process_direction_north_east();
        }
        ^return process_direction_north();
    }

    if a & joypad.JOYH.DOWN != 0 {
        if a & joypad.JOYH.LEFT != 0 {
            ^return process_direction_south_west();
        }
        if a & joypad.JOYH.RIGHT != 0{
            ^return process_direction_south_east();
        }
        ^return process_direction_south();
    }

    if a & joypad.JOYH.LEFT != 0 {
        ^return process_direction_west();
    }

    if a & joypad.JOYH.RIGHT != 0{
        ^return process_direction_east();
    }

    return process_direction_stationary();
}



// DB = 0x7e
#[mem8, idx8]
func process_direction_stationary() {
    // Do not change facingDirection

    zero_x_velocity();
    zero_y_velocity();
}



// DB = 0x7e
#[mem8, idx8]
func process_direction_north() {
    facingDirection = a = FacingDirection.UP as u8;

    zero_x_velocity();
    decrement_y_velocity();
}



// DB = 0x7e
#[mem8, idx8]
func process_direction_north_east() {
    a = facingDirection;
    if a == FacingDirection.LEFT as u8 {
        facingDirection = a = FacingDirection.UP as u8;
    }
    if a == FacingDirection.DOWN as u8 {
        facingDirection = a = FacingDirection.RIGHT as u8;
    }

    increment_x_velocity();
    decrement_y_velocity();
}



// DB = 0x7e
#[mem8, idx8]
func process_direction_east() {
    facingDirection = a = FacingDirection.RIGHT as u8;

    increment_x_velocity();
    zero_y_velocity();
}



// DB = 0x7e
#[mem8, idx8]
func process_direction_south_east() {
    a = facingDirection;
    if a == FacingDirection.LEFT as u8 {
        facingDirection = a = FacingDirection.DOWN as u8;
    }
    if a == FacingDirection.UP as u8 {
        facingDirection = a = FacingDirection.RIGHT as u8;
    }

    increment_x_velocity();
    increment_y_velocity();
}



// DB = 0x7e
#[mem8, idx8]
func process_direction_south() {
    facingDirection = a = FacingDirection.DOWN as u8;

    zero_x_velocity();
    increment_y_velocity();
}



// DB = 0x7e
#[mem8, idx8]
func process_direction_south_west() {
    a = facingDirection;
    if a == FacingDirection.RIGHT as u8 {
        facingDirection = a = FacingDirection.DOWN as u8;
    }
    if a == FacingDirection.UP as u8 {
        facingDirection = a = FacingDirection.LEFT as u8;
    }

    decrement_x_velocity();
    increment_y_velocity();
}



// DB = 0x7e
#[mem8, idx8]
func process_direction_west() {
    facingDirection = a = FacingDirection.LEFT as u8;

    decrement_x_velocity();
    zero_y_velocity();
}



// DB = 0x7e
#[mem8, idx8]
func process_direction_north_west() {
    a = facingDirection;
    if a == FacingDirection.RIGHT as u8 {
        facingDirection = a = FacingDirection.UP as u8;
    }
    if a == FacingDirection.DOWN as u8 {
        facingDirection = a = FacingDirection.LEFT as u8;
    }

    decrement_x_velocity();
    decrement_y_velocity();
}



// DB = 0x7e
#[mem8, idx8]
func decrement_x_velocity() {

    // ::TODO add acceleration and friction::
    <:xVelocity = a = <:-WALK_VELOCITY;
    >:xVelocity = a = >:-WALK_VELOCITY;
}



// DB = 0x7e
#[mem8, idx8]
func zero_x_velocity() {

    // ::TODO add friction::
    <:xVelocity = 0;
    >:xVelocity = 0;
}



// DB = 0x7e
#[mem8, idx8]
func increment_x_velocity() {

    // ::TODO add acceleration and friction::
    <:xVelocity = a = <:WALK_VELOCITY;
    >:xVelocity = a = >:WALK_VELOCITY;
}



// DB = 0x7e
#[mem8, idx8]
func decrement_y_velocity() {

    // ::TODO add acceleration and friction::
    <:yVelocity = a = <:-WALK_VELOCITY;
    >:yVelocity = a = >:-WALK_VELOCITY;
}



// DB = 0x7e
#[mem8, idx8]
func zero_y_velocity() {

    // ::TODO add friction::
    <:yVelocity = 0;
    >:yVelocity = 0;
}



// DB = 0x7e
#[mem8, idx8]
func increment_y_velocity() {

    // ::TODO add acceleration and friction::
    <:yVelocity = a = <:WALK_VELOCITY;
    >:yVelocity = a = >:WALK_VELOCITY;
}



// WALKING STATE
// =============


// DB = 0x7e
#[mem8, idx8]
func set_state__walking() {
    state = State.WALKING as u8;

    // No watchdog in WALKING state.
    watchdogTimer = a = 1;
}



// DB = 0x7e
#[mem8, idx8]
func process__walking() {
    // Watchdog is not required when walking.  This state can last forever
    watchdogTimer = a = 1;

    process_dpad_update_velocity();

    move_player_with_tile_tests();

    a = joypad.input_buffers.attack;
    if !zero {
        set_state__attacking();
    }
    else {
        // ASSUMES WALKING_MS_ANIMATION_OFFSET == 0
        ^return _set_ms_animation_if_changed(facingDirection);
    }
}



// ATTACKING STATE
// ===============


// DB = 0x7e
#[mem8, idx8]
func set_state__attacking() {
    state = a = State.ATTACKING as u8;

    watchdogTimer = a = Watchdog.MAX_ATTACK_FRAMES;

    // Stand still while attacking
    <:xVelocity = 0;
    >:xVelocity = 0;
    <:yVelocity = 0;
    >:yVelocity = 0;

    audio.queue_sound_effect(sound_effects.sword_swing);

    ^return _set_ms_animation(facingDirection | ATTACKING_MS_ANIMATION_OFFSET);
}



// DB = 0x7e
#[mem8, idx8]
func process__attacking() {

    move_player_with_tile_tests();

    carry = _is_ms_non_looping_animation_running();
    if !carry {
        return set_state__walking();
    }
}



// HURT STATE
// ==========


// DB = 0x7e
#[mem8, idx8]
inline func set_state_hurt__enemy_collision__inline(enemyEntityId : u8 in y) {
    a = state as u8;
    if a != State.HURT as u8 {
        _set_state__hurt__enemy_collision(y, a as State);
    }
}



// DB = 0x7e
#[mem8, idx8]
func _set_state__hurt__enemy_collision(enemyEntityId : u8 in y, _previousState : State in a) {
    previousState = a;

    state = a = State.HURT as u8;

    watchdogTimer = a = Watchdog.MAX_HURT_STATE_FRAMES;

    x = calc_angle_32x2(a = entities.SoA.previousXpos[unaligned y],
                        a = entities.SoA.previousYpos[unaligned y],
                        player.previousXpos,
                        player.previousYpos);

    mem16();
    #[mem16] {
        xVelocity = aa = CosineTables.PlayerHurtVelocity[unaligned x] as u16;

        #[idx16] {
            xx = aa = (xx + CosineTables.SINE_OFFSET) & CosineTables.TABLE_MASK;
        }

        yVelocity = aa = CosineTables.PlayerHurtVelocity[unaligned x] as u16;
    }
    mem8();


    iframeCounter = a = N_IFRAMES_AFTER_ATTACKED;
    hurtTimer = a = N_HURT_FRAMES__ENEMY;


    player_hurt_sound_effect();


    ^return _set_ms_animation(facingDirection | HURT_MS_ANIMATION_OFFSET);
}



// Returns true if the player was hurt
//
// DB = 0x7e
#[mem8, idx8]
func take_environmental_damage(damage : u8 in a) : bool in carry {
var _damage : u8 in zpTmp_byte_0;

    x = iframeCounter;
    ^if zero {
        x = state as u8;
        if x != State.HURT as u8 {
            previousState = x;

            state = x = State.HURT as u8;

            // Save `damage` for later
            _damage = a;

            iframeCounter = a = N_IFRAMES_AFTER_ENVIRONMENTAL_DAMAGE;
            hurtTimer = a = N_HURT_FRAMES__ENVIRONMENT;

            watchdogTimer = a = Watchdog.MAX_HURT_STATE_FRAMES;


            a = joypad.current_h & joypad.JOYH.DPAD;
            if !zero {
                // Stop player movement when the player is using the D-PAD
                // (Player poisoned feedback)
                // Tried adding a knockback velocity, but that felt very jarring.
                mem16();
                #[mem16] {
                    xVelocity = 0;
                    yVelocity = 0;
                }
                mem8();
            }
            else {
                // Player is not using the D-PAD, add hurt knockback
                // This provides feedback that the player is poisoned.
                mem16();
                #[mem16] {
                    x = facingDirection as u8;
                    if x == FacingDirection.UP as u8 {
                        xVelocity = 0;
                        yVelocity = aa = STATIONARY_PLAYER__ENVIRONMENTAL_DAMAGE_VELOCITY;
                    } else if x == FacingDirection.DOWN as u8 {
                        xVelocity = 0;
                        yVelocity = aa = -STATIONARY_PLAYER__ENVIRONMENTAL_DAMAGE_VELOCITY as u16;
                    } else if x == FacingDirection.LEFT as u8 {
                        xVelocity = aa = STATIONARY_PLAYER__ENVIRONMENTAL_DAMAGE_VELOCITY;
                        yVelocity = 0;
                    } else {
                        // facing right
                        xVelocity = aa = -STATIONARY_PLAYER__ENVIRONMENTAL_DAMAGE_VELOCITY as u16;
                        yVelocity = 0;
                    }
                }
                mem8();
            }

            // Player takes damage
            a = player.health - _damage;
            if !carry {
                a = 0;
            }
            player.health = a;

            player_hurt_sound_effect();

            return true;
        }
    }

    return false;
}



#[mem8, idx8]
func player_hurt_sound_effect() {
    // Hurt sound effect
    a = health;
    if !zero && a < player.LOW_HEALTH_ALARM + 1 {
        a = sound_effects.player_hurt_low_health as u8;
    }
    else {
        a = sound_effects.player_hurt as u8;
    }
    ^return audio.queue_sound_effect(a as sound_effects);
}



// DB = 0x7e
#[mem8, idx8]
func process__hurt() {

    a = previousState;
    if a != State.WALK_THROUGH_DOORWAY as u8 && a != State.ATTACKING_IN_DOORWAY as u8 {
        move_player_with_tile_tests();
    }

    // Frozen until timer expires
    // (Cannot use `_is_ms_non_looping_animation_running()` here as `take_environmental_damage()` cannot change the MetaSprite animation)
    hurtTimer--;
    if zero {
        a = previousState;
        if a == State.WALK_THROUGH_DOORWAY as u8 || a == State.ATTACKING_IN_DOORWAY as u8 {
            set_state__walk_through_doorway__after_attacking_in_doorway();
            return;
        }
        else if a == State.HOLDING_BOMB as u8 {
            set_state__holding_bomb__after_hurt();
            return;
        }
        else {
            ^return set_state__walking();
        }
    }

    // Still in the hurt state.

    // Set the MS animation.
    // Fixes a bug where the animation is not changed in `take_environmental_damage()`
    // (`process_walking()` calls `_set_ms_animation_if_changed()` after processing interactive tiles)
    _set_ms_animation_if_changed(facingDirection | HURT_MS_ANIMATION_OFFSET);
}



// WALK_THROUGH_DOORWAY state
// ==========================


in wram7e_roomstate {
    // The direction of the player when they entered the door
    var walkThroughDoorway_direction : metatiles.CollisionDirection;

    // The position (on the main axis) of the player at the start of the WALK_THROUGH_DOORWAY state.
    var walkThroughDoorway_mainAxisStart : u8;

    // The target position (on the alt axis) the player needs to be to enter to door.
    var walkThroughDoorway_altAxisTarget : u8;
}



// Called when the player is touching a solid tile.
//
// DB = 0x7e
#[mem8, idx8]
inline func set_state__walk_through_doorway__inline(direction : metatiles.CollisionDirection in x, mainAxisStart : u8 in y, altAxisTarget : u8 in a) {
    walkThroughDoorway_direction = direction;
    walkThroughDoorway_mainAxisStart = mainAxisStart;
    walkThroughDoorway_altAxisTarget = altAxisTarget;

    state = a = State.WALK_THROUGH_DOORWAY as u8;

    // no watchdog when walking
    // a is non-zero
    watchdogTimer = a;
}


// Called when restoring player state
//
// DB = 0x7e
#[mem8, idx8]
inline func set_state__walk_through_doorway__restore_player_state() {
    state = a = State.WALK_THROUGH_DOORWAY as u8;

    // no watchdog when walking
    // a is non-zero
    watchdogTimer = a;


    // This code assumes the player entered the room in the correct position and direction
    // ::TODO is this assumption correct?::

    a = facingDirection as u8 <<< 1;
    walkThroughDoorway_direction = a as metatiles.CollisionDirection;

    if a & metatiles.CollisionDirection_LEFT_RIGHT_BIT_TEST != 0 {
        y = player.xPos.px;
        a = player.yPos.px;
    }
    else {
        y = player.yPos.px;
        a = player.xPos.px;
    }
    walkThroughDoorway_mainAxisStart = y;
    walkThroughDoorway_altAxisTarget = a;

    _set_ms_animation(facingDirection);
}



// Called after the player is attacking in a doorway
//
// DB = 0x7e
#[mem8, idx8]
inline func set_state__walk_through_doorway__after_attacking_in_doorway() {
    state = a = State.WALK_THROUGH_DOORWAY as u8;

    // no watchdog when walking
    // a is non-zero
    watchdogTimer = a;

    // ASSUMES WALKING_MS_ANIMATION_OFFSET == 0
    _set_ms_animation(facingDirection);
}



// DB = 0x7e
#[mem8, idx8]
func process__walk_through_doorway() {
    // Watchdog is not required when walking.  This state can last forever
    watchdogTimer = a = 1;


var _mainAxisOffset : u8 in zpTmp_byte_0;

    idx16();
    #[idx16] {
        xx = 0;
        yy = 0;

        a = walkThroughDoorway_direction as u8;
        ^if a & metatiles.CollisionDirection_LEFT_RIGHT_BIT_TEST != 0 {
            // X axis doorway

            a = xPos.px - walkThroughDoorway_mainAxisStart;
            if !carry {
                a = negate8(a);
            }
            _mainAxisOffset = a;


            // Calculate Y axis velocity to reach `walkThroughDoorway_altAxisTarget`.
            a = yPos.px;
            if a < walkThroughDoorway_altAxisTarget {
                yy = DOORWAY_DIAGONAL_ALT_VELOCITY;
            }
            else if !zero {
                yy = -DOORWAY_DIAGONAL_ALT_VELOCITY as u16;
            }


            a = walkThroughDoorway_direction as u8;
            if a == metatiles.CollisionDirection.LEFT as u8 {
                // direction = LEFT

                a = joypad.current_h;
                if a & joypad.JOYH.LEFT != 0 {
                    facingDirection = a = FacingDirection.LEFT as u8;

                    if yy == 0 {
                        xx = -DOORWAY_VELOCITY as u16;
                    }
                    else {
                        xx = -DOORWAY_DIAGONAL_MAIN_VELOCITY as u16;
                    }
                }
                else if a & joypad.JOYH.RIGHT != 0 {
                    facingDirection = a = FacingDirection.RIGHT as u8;

                    xx = DOORWAY_VELOCITY;
                    yy = 0;
                }
                else if a & (joypad.JOYH.UP | joypad.JOYH.DOWN) != 0 {
                    // Leave door by pressing UP/DOWN if the player is near the door entrance
                    a = _mainAxisOffset;
                    if a < DOORWAY_LEAVE_DISTANCE {
                        facingDirection = a = FacingDirection.RIGHT as u8;
                        xx = DOORWAY_VELOCITY;
                        yy = 0;
                    }
                }
            }
            else {
                // direction = RIGHT

                a = joypad.current_h;
                if a & joypad.JOYH.RIGHT != 0 {
                    facingDirection = a = FacingDirection.RIGHT as u8;

                    if yy == 0 {
                        xx = DOORWAY_VELOCITY;
                    }
                    else {
                        xx = DOORWAY_DIAGONAL_MAIN_VELOCITY;
                    }
                }
                else if a & joypad.JOYH.LEFT != 0 {
                    facingDirection = a = FacingDirection.LEFT as u8;

                    xx = -DOORWAY_VELOCITY as u16;
                    yy = 0;
                }
                else if a & (joypad.JOYH.UP | joypad.JOYH.DOWN) != 0 {
                    // Leave door by pressing UP/DOWN if the player is near the door entrance
                    a = _mainAxisOffset;
                    if a < DOORWAY_LEAVE_DISTANCE {
                        facingDirection = a = FacingDirection.LEFT as u8;
                        xx = -DOORWAY_VELOCITY as u16;
                        yy = 0;
                    }
                }
            }
        }
        else {
            // Y axis doorway

            a = yPos.px - walkThroughDoorway_mainAxisStart;
            if !carry {
                a = negate8(a);
            }
            _mainAxisOffset = a;


            // Calculate X velocity to reach `walkThroughDoorway_altAxisTarget`.
            a = xPos.px;
            if a < walkThroughDoorway_altAxisTarget {
                xx = DOORWAY_DIAGONAL_ALT_VELOCITY;
            }
            else if !zero {
                xx = -DOORWAY_DIAGONAL_ALT_VELOCITY as u16;
            }


            a = walkThroughDoorway_direction as u8;
            if !zero {
                // direction = UP

                a = joypad.current_h;
                if a & joypad.JOYH.UP != 0 {
                    facingDirection = a = FacingDirection.UP as u8;

                    if xx == 0 {
                        yy = -DOORWAY_VELOCITY as u16;
                    }
                    else {
                        yy = -DOORWAY_DIAGONAL_MAIN_VELOCITY as u16;
                    }
                }
                else if a & joypad.JOYH.DOWN != 0 {
                    facingDirection = a = FacingDirection.DOWN as u8;

                    xx = 0;
                    yy = DOORWAY_VELOCITY;
                }
                else if a & (joypad.JOYH.LEFT | joypad.JOYH.RIGHT) != 0 {
                    // Leave door by pressing LEFT/RIGHT if the player is near the door entrance
                    a = _mainAxisOffset;
                    if a < DOORWAY_LEAVE_DISTANCE {
                        facingDirection = a = FacingDirection.DOWN as u8;
                        xx = 0;
                        yy = DOORWAY_VELOCITY;
                    }
                }
            }
            else {
                // direction = DOWN

                a = joypad.current_h;
                if a & joypad.JOYH.DOWN != 0 {
                    facingDirection = a = FacingDirection.DOWN as u8;

                    if yy == 0 {
                        yy = DOORWAY_VELOCITY;
                    }
                    else {
                        yy = DOORWAY_DIAGONAL_MAIN_VELOCITY;
                    }
                }
                else if a & joypad.JOYH.UP != 0 {
                    facingDirection = a = FacingDirection.UP as u8;

                    xx = 0;
                    yy = -DOORWAY_VELOCITY as u16;
                }
                else if a & (joypad.JOYH.LEFT | joypad.JOYH.RIGHT) != 0 {
                    // Leave door by pressing LEFT/RIGHT if the player is near the door entrance
                    a = _mainAxisOffset;
                    if a < DOORWAY_LEAVE_DISTANCE {
                        facingDirection = a = FacingDirection.UP as u8;
                        xx = 0;
                        yy = -DOORWAY_VELOCITY as u16;
                    }
                }
            }
        }

        xVelocity = xx;
        yVelocity = yy;
    }
    mem8_idx8();


    add_velocity_to_positon_without_collsion_checks();


    // Do not test for solid tile if main axis position is unchanged.
    //
    //  * Prevents `set_state__walking()` from repeatedly resetting the walking animation frame to 0.
    //  * Ensures player can enter the doorway tile as soon as possible.
    a = _mainAxisOffset;
    if !zero {
        negative = metatiles.test_if_player_touches_a_solid_tile();
        if !negative {
            set_state__walking();
            return;
        }
    }


    // Must be after solid tile test to prevent a clip
    a = joypad.input_buffers.attack;
    goto set_state__attacking_in_doorway if !zero;


    // ASSUMES WALKING_MS_ANIMATION_OFFSET == 0
    ^return _set_ms_animation_if_changed(facingDirection);
}



// ATTACKING IN DOORWAY STATE
// ==========================


// DB = 0x7e
#[mem8, idx8]
func set_state__attacking_in_doorway() {
    state = a = State.ATTACKING_IN_DOORWAY as u8;

    watchdogTimer = a = Watchdog.MAX_ATTACK_FRAMES;


    // Player moves forward a bit when attacking.
    //
    // Prevents player from finding a pixel-perfect position where they can attack inside
    // a doorway and not get hurt by an enemy.
    //
    // Should not cause any issues with collisions.
    x = a = (facingDirection as u8) << 1;
    mem16();
    #[mem16] {
        xVelocity = aa = AttackingInDoorwayVelocity_X[unaligned x] as u16;
        yVelocity = aa = AttackingInDoorwayVelocity_Y[unaligned x] as u16;
    }
    mem8_idx8();

    audio.queue_sound_effect(sound_effects.sword_swing);

    ^return _set_ms_animation(facingDirection | ATTACKING_MS_ANIMATION_OFFSET);
}



// DB = 0x7e
#[mem8, idx8]
func process__attacking_in_doorway() {

    add_velocity_to_positon_without_collsion_checks();

    // wait until animation is over
    carry = _is_ms_non_looping_animation_running();
    if !carry {
        set_state__walk_through_doorway__after_attacking_in_doorway();
    }
}



// HOLDING_BOMB STATE
// ==================


// Called when restoring player state
//
// DB = 0x7e
#[mem8, idx8]
inline func set_state__holding_bomb__restore_player_state() {
    player.state = a = State.HOLDING_BOMB as u8;

    // a is non-zero.
    watchdogTimer = a;

    _set_ms_animation(facingDirection | HOLDING_MS_ANIMATION_OFFSET);


    // Retrieve the MetaSprite frame address of the bomb.
    // Assumes the correct frame is the first one in the MetaSprite frame table.
    // ::TODO find a better way to do this::
    mem16_idx16();
    #[mem16, idx16] {
        let PLAYER_BOMB_ID = entities.EntityTypes.player_bomb as u8;

        xx = aa = (entity_rom_data.metasprite_framesets as far *u16)[PLAYER_BOMB_ID];
        xx = aa = metasprites.MsFsData.frameTable[unaligned xx];
        itemAboveHead_msFrameAddr = aa = metasprites.MetaSpriteFrameTableOffset[unaligned xx];
    }
    mem8_idx8();
}



// KEEP: Y
//
// DB = 0x7e
#[mem8, idx8]
inline func pickup_bomb__inline(bomb_entityId : u8 in y) {
    a = player.state as u8;
    if zero {
        player.state = a = State.HOLDING_BOMB as u8;

        audio.queue_sound_effect(sound_effects.pickup_bomb);

        mem16();
        #[mem16] {
            itemAboveHead_msFrameAddr = aa = entities.SoA.msFrameAddr[unaligned y];
        }
        mem8();
    }
}


// DB = 0x7e
#[mem8, idx8]
inline func set_state__holding_bomb__after_hurt() {
    player.state = a = State.HOLDING_BOMB as u8;
}


// DB = 0x7e
#[mem8, idx8]
func process__holding_bomb() {
    // Watchdog is not required when holding a bomb.  This state can last forever
    watchdogTimer = a = 1;

    process_dpad_update_velocity();

    move_player_with_tile_tests();


    a = joypad.pressed_l;
    if a & joypad.DROP_BOMB_BUTTON_L != 0 {
        // Stop drawing item above the player's head
        <:itemAboveHead_msFrameAddr = 0;
        >:itemAboveHead_msFrameAddr = 0;

        // Spawn active bomb
        entityloop.spawn_entity(a = xPos.px,
                                a = yPos.px,
                                a = entities.EntityTypes.player_bomb as u8,
                                y = entities.player_bomb.DROP_ACTIVE_BOMB_PARAMETER);

        audio.queue_sound_effect(sound_effects.throw_bomb);

        ^return set_state__walking();
    }

    ^return _set_ms_animation_if_changed(facingDirection | HOLDING_MS_ANIMATION_OFFSET);
}


}


in rodata0 {
    let __AIDV = ATTACKING_IN_DOORWAY_VELOCITY;

    const _AttackingInDoorwayVelocity_X : [i16 ; 4] = [       0,       0,  __AIDV, -__AIDV ];
    const _AttackingInDoorwayVelocity_Y : [i16 ; 4] = [  __AIDV, -__AIDV,       0,       0 ];

    let AttackingInDoorwayVelocity_X = far &_AttackingInDoorwayVelocity_X as far *i16;
    let AttackingInDoorwayVelocity_Y = far &_AttackingInDoorwayVelocity_Y as far *i16;
}


}

