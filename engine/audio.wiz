// Copyright (c) 2023, Marcus Rowe <undisbeliever@gmail.com>.
// Distributed under The MIT License, see the LICENSE file for more details.

import "src/memmap";
import "registers";

import "resources/resources";

import "gen/enums";



namespace audio {

// ::TODO add menu to set/clear monoFlag::


// Address to store the loader (in Audio-RAM).
// Address (in Audio-RAM) to execute after loading the Loader.
// MUST match LOADER_ADDR in `audio-driver/src/common_memmap.wiz`
let LOADER_ARAM_ADDR = 0x160;

// Maximum pan value (100% to the right)
let MAX_PAN = 128;
let CENTER_PAN = MAX_PAN / 2;


// MUST match `audio-driver/src/io-commands.wiz`
namespace IO {
    namespace ToDriver {
        // The command to execute.
        //
        //      iii0ccci
        //          ccc = command
        //            0 = reserved for future expansion
        //            i = command id, MUST be different on every command.
        //                Used to detect when a new command has been sent to the driver.
        //
        // NOTES:
        //  * The command will only be execute if the `command` byte has changed.
        //  * This value MUST be written last.
        //  * The command and parameter bytes MUST NOT change unless the previous command
        //    has been acknowledged.
        extern writeonly command @ &APUIO_OUT_0 : u8;

        let N_COMMANDS = 8;
        let COMMAND_MASK   = 0b00001110;
        let COMMAND_I_MASK = 0b11100001;

        // The two command parameter bytes
        extern writeonly parameter0 @ &APUIO_OUT_1 : u8;
        extern writeonly parameter1 @ &APUIO_OUT_2 : u8;


        // Writing `SWITCH_TO_LOADER` to this port should stop execution and start the loader.
        //
        // If the audio-driver is running; if the `_SWITCH_TO_LOADER_BIT` is set,
        // the audio driver will stop and execute the loader.
        //
        // If the loader is in the middle of a transfer and both the `_SWITCH_TO_LOADER_BIT`
        // and MSB (bit 7) bits are set, the loader will restart.
        extern writeonly switch_to_loader @ &APUIO_OUT_3 : u8;

        let _SWITCH_TO_LOADER_BIT = 5;
        let SWITCH_TO_LOADER = 0x80 | (1 << _SWITCH_TO_LOADER_BIT);
    }

    namespace ToScpu {
        // Audio driver command acknowledgment.
        //
        // Acknowledgment of the `ToDriver.command` byte.  Not used in the loader.
        //
        // After the command has been processed, the `IO.ToDriver.command` value will be written to this port.
        extern const command_ack @ &APUIO_IN_0 : u8;


        // The mode the S-SMP is currently executing.
        //
        // Used by both the loader and the audio-driver.
        //
        // NOTE: The IPL sets this value after at has cleared the zero-page.
        //       Do not read this value immediately after reset.
        //       Make sure enough time has passed for the IPL to set IO Port 1
        //       to 0xbb before reading this port.
        extern const mode @ &APUIO_IN_1 : u8;

        // The S-SMP is at the start of the IPL, waiting for the ready signal.
        let MODE_IPL = 0xbb;

        // The S-SMP is running the loader.
        let MODE_LOADER = 0x4c;         // 'L', Loader.LOADER_READY_L

        // The S-SMP is running the audio-driver.
        let MODE_AUDIO_DRIVER = 0x61 ;  // 'a'
    }

    // MUST match CommandFunctionTable in `audio-driver.wiz`.
    enum Command : u8 {
        // Stop song and sound effect execution.
        // * Commands will still be executed when the audio-driver is paused
        // * The audio driver starts paused unless the `LoaderDataType.PLAY_SONG_BIT` is set.
        PAUSE               = 0,

        // Unpauses the audio driver.
        //
        // * Resets the S-SMP timer counters,
        //   can cause issues if the S-CPU spams `UNPAUSE` commands.
        UNPAUSE             = 2,

        // Play a sound effect
        //  * parameter0: sound effect id (not bounds checked)
        //  * parameter1: pan (0-128) (not bounds checked)
        PLAY_SOUND_EFFECT   = 4,

        // reserved

        // Stop all active sound effects
        STOP_SOUND_EFFECTS = 8,

        // Set the main volume
        //  * parameter0: signed i8 volume
        //
        // NOTE: The main volume is reset whenever a new song is loaded.
        SET_MAIN_VOLUME = 10,

        // Enables or disable channels.
        //  * parameter0: A bitmask of the 8 channels that can send key-on events
        //
        // Useful for disabling channels in a song.
        //
        // NOTE: The enabled channels bitmask is reset whenever a new song is loaded.
        SET_ENABLED_CHANNELS = 12,

        // Set the song tempo.
        //  * parameter0: The new S-DSP TIMER_0 register value
        //    (MUST be >= MIN_TICK_CLOCK 64, is bounds checked)
        //
        // NOTE: The song can still change the tempo.
        SET_SONG_TEMPO = 14,
    };
}

// MUST match `audio-driver/src/io-commands.wiz`
enum LoaderDataType : u8 {
    CODE             = 0,
    COMMON_DATA      = 1,
    MONO_SONG_DATA   = 0x02,
    STEREO_SONG_DATA = 0x82,
};


in rodata0 {
    const __Loader = embed "gen/audio-loader.bin";

    let Loader = far &__Loader as far * const u8;
    let LOADER_SIZE = sizeof(typeof(__Loader));

    const AudioDriver = embed "gen/audio-driver.bin";

    const BlankSong = embed "gen/audio-blank-song.bin";
}


in zeropage {
    // The sound effect to play next.
    //
    // NOTE: If sfxQueue > N_SOUND_EFFECTS.  No sound effect will be played.
    var sfxQueue : u8;

    // The pan value for the next sound effect to play.
    var sfxQueuePan : u8;


    // The previous `IO.ToDriver.command` sent to the S-SMP audio driver.
    var previousCommand : u8;
}


in lowram {
    // Non-zero if the common audio data has been loaded into Audio-RAM.
    // (byte flag)
    var _common_audio_data_loaded : u8;


    // Set if a song is loaded into Audio-RAM and the audio driver is running.
    // (byte flag)
    var _songLoaded : u8;


    // Mono sound flag.
    //   * Mono if non-zero
    //   * Stereo if zero (default)
    // (byte flag)
    var monoFlag : u8;
}


in code {


// REQUIRES: S-SMP reset
//
// This function MUST only be called once.
//
// This function MUST be called after `resources_over_usb2snes` init.
//
// DB = 0x80
#[mem8, idx16]
inline func setup__inline() {
var _res : resources.ResourceEntry in resources.res;

    // ::TODO add a first-call check::

    __transfer_loader_via_ipl__inline();


    _common_audio_data_loaded = 0;
    _songLoaded = 0;


    *(&_res.farPtr as *u16) = xx = &AudioDriver as u16;
    #:_res.farPtr = a = #:far &AudioDriver;
    _res.size = yy = sizeof(typeof(AudioDriver));

    __transfer_data_to_loader(_res, LoaderDataType.CODE);


    // Will also transfer common data to the Loader
    load_blank_song();
}



// DB access low-ram
#[mem8]
inline func _reset_sfx_queue__inline() {
    // Reset the SFX queue
    sfxQueue = a = 0xff;

    a = IO.Command.UNPAUSE as u8;
    IO.ToDriver.command = a;
    previousCommand = a;
}



// Queue the next sound effect to play, without panning (center pan).
//
// NOTE: Only 1 sound effect can be played at a time
// NOTE: Lower sound effect IDs take priority over higher sound effect IDs.
//
// KEEP: Y
//
// DB access zero-page
#[fallthrough, mem8, idx8]
func queue_sound_effect(effect_id : sound_effects in a) {
    x = CENTER_PAN;
}



// Queue the next sound effect to play, with panning.
//
// NOTE: Only 1 sound effect can be played at a time
// NOTE: Lower sound effect IDs take priority over higher sound effect IDs.
//
// KEEP: Y
//
// DB access zero-page
#[mem8, idx8]
func queue_panned_sound_effect(effect_id : sound_effects in a, pan: u8 in x) {
    // MUST NOT modify zpTmp variables.

    if a < sfxQueue {
        sfxQueue = a;
        sfxQueuePan = x;
    }
}



// Process sound effects.
//
// MUST be called once per frame.
//
// DB = 0x80
#[mem8, idx8]
inline func process_sfx_queue__inline() {
    // Assumes N_SOUND_EFFECTS <= 255
    x = sfxQueue;
    if x < N_SOUND_EFFECTS {
        a = _songLoaded;
        if !zero {
            a = previousCommand;
            if a == IO.ToScpu.command_ack {
                // The previous command executed successfully.
                // Send a new command.

                // Bit trick to change the i bits and set the play sound effect command

                // a = previousCommand
                // Clear the non i bits of commands
                a &= IO.ToDriver.COMMAND_I_MASK as u8;
                //  Change the i bits and set the play sound effect command
                a ^= IO.ToDriver.COMMAND_I_MASK | (IO.Command.PLAY_SOUND_EFFECT as u8);

                // parameter 0 = sfx_id
                IO.ToDriver.parameter0 = x;

                // parameter 1 = pan
                y = sfxQueuePan;
                if y >= MAX_PAN + 1 {
                    y = CENTER_PAN;
                }
                IO.ToDriver.parameter1 = y;

                IO.ToDriver.command = a;
                previousCommand = a;
            }
        }

        // Reset the SFX queue
        sfxQueue = a = 0xff;
    }
}


// Send a `PAUSE` command to the audio driver.
//
// NOTE: May not send the IO command.  Check the return value.
//
// DB = 0x80
#[mem8, idx8]
func pause() : bool in carry {
    return __send_io_command_no_parameter(IO.Command.PAUSE);
}


// Send an `UNPAUSE` command to the audio driver.
//
// NOTE: May not send the IO command.  Check the return value.
//
// DB = 0x80
#[mem8, idx8]
func unpause() : bool in carry {
    return __send_io_command_no_parameter(IO.Command.UNPAUSE);
}


// Send a `STOP_SOUND_EFFECTS` command to the audio driver.
//
// NOTE: May not send the IO command.  Check the return value.
//
// DB = 0x80
#[mem8, idx8]
func stop_sound_effects() : bool in carry {
    return __send_io_command_no_parameter(IO.Command.STOP_SOUND_EFFECTS);
}


// Send a `SET_MAIN_VOLUME` command to the audio driver.
//
// NOTE: May not send the IO command.  Check the return value.
//
// DB = 0x80
#[mem8, idx8]
func set_main_volume(volume: u8 in a) : bool in carry {
    return __send_io_command_with_parameter(IO.Command.SET_MAIN_VOLUME, a);
}


// Send a `SET_ENABLED_CHANNELS` command to the audio driver.
//
// NOTE: May not send the IO command.  Check the return value.
//
// DB = 0x80
#[mem8, idx8]
func set_enabled_channels(volume: u8 in a) : bool in carry {
    return __send_io_command_with_parameter(IO.Command.SET_ENABLED_CHANNELS, a);
}


// Send a `SET_SONG_TEMPO` command to the audio driver.
//
// NOTE: May not send the IO command.  Check the return value.
//
// DB = 0x80
#[mem8, idx8]
func set_song_tempo(volume: u8 in a) : bool in carry {
    return __send_io_command_with_parameter(IO.Command.SET_SONG_TEMPO, a);
}



// Send an IO command (with a parameter) to the audio driver.
//
// NOTE: May not send the IO command. Check the return value.
//
// NOTE: Cannot be used to send play_sound_effect commands.  Use the sound effect queue instead.
//
// DB = 0x80
#[mem8, idx8]
func __send_io_command_with_parameter(command : IO.Command in x, parameter0: u8 in a) : bool in carry {
var _command : IO.Command in zpTmp_byte_0;

    y = a;

    a = _songLoaded;
    if !zero {
        a = previousCommand;
        if a == IO.ToScpu.command_ack {
            _command = x as IO.Command;

            // Wait until the previous command has been acknowledged
            a = previousCommand;
            do {
            } while a != IO.ToScpu.command_ack;


            // Extract and change the i bits (to create a new command byte)
            a &= IO.ToDriver.COMMAND_I_MASK;
            a ^= IO.ToDriver.COMMAND_I_MASK;

            a |= _command as u8;

            IO.ToDriver.parameter0 = y;
            IO.ToDriver.command = a;

            previousCommand = a;

            return true;
        }
    }

    return false;
}

// Send an IO command with no parameter
// WARNING: will send the x register value to the audio driver.
let __send_io_command_no_parameter = __send_io_command_with_parameter as func(command : IO.Command in a): bool in carry;




// Mark the common audio data in Audio-RAM as out-of-date
//
// DB access lowram
#[mem8]
inline func mark_common_audio_data_changed() {
    _common_audio_data_loaded = 0;
}



// Load common audio data into Audio-RAM if required.
//
// DB = 0x80
#[mem8, idx16]
func _load_common_data_if_required__inline() {
    a = _common_audio_data_loaded;
    if zero {
        _transfer_common_audio_data();
    }
}



// Load common audio data into Audio-RAM.
//
// DB = 0x80
#[mem8, idx16]
func _transfer_common_audio_data() {
var _res : resources.ResourceEntry in resources.res;

    __send_switch_to_loader_command();

    _res = resources.load_songs_resource(resources.songs.__null__common_data__);
    __transfer_data_to_loader(_res, LoaderDataType.COMMON_DATA);

    _common_audio_data_loaded = a = 1;
}



// Send a *switch-to-loader* command to the audio-driver or loader
//
// DB = 0x80
#[mem8, idx16]
func __send_switch_to_loader_command() {
    IO.ToDriver.switch_to_loader = a = IO.ToDriver.SWITCH_TO_LOADER;

    // Audio Driver is no longer active.
    _songLoaded = 0;
}



// Load a blank song to the audio driver
//
// DB = 0x80
#[fallthrough, mem8, idx16]
func load_blank_song() {
    a = 0;

// Fallthrough
}


// Load a song to the audio driver
//
// If songId is 0, a blank song is loaded and no music will be played
//
// DB = 0x80
#[fallthrough, mem8, idx16]
func load_song(songId : u8 in a) {
var _res : resources.ResourceEntry in resources.res;

    // Fixes badly glitching audio when `songId` >= N_SONGS.
    // (When `songId` >= N_SONGS, it erroneously loads the common-audio-data as song-data)
    if a >= resources.N_SONGS {
        a = 0;
    }

    push8(a);

    a =_common_audio_data_loaded;
    if zero {
        _transfer_common_audio_data();
    }

    a = pop8();
    if zero {
        // Resource 0 is Common Audio Data
        // Load BlankSong instead
        *(&_res.farPtr as *u16) = xx = &BlankSong as u16;
        #:_res.farPtr = a = #:far &BlankSong;
        _res.size = yy = sizeof(typeof(BlankSong));
    }
    else {
        _res = resources.load_songs_resource(a as resources.songs);
    }

// Fallthrough
}



// Transfer song data to the audio driver
//
// ASSUMES: Common data is already loaded into the console
//
// DB = 0x80
#[mem8, idx16]
func _transfer_song_data(_res : resources.ResourceEntry in resources.res) {
    // ::TODO silence or fadeout the current song before loading the next one::

    __send_switch_to_loader_command();

    a = monoFlag;
    if !zero {
        a = LoaderDataType.MONO_SONG_DATA as u8;
    }
    else {
        a = LoaderDataType.STEREO_SONG_DATA as u8;
    }

    __transfer_data_to_loader(_res, a as LoaderDataType);


    // Song is loaded into Audio-RAM
    _songLoaded = a = 1;
}



// Transfer data to the audio loader
//
// NOTE: This function may read one byte past the end of `_res`.
//
// DB = 0x80
#[mem8, idx16]
func __transfer_data_to_loader(_res : resources.ResourceEntry in resources.res, type : LoaderDataType in a) {

    // Wait until loader is ready
    xx = ('L' as u16) | ('D' as u16 << 8);
    do {
    } while xx != APUIO_IN_32;


    // Send the ready signal and the LoaderDataType.
    APUIO_OUT_1 = a;
    APUIO_OUT_2 = a = 'L';
    APUIO_OUT_3 = a = 'D';


    // Calculate the number of words to transfer
    // ASSUMES _res.size >= 2.
    mem16();
    #[mem16] {
        aa = _res.size;
        aa++;
        xx = aa = aa >>> 1;
    }
    mem8();


    // Wait for acknowledgement from the LoaderDataType
    do {
        a = APUIO_IN_3;
    } while !zero;

    yy = 0;
    do {
        APUIO_OUT_1 = a = _res.farPtr[yy];
        yy++;
        APUIO_OUT_2 = a = _res.farPtr[yy];

        // Tell S-SMP the data is ready
        // `APUIO_OUT_3` cannot be negative.  A negative value on port-3 means end-of-data.
        // Also cannot be 'D'.
        a = y & 0xf;
        APUIO_OUT_3 = a;

        yy++;

        do {
        } while a != APUIO_IN_3;

        xx--;
    } while !zero;


    // End of data transfer
    // MUST NOT set `IO.ToDriver.SWITCH_TO_LOADER_BIT`
    APUIO_OUT_3 = a = 0x80;

    // Must wait for the end of the input as `_reset_sfx_queue__inline()` writes to IO port 0.
    do {
    } while a != APUIO_IN_3;

    _reset_sfx_queue__inline();
}



// REQUIRES: S-SMP reset and no data has been written to it yet
//
// This function MUST only be called once.
//
// DB = 0x80
#[mem8, idx16]
inline func __transfer_loader_via_ipl__inline() {
    // ::TODO add a 'running IPL' check::

    // Initialize the transfer
    yy = 0xbbaa;
    APUIO_OUT_10 = yy;

    // Wait for a response from the IPL
    do {
    } while yy != APUIO_IN_10;

    xx = LOADER_ARAM_ADDR;
    a = 0xcc;
    APUIO_OUT_32 = xx;     // destination ARAM address
    APUIO_OUT_1 = a;       // non-zero = write data to address
    APUIO_OUT_0 = a;       // New data command (non-zero and APUIO0 + more than 2, or 0xcc on the first transfer)


    // Wait for a response form the IPL
    do {
    } while a != APUIO_IN_0;


    // Transfer the data
    idx8();
    #[idx8] {
        x = 0;
        do {
            // Send the next byte to the IPL
            APUIO_OUT_1 = a = Loader[x];

            // Tell the IPL the next data is ready
            APUIO_OUT_0 = x;

            // Wait for a response from the IPL
            do {
            } while x != APUIO_IN_0;

            x++;
        } while x < LOADER_SIZE;
    }
    idx16();

    APUIO_OUT_32 = xx = LOADER_ARAM_ADDR;  // A-RAM address
    APUIO_OUT_1 = 0;                       // zero = execute program at A-RAM address
    APUIO_OUT_0 = a = LOADER_SIZE + 2;     // New data command (must be at least +2 the previous APUIO_OUT_0 write)
}

}

}

