// Copyright (c) 2024, Marcus Rowe <undisbeliever@gmail.com>.
// Distributed under The MIT License, see the LICENSE file for more details.

import "src/memmap";
import "game/gamestate";
import "gen/enums";

namespace gs {

in code {

// u8 GameState Variables
// ======================

// CAUTION: gsVar8 is not bounds or alignment checked.
// KEEP: Y
// DB = 0x7e
#[mem8]
inline func get_u8(let gsVar8 : var8) : u8 in a {
    return gamestate.data.u8_vars[unaligned gsVar8 as u8];
}

// CAUTION: gsVar8 is not bounds or alignment checked.
// KEEP: Y
// DB = 0x7e
#[idx8]
inline func get_u8_x(let gsVar8 : var8) : u8 in x {
    return gamestate.data.u8_vars[unaligned gsVar8 as u8];
}


// CAUTION: gsVar8 is not bounds or alignment checked.
// KEEP: Y
// DB = 0x7e
#[mem8, idx8]
inline func get_dyn_u8(gsVar8 : var8 in x) : u8 in a {
    return gamestate.data.u8_vars[unaligned x];
}


// CAUTION: gsVar8 is not bounds or alignment checked.
// KEEP: Y
// DB = 0x7e
#[mem8]
inline func set_u8(let gsVar8 : var8, value: u8 in a) {
    gamestate.data.u8_vars[unaligned gsVar8 as u8] = a;
}


// CAUTION: gsVar8 is not bounds or alignment checked.
// KEEP: Y
// DB = 0x7e
#[idx8]
inline func set_u8_x(let gsVar8 : var8, value: u8 in x) {
    gamestate.data.u8_vars[unaligned gsVar8 as u8] = x;
}


// CAUTION: gsVar8 is not bounds or alignment checked.
// KEEP: Y
// DB = 0x7e
#[mem8, idx8]
inline func set_dyn_u8(gsVar8 : var8 in x, value: u8 in a) {
    gamestate.data.u8_vars[unaligned x] = a;
}


// CAUTION: gsVar8 is not bounds or alignment checked.
// KEEP: Y
// DB = 0x7e
#[mem8, idx8]
func saturating_inc_u8(gsVar8 : var8 in x) : u8 in a {
    a = gamestate.data.u8_vars[unaligned x];
    a++;
    if zero {
        a--;
    }
    gamestate.data.u8_vars[unaligned x] = a;

    return a;
}


// CAUTION: gsVar8 is not bounds or alignment checked.
// OUT: A = new gamestate value.
// KEEP: Y
// DB = 0x7e
#[mem8, idx8]
func checked_dec_u8(gsVar8 : var8 in x) : bool in carry {
    a = gamestate.data.u8_vars[unaligned x];
    cmp(a, 1);
    if carry {
        a--;
        gamestate.data.u8_vars[unaligned x] = a;
    }
    return carry;
}



// u16 GameState Variables
// =======================

// CAUTION: gsVar16 is not bounds or alignment checked.
// KEEP: Y
// DB = 0x7e
#[mem16]
inline func get_u16_aa(let gsVar16 : var16) : u16 in aa {
    return gamestate.data.u16_vars[unaligned gsVar16 as u16];
}

// CAUTION: gsVar16 is not bounds or alignment checked.
// KEEP: Y
// DB = 0x7e
#[idx16]
inline func get_u16_xx(let gsVar16 : var16) : u16 in xx {
    return gamestate.data.u16_vars[unaligned gsVar16 as u16];
}


// CAUTION: gsVar16 is not bounds or alignment checked.
// KEEP: Y
// DB = 0x7e
#[mem16, idx8]
inline func get_dyn_u16(gsVar16 : var16 in x) : u16 in aa {
    return gamestate.data.u16_vars[unaligned x];
}


// CAUTION: gsVar16 is not bounds or alignment checked.
// KEEP: Y
// DB = 0x7e
#[mem16]
inline func set_u16_aa(let gsVar16 : var16, value: u16 in aa) {
    gamestate.data.u16_vars[unaligned gsVar16 as u16] = aa;
}


// CAUTION: gsVar16 is not bounds or alignment checked.
// KEEP: Y
// DB = 0x7e
#[idx16]
inline func set_u16_xx(let gsVar16 : var16, value: u16 in xx) {
    gamestate.data.u16_vars[unaligned gsVar16 as u16] = xx;
}


// CAUTION: gsVar16 is not bounds or alignment checked.
// KEEP: Y
// DB = 0x7e
#[mem16, idx8]
inline func set_dyn_u16(gsVar16 : var16 in x, value: u16 in aa) {
    gamestate.data.u16_vars[unaligned x] = aa;
}


// CAUTION: gsVar16 is not bounds or alignment checked.
// KEEP: Y
// DB = 0x7e
#[mem8, idx8]
func saturating_inc_u16__mem8(gsVar16 : var16 in x) {
    mem16();
    #[mem16] {
        aa = gamestate.data.u16_vars[unaligned x];
        aa++;
        if zero {
            aa--;
        }
        gamestate.data.u16_vars[unaligned x] = aa;
    }
    mem8();
}


// CAUTION: gsVar16 is not bounds or alignment checked.
// KEEP: Y
// DB = 0x7e
#[mem8, idx8]
func checked_dec_u16__mem8(gsVar16 : var16 in x) : bool in carry {
    mem16();
    #[mem16] {
        aa = gamestate.data.u16_vars[unaligned x];
        cmp(aa, 1);
        if carry {
            aa--;
            gamestate.data.u16_vars[unaligned x] = aa;
        }
    }
    mem8();
    return carry;
}

}

}

