// Gamestate variables
//
// Copyright (c) 2022, Marcus Rowe <undisbeliever@gmail.com>.
// Distributed under The MIT License, see the LICENSE file for more details.

import "src/memmap";

import "dungeon";
import "../entity_api";
import "../resources/resources";

import "src/engine-hooks";
import "gen/enums";


in lowram {
    // Number of frames processed.
    // (incremented every `WaitFrame` call)
    //
    // MUST be in the `lowram` bank to work correctly.
    //
    // (u32)
    var frameCounter : u32;

        var frameCounter_lobyte @ &<:frameCounter : u8;

        var frameCounter_loword @ &frameCounter              : u16;
        var frameCounter_hiword @ (&frameCounter as u16 + 2) : u16;
}


namespace gamestate {

typealias PlayerState : engine_hooks.GameState__PlayerState;


// unnamed snes game!
let __SIGNATURE = "USG!";

let SIGNATURE_W0 = (__SIGNATURE[0] as u16) | (__SIGNATURE[1] as u16 << 8);
let SIGNATURE_W1 = (__SIGNATURE[2] as u16) | (__SIGNATURE[3] as u16 << 8);


struct RoomToLoad {
    dungeon: u8,
    room_x: u8,
    room_y: u8,

    player_x: u8,
    player_y: u8,
    player_z: u8,

    // ::TODO add to mappings.json::
    player_state: u8,
    // ::TODO add to mappings.json::
    player_direction: u8,
}


struct GameStateData {
    // Game state signature
    signature : [u16 ; 2],

    // The checksum of the data
    // Updated whenever the gamestate backup is created.
    checksum : u16,

    // The player position to load on new-game/continue/reload
    playerPosition : RoomToLoad,

    // The player's state at the start of the room
    // (or when saving, loading or starting a new game)
    // ::TODO move elsewhere::
    playerState : PlayerState,


    // Game State flags
    // (256 bit bitfield)
    gameFlags : [ u8 ; 256 / 8 ],

    // Number of keys held by the player
    //
    // NOTE: This function should not be modified by game code
    _keyCount : u8,
};


in wram7e {
    var __far_roomToLoad : RoomToLoad;
        var roomToLoad @ &__far_roomToLoad : RoomToLoad;
}


in wram7e_roomstate {
    // game state data MUST be in `wram7e_roomstate` to ensure the game state is rolled back correctly if a room-transition fails.
    var __fardata : GameStateData;
        var data @ &__fardata : GameStateData;
}


in wram7f_gamestatebackup {
    // A backup of the gamestate that exists at the end of WRAM.
    // The backup is saved on every successful room transition
    // Used to restore the game to a known good state on a crash (or reset).
    var gamestateBackup : GameStateData;
}


in code {

// Returns true if the gamestate backup is valid.
//
// DB = 0x7e
#[mem8, idx8]
func init() : bool in carry {
    mem16_idx16();
    #[mem16, idx16] {
        carry = restore_gamestate_backup__inline();
    }
    mem8_idx8();

    if carry {
        return carry;
    }

    // gamestate backup is missing or corrupt.  Start a new game.
    new_game();
    return false;
}



// Reset the gamestate with new-game data.
//
// DB = 0x7e
#[mem8, idx8]
func new_game() {
    // Populate initial player state
    mem16_idx16();
    #[mem16, idx16] {
        // Clear gamestate
        *(&data as *u16) = 0;
        // Parameter order is destination, source
        load_dec_repeat(#:far &__fardata, yy = &data as u16 + 1,
                        #:far &__fardata, xx = &data as u16,
                        aa = sizeof(typeof(data)) - 2);

        // Load initial player state
        load_dec_repeat(#:far &__fardata, yy = &data.playerState as u16,
                        #:far &InitialPlayerState, xx = &InitialPlayerState as u16,
                        aa = sizeof(typeof(data.playerState)) - 1);
        // DB = 0x7e
    }
    mem8_idx8();


    // Force a dungeon load on the next room transition
    dungeon.mark_dungeon_unloaded();

    // Load the default room of dungeon 0.
    data.playerPosition.dungeon = a = 0xff;
}



// Continue current game
//
// Moves player back to the start and resets health.
//
// DB = 0x7e
#[mem8, idx8]
func continue_game() {

    // ::TODO create some kind of checkpoint system::

    engine_hooks.gamestate__continue_game__inline();

    engine_hooks.gamestate__continue_player_gamestate__inline();

    // Force a dungeon load on the next room transition
    dungeon.mark_dungeon_unloaded();
}



// Calculate a checksum for the current gamestate.
//
// NOTE: This function does not modify gamestate
//
// DB = 0x7e
#[mem16, idx16]
func calculate_checksum() : u16 in aa {
var _tmp         : u16 in zpTmp_word_0;
var _oldChecksum : u16 in zpTmp_word_1;

    _oldChecksum = xx = data.checksum;


    // A silly little checksum I dreamt up.
    // I have no idea how effective it is.

    // ::TODO do some tests on this checksum::

    // Set checksum to a constant value
    data.checksum = aa = 0x1234;

    _tmp = 0;
    // checksum relies on the carry flag the previous operation
    carry = false;

    xx = sizeof(typeof(data)) - 1;
    do {
        aa = (&data as *u16)[unaligned xx] & 0xff;

        // I am deliberately reusing the carry from the previous operation
        aa +#= _tmp;
        aa <<<<#= 1;    // rol
        aa ^= (1 << 10) | (1 << 3);
        _tmp = aa;

        xx--;
    } while !negative;


    // Restore checksum (keep it unchanged)
    data.checksum = xx = _oldChecksum;

    return aa;
}




// Create a backup of the gamestate
//
// DB = 0x7e
#[mem8, idx8]
func backup_gamestate() {
    populate_room_to_load();
    _copy_room_to_load_to_gamestate();

    engine_hooks.gamestate__save_player_state__inline();


    mem16_idx16();
    #[mem16, idx16] {
        // set signature
        data.signature[0] = aa = SIGNATURE_W0;
        data.signature[1] = aa = SIGNATURE_W1;

        data.checksum = aa = calculate_checksum();

        // Parameter order is destination, source
        load_dec_repeat(#:far &gamestateBackup, yy = &gamestateBackup as u16,
                        #:far &__fardata, xx = &data as u16,
                        aa = sizeof(typeof(data)) - 1);
    // DB = 0x7f
    }
    mem8_idx8();

    push8(a = 0x7e);
    data_bank = pop8();
// DB = 0x7e
}



// Restore gamestate backup.
//
// Returns true if the backup is valid.
//
// NOTE: Clobbers the old gamestate
//
// DB = 0x7e
#[mem16, idx16]
inline func restore_gamestate_backup__inline() : bool in carry {
    // Parameter order is destination, source
    load_dec_repeat(#:far &__fardata, yy = &data as u16,
                    #:far &gamestateBackup, xx = &gamestateBackup as u16,
                    aa = sizeof(typeof(data)) - 1);
// DB = 0x7e

    // Check checksum and signature is correct
    aa = calculate_checksum();
    xx = SIGNATURE_W0;
    yy = SIGNATURE_W1;
    if aa == data.checksum && xx == data.signature[0] && yy == data.signature[1] {
        return true;
    }

    return false;
}



// Populate `roomToLoad` with the player's current position.
//
// DB = 0x7e
#[mem8, idx8]
func populate_room_to_load() {
    gamestate.roomToLoad.room_x = a = gamestate.data.playerPosition.room_x;
    gamestate.roomToLoad.room_y = a = gamestate.data.playerPosition.room_y;
    gamestate.roomToLoad.dungeon = a = gamestate.data.playerPosition.dungeon;

    gamestate.roomToLoad.player_x = a = player.xPos.px;
    gamestate.roomToLoad.player_y = a = player.yPos.px;
    gamestate.roomToLoad.player_z = a = player.zPos;

    roomToLoad.player_state = a = engine_hooks.get_roomtoload_player_state__inline();
    roomToLoad.player_direction = a = engine_hooks.get_roomtoload_player_direction__inline();
}



// Copy `gamestate.playerPosition` to `roomToLoad`
//
// DB = 0x7e
#[mem8, idx8]
func copy_gamestate_to_room_to_load() {
    x = sizeof(RoomToLoad) - 1;
    do {
        (&roomToLoad as *u8)[x] = a = (&data.playerPosition as *u8)[x];
        x--;
    } while !negative;
}



// Copy `roomToLoad` to `data.playerPosition`.
//
// Caution: invalidates roomToLoad.
//
// DB = 0x7e
#[mem8, idx8]
func _copy_room_to_load_to_gamestate() {
    x = sizeof(RoomToLoad) - 1;
    do {
        (&data.playerPosition as *u8)[x] = a = (&roomToLoad as *u8)[x];
        x--;
    } while !negative;
}



// Returns true if the game flag is clear
//
// DB = 0x7e
#[mem8, idx8]
func is_flag_clear(flag_id : u8 in x) : bool in zero {
    y = a = x >>> 3;
    x = a = x & 7;

    a = data.gameFlags[y] & _BitTable[x];
    return zero;
}


// Returns true if the game flag is clear (without clobbering the Y register)
//
// KEEP: y
//
// DB = 0x7e
#[mem8, idx8]
func is_flag_clear__keep_y(flag_id : u8 in x) : bool in zero {
var _tmp : u8 in zpTmp_byte_0;

    _tmp = y;

    y = a = x >>> 3;
    x = a = x & 7;

    a = data.gameFlags[y];

    y = _tmp;

    a &= _BitTable[x];
    return zero;
}


// DB = 0x7e
#[mem8, idx8]
func set_game_flag(flag_id : u8 in x) {
    y = a = x >>> 3;
    x = a = x & 7;

    data.gameFlags[y] = a = data.gameFlags[y] | _BitTable[x];
}



// KEEP: Y
//
// DB = 0x7e
#[mem8, idx8]
func set_game_flag__keep_y(flag_id : u8 in x) {
var _tmp : u8 in zpTmp_byte_0;

    _tmp = y;

    y = a = x >>> 3;
    x = a = x & 7;

    data.gameFlags[y] = a = data.gameFlags[y] | _BitTable[x];

    y = _tmp;
}



// Increment the key counter
// DB = 0x7e
#[mem8, idx8]
func increment_key_count() {
    x = data._keyCount;
    x++;
    if negative {
        x = 127;
    }
    data._keyCount = x;

    ^return engine_hooks.gamestate__key_count_changed(x);
}



// Decrement the key counter.
//
// Return true if there was a key to decrement.
//
// DB = 0x7e
#[mem8, idx8]
func test_and_decrement_key_count() : bool in carry{
    x = data._keyCount;
    if !zero {
        x--;
        data._keyCount = x;

        engine_hooks.gamestate__key_count_changed(x);
        return true;
    }
    return false;
}


}


in rodata0 {

const __BitTable : [ u8 ; 8 ] = [ 1 << i for let i in 0..7 ];

let _BitTable = far &__BitTable as far *u8;


const InitialPlayerState : PlayerState = engine_hooks.GameState__InitialPlayerState;

}

}

