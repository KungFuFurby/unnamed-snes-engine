// Copyright (c) 2024, Marcus Rowe <undisbeliever@gmail.com>.
// Distributed under The MIT License, see the LICENSE file for more details.

import "src/memmap";
import "../registers";
import "../registers_math.wiz";
import "../wait-frame";

import "room-transitions";

import "../resources/dma";
import "../resources/resources";
import "../common/math";

import "gen/enums";

namespace second_layer {

// ::TODO add a second layer with a height of 32 to the tech-demo::
// ::TODO add a second layer with a width of 64 to the tech-demo::
// ::TODO add a second layer with a width of 32 to the tech-demo::


let TILE_PX = 8;
let TILE_PX_MASK = 7;
let POSITION_TILE_MASK = 0xffff ^ TILE_PX_MASK;


let DISPLAY_WIDTH = 256;
let DISPLAY_HEIGHT = 224;

let VRAM_TILEMAP_WIDTH = 512;
let VRAM_TILEMAP_HEIGHT = 256;

let VRAM_TILEMAP_TILE_WIDTH = 64;
let VRAM_TILEMAP_TILE_HEIGHT = 32;

// The VRAM tilemap is made up of 2 smaller 32x32 tilemaps
let NAMETABLE_TILE_WIDTH = 32;
let NAMETABLE_TILE_HEIGHT = 32;
let NAMETABLE_WORD_SIZE = NAMETABLE_TILE_WIDTH * NAMETABLE_TILE_HEIGHT;

let VIEWPORT_X_OFFSET = (VRAM_TILEMAP_WIDTH - DISPLAY_WIDTH) / 2;
let VIEWPORT_Y_OFFSET = (VRAM_TILEMAP_HEIGHT - DISPLAY_HEIGHT) / 2;


let MAX_TILES_PER_BG = 1024;

let MAX_TILEMAP_CELLS = 6 * 1024;


struct _SecondLayerHeader {
    // If non-zero, the second layer is a part of the room.
    //
    // When set, the second layer will only scroll in sync with a room-transition.
    partOfRoom: u8,

    // Map tile width (minimum value: 32)
    width: u8,
    // Map tile height (minimum value: 32)
    height: u8,

    // Index into `sl_callbacks` function tables
    callback_index: u8,

    callback_parameters : [u8 ; 8],
}

// Second layer data stored in RAM
//
// PPU data format: 4bpp tiles (note, to be placed at the end of BG1/BG2 tile data)
struct _RamDataFormat {
    // Header MUST NOT be modified inside a callback.
    header: _SecondLayerHeader,

    // Tilemap data (contagious row major order)
    // NOTE: tilemap data may be smaller then `MAX_TILEMAP_SIZE`
    tilemap: [u16; MAX_TILEMAP_CELLS]
};

// Storing variables in lowram so they can be accessed by setup (DB=0x80) and process (DB=0x7e).
// NOTE: These variables MUST NOT be modified by the sl_callback
in lowram {
    // The rightmost position
    var right : u16;

    // The leftmost position
    var bottom : u16;


    // Tilemap size (in bytes)
    var tilemapSize : u16;

    // Number of bytes per column in the tilemap
    var tilemapStride : u16;

    // The sl_tilemap offset between tilemapSeam and the row to draw above the viewport.
    // (equal to `tilemapStride * 31`)
    var tilemapAboveViewportOffset : u16;  // ::DBEUG find better name::


    var xScrollShadow : u16 in bg2_scrollX;
        var xScrollShadow_l : u8 in <:xScrollShadow;
        var xScrollShadow_h : u8 in >:xScrollShadow;
    var yScrollShadow : u16 in bg2_scrollY;
        var yScrollShadow_l : u8 in <:yScrollShadow;
        var yScrollShadow_h : u8 in >:yScrollShadow;


    // The x-component of the tilemap seam.
    //
    // NOTE: The tilemap seam is on the bottom-right (start + 63 columns).
    //
    // MUST BE:
    //   * a multiple of 2
    //   * less than `tilemapStride`
    //
    // (index into sl_tilemap)
    var tilemapSeam_x : u16;

    // The y-component of the tilemap seam.
    //
    // NOTE: The tilemap seam is on the bottom-right (start + 31 rows).
    //
    // MUST BE:
    //   * a multiple of `tilemapStride`
    //   * less than `tilemapSize`
    //
    // (index into sl_tilemap)
    var tilemapSeam_y : u16;


    // VBlank flags to determine which buffer (if any) to transfer on the next VBlank.
    var bufferState : u8;
        let BUFFER_STATE__VERTICAL_BIT = 7;
        let BUFFER_STATE__HORIZONTAL_BIT = 6;

    // Bitflags to signal if the vertical_buffer or horizontal_buffer should be skipped.
    //
    // Vertical buffer updates can be skipped if the second-layer is 32 or 64 tiles wide.
    // Horizontal buffer updates can be skipped if the second-layer is 32 tiles tall.
    var skipFlags : u8;
        let SKIP_FLAGS__VERTICAL_BIT = 7;
        let SKIP_FLAGS__HORIZONTAL_BIT = 6;

    namespace vertical_buffer {
        var vramWordAddr : u16;

        // The masked previous position
        //
        // Used:
        //  * to determine if xPos/yPos has advanced past a tile boundary.
        //  * to determine scrolling direction.
        //  * to limit xPos/yPos to a single tile update per frame.
        //    (since I'm auto-wrapping xPos/yPos, I may as well limit it to the actual location)
        var maskedPrevXPos : u16;

        // Position within `buffer`.
        // Used to calculate `horizontal_buffer.vramWordAddr1`.
        // MUST ALWAYS be even and masked by `CURSOR_INDEX_MASK`.
        var cursorIndex : u16;

        // Offset between `sl_callbacks.xPos_px` and `xScrollShadow`.
        // Used because `xScrollShadow` might be changed outside this subsystem.
        var viewportXOffset : u16;
    }


    namespace horizontal_buffer {
        var vramWordAddr1 : u16;
        var vramWordAddr2 : u16;

        // See `vertical_buffer.maskedPrevYPos`
        var maskedPrevYPos : u16;

        // Position within `buffer`.
        // Used to calculate `vertical_buffer.vramWordAddr`.
        // MUST ALWAYS be even and masked by `CURSOR_INDEX_MASK`.
        var cursorIndex : u16;

        // Offset between `sl_callbacks.yPos_px` and `yScrollShadow`.
        // Used because `xScrollShadow` might be changed outside this subsystem.
        var viewportYOffset : u16;
    }
}

in wram7e {
    // this hack allows me to write `tilemap[x]` without a compile error.
    var __far_sl_data : _RamDataFormat;
        const sl_data @ &__far_sl_data : _RamDataFormat;
        const sl_header @ &__far_sl_data : _SecondLayerHeader;
        const sl_tilemap @ &__far_sl_data.tilemap[0] : [u16 ; MAX_TILEMAP_CELLS];

    // Callback parameters
    const sl_parameters @ &sl_header.callback_parameters[0] : typeof(sl_header.callback_parameters);

    namespace vertical_buffer {
        var buffer : [u16 ; 32];
        let CURSOR_INDEX_MASK = 31 * 2;
    }

    namespace horizontal_buffer {
        // NOTE: This buffer requires 2 transfers to load into VRAM.
        var buffer : [u16 ; 64];
        let CURSOR_INDEX_MASK = 63 * 2;
    }
}


in code {


// Load the second-layer into memory and draw the tilemap to VRAM.
//
// REQUIRES: Force-Blank
// REQUIRES: Room loaded
// Uses DMA channel 0
//
// DB = 0x80
#[mem8, idx16]
func setup__forceblank__inline(second_layer_id : u8 in a) {
    load_second_layer__forceblank__inline(a);

    push16(0x807e);
    data_bank = pop8();
// DB = 0x7e

    mem16_idx16();
    #[mem16, idx16] {
        // Clear sl_callback variables
        // Assumes __STATE_SIZE is even
        xx = sl_callbacks.__STATE_SIZE - 2;
        do {
            (sl_callbacks.__STATE_START_ADDR as *u16)[unaligned xx] = 0;
            xx--;
            xx--;
        } while !negative;
    }
    mem8_idx8();
    #[mem8, idx8] {
        a = sl_header.callback_index;
        if a >= sl_callbacks.N_SECOND_LAYER_FUNCTIONS {
            a = 0;
        }
        a &= (0xff - 1);
        *(&__far_sl_data.header.callback_index as *u8) = a;

        x = a;
        sl_callbacks.init_function_table[unaligned xx]();
    }
    idx16();

    data_bank = pop8();
// DB = 0x80

    _draw_fullscreen.draw__forceblank__inline();
}


// Load a second-layer into memory and the PPU.
//
// NOTE: Does not initialize state variables.
//
// REQUIRES: Force-Blank
// Uses DMA channel 0
//
// DB = 0x80
#[mem8, idx16]
inline func load_second_layer__forceblank__inline(second_layer_id : u8 in a) {
var _ppuData : resources.PpuData_Dma0 in resources.ppuData;

    _ppuData = resources.load_resource__dynamic_ram_and_ppu_data__forceblank_inline(
        resources.ResourceType.second_layer, a, &sl_data as *u8, sizeof(typeof(sl_data)));

    // Transfer tiles to VRAM
    // Second Layer tiles are loaded at the end of the BG1 tile block.
    mem16();
    #[mem16] {
        VMADD = aa = ((VRAM_BG1_TILES_WADDR * 2 + MAX_TILES_PER_BG * 32) - _ppuData.remaining) >>> 1;
    }
    mem8();

    resources.dma_remaining_to_vram__forceblank(_ppuData);
}


namespace _draw_fullscreen {
    in zeropage {
        var _tilePos_x : u8 in zpTmp_byte_0;
        var _tilePos_y : u8 in zpTmp_byte_1;

        var _dmaSize1 : u8 in zpTmp_byte_2;
        var _dmaSize2 : u8 in zpTmp_byte_3;

        var _partOfRoom : u8 in zpTmp_byte_2;

        var _endAddr : u16 in zpTmp_word_0;

        var _mapTileSize : u16 in zpTmp_word_1;
            var _mapWidth : u8 in <:_mapTileSize;
            var _mapHeight : u8 in >:_mapTileSize;
    }


    #[mem16, idx8]
    inline func __clamp_pos(let pos : *u16, let max : *u16, let maskedPrevPos : *u16) : u8 in x {
        aa = *pos;
        if negative {
            aa += *max;
            if negative {
                aa = direct_page; // 0
            }
        }
        else if aa >= *max {
            aa -= *max;
            if aa >= *max {
                aa = direct_page; // 0
            }
        }
        *pos = aa;

        aa &= POSITION_TILE_MASK;
        *maskedPrevPos = aa;

        aa >>>= 3;
        #[idx16] xx = aa;
        return x;
    }


    // Draw the second layer to VRAM (using DMA) and populate the state variables.
    //
    // NOTE: The viewport starts in the middle of the VRAM tilemap to save 1 DMA transfer per scanline.
    //
    // REQUIRES: Force-Blank
    // REQUIRES: Second layer loaded
    // Uses DMA channel 0
    //
    // DB = 0x80
    #[mem8, idx16]
    inline func draw__forceblank__inline() {
        VMAIN = a = VMAIN_INCREMENT_1 | VMAIN_INCREMENT_HIGH;
        VMADD = xx = VRAM_BG2_MAP_WADDR;

        bufferState = 0;
        skipFlags = 0;

        var __sl_header_partOfRoom @ &__far_sl_data.header.partOfRoom : u8;
        _partOfRoom = a = *(far &__sl_header_partOfRoom);

        push8(p);
        mem16();
        idx8();
        #[mem16, idx8] {
            // Copy map width AND height to zeropage
            var __sl_header_mapTileSize @ &__far_sl_data.header.width : u16;
            _mapTileSize = aa = *(far &__sl_header_mapTileSize);

            WRMPYA_WRMPYB = aa; // Also writes height to WRMPYB

            // Must wait 8 CPU cycles before reading RDMPY
            tilemapStride = aa = (aa & 0xff) <<< 1; // 3 (and) + 2 (asl) + 5 (sta) cycles
            tilemapAboveViewportOffset = aa = (aa <<< 5) - tilemapStride;
            tilemapSize = aa = RDMPY <<< 1;

            _endAddr = aa = aa + (&sl_data.tilemap[0] as u16);

            x = _mapWidth;
            right = aa = xx <<< 3;

            y = _mapHeight;
            bottom = aa = yy <<< 3;

            x = _partOfRoom;
            ^if zero {
                __init_state__normal__inline();
            }
            else {
                __init_state__part_of_room__inline();
            }
        }
        p = pop8();


        a = _partOfRoom;
        if zero {
            __draw_tilemaps__normal__forceblank__inline();
        }
        else {
            __draw_tilemaps__part_of_room__forceblank__inline();
        }
    }


    #[mem16, idx8]
    inline func __init_state__normal__inline() {
        x = __clamp_pos(&sl_callbacks.xPos_px, &right, &vertical_buffer.maskedPrevXPos);
        y = _mapWidth;
        if y == VRAM_TILEMAP_TILE_WIDTH || y == NAMETABLE_TILE_WIDTH {
            // _mapWidth matches VRAM tilemap width.
            // Disable the vertical buffer.
            skipFlags = y = 1 << SKIP_FLAGS__VERTICAL_BIT;

            // Set _tilePos_x so the leftmost tile in the VRAM tilemap has an xPos of 0.
            x = VIEWPORT_X_OFFSET / TILE_PX;

            y = 0;
            aa = sl_callbacks.xPos_px;
        } else {
            y = VIEWPORT_X_OFFSET;
            aa = (sl_callbacks.xPos_px & TILE_PX_MASK) | VIEWPORT_X_OFFSET;
        }
        _tilePos_x = x;
        xScrollShadow = aa;
        vertical_buffer.viewportXOffset = aa = yy;
        vertical_buffer.cursorIndex = 0;

        x = __clamp_pos(&sl_callbacks.yPos_px, &bottom, &horizontal_buffer.maskedPrevYPos);
        y = _mapHeight;
        if y == VRAM_TILEMAP_TILE_HEIGHT {
            // _mapHeight matches VRAM tilemap height.
            // Disable the horizontal buffer.
            test_and_set(*(&skipFlags as *u16), aa = 1 << SKIP_FLAGS__HORIZONTAL_BIT);

            // Set _tilePos_y so the topmost tile in the VRAM tilemap has a yPos of 0.
            x = VIEWPORT_Y_OFFSET / TILE_PX;
            y = 0;
            aa = sl_callbacks.yPos_px;
        }
        else {
            y = (VIEWPORT_Y_OFFSET - 1);
            aa = (sl_callbacks.yPos_px & TILE_PX_MASK) | VIEWPORT_Y_OFFSET;
            aa--;
        }
        _tilePos_y = x;
        yScrollShadow = aa;
        horizontal_buffer.viewportYOffset = aa = yy;
        horizontal_buffer.cursorIndex = 0;
    }


    // REQUIRES: Force-Blank
    // Uses DMA channel 0
    //
    // IN: VMADD = vram address to write to
    #[mem8, idx16]
    inline func __draw_tilemaps__normal__forceblank__inline() {
        WRMPYA = a = _mapWidth;
        a = _tilePos_y - (VIEWPORT_Y_OFFSET / TILE_PX);
        if !carry {
            a += _mapHeight;
        }
        WRMPYB = a;
        // Must wait 8 CPU cycles before reading RDMPY


        a = _tilePos_x - (VIEWPORT_X_OFFSET / TILE_PX);
        if !carry {
            a += _mapWidth;
        }
        __draw_nametable__forceblank(a);

        a = _tilePos_x + (NAMETABLE_TILE_WIDTH - VIEWPORT_X_OFFSET / TILE_PX);
        if carry || a >= _mapWidth {
            a -= _mapWidth;
        }
        __draw_nametable__forceblank(a);


        // Calculate the tilemapSeam (bottom-right seam corner)
        a = _tilePos_y + (VRAM_TILEMAP_TILE_HEIGHT - VIEWPORT_Y_OFFSET / TILE_PX - 1);
        if carry || a >= _mapHeight {
            a -= _mapHeight;
        }
        WRMPYB = a;
        // Must wait 8 CPU cycles before reading RDMPY

        a = _tilePos_x + (VRAM_TILEMAP_TILE_WIDTH - VIEWPORT_X_OFFSET / TILE_PX - 1);
        if carry || a >= _mapWidth {
            a -= _mapWidth;
        }

        mem16();
        #[mem16] {
            tilemapSeam_x = aa = (aa & 0xff) <<< 1;
            tilemapSeam_y = aa = (RDMPY <<< 1);
        }
        mem8();
    }


    #[mem16, idx8]
    inline func __init_state__part_of_room__inline() {
        // ::TODO get tile position from room::
        x = 0x50;
        if x >= _mapWidth {
            x = 0;
        }
        _tilePos_x = x;

        // ::TODO get tile position from room::
        y = 0x30;
        if y >= _mapHeight {
            y = 0;
        }
        _tilePos_y = y;

        xScrollShadow = 0;
        vertical_buffer.viewportXOffset = 0;
        vertical_buffer.cursorIndex = 0;

        aa = -1 as u16;
        yScrollShadow = aa;
        horizontal_buffer.viewportYOffset = aa;
        horizontal_buffer.cursorIndex = 0;
    }


    // REQUIRES: Force-Blank
    // Uses DMA channel 0
    //
    // IN: VMADD = vram address to write to
    #[mem8, idx16]
    inline func __draw_tilemaps__part_of_room__forceblank__inline() {
        WRMPYA = a = _mapWidth;
        WRMPYB = a = _tilePos_y;
        // Must wait 8 CPU cycles before reading RDMPY

        __draw_nametable__forceblank(_tilePos_x);

        xx = 0;
        tilemapSeam_x = xx;
        tilemapSeam_y = xx;
    }


    // Draw a single nametable (32x32 tilemap) to VRAM.
    //
    // REQUIRES: Force-Blank
    // Uses DMA channel 0
    //
    // IN: xTilePos
    // IN: VMADD = vram address to write to
    // IN: RDMPY = tileY * tileWidth
    //
    // OUT: The index of the top-left tile for the nametable.
    //
    // DB = 0x80
    #[mem8, idx16]
    func __draw_nametable__forceblank(xTilePos : u8 in a) {
        let ROWS_TO_DRAW = VRAM_TILEMAP_HEIGHT / TILE_PX;
        let COLUMNS_TO_DRAW = 32;

        push8(a);
        {
            dma.set_dmap0_and_bbad0__yy(DMAP_TO_PPU | DMAP_TRANSFER_TWO, <:&VMDATAL);

            // Calculate size of the two DMA transfers
            a = _mapWidth - (ss as *u8)[1];
            if a >= COLUMNS_TO_DRAW {
                a = COLUMNS_TO_DRAW;
            }
            a <<= 1;
            _dmaSize1 = a;

            _dmaSize2 = a = COLUMNS_TO_DRAW * 2 - _dmaSize1;
        }
        a = pop8();

        push8(p);
        mem16();
        idx8();
        #[mem16, idx8] {
            aa = (aa & 0xff) + RDMPY;
            aa <<<= 1;

            aa += (&sl_data.tilemap[0] as u16);


            // Set DAS0H to 0
            DAS0 = 0;

            A1B0 = x = 0x7e;

            y = ROWS_TO_DRAW;
            do {
                A1T0 = aa;
                // DAS0H is 0
                DAS0L = x = _dmaSize1;
                MDMAEN = x = MDMAEN_DMA0;

                x = _dmaSize2;
                if !zero {
                    // Tilemap wrapping is required.
                    // Do a second DMA transfer.

                    // DAS0H is 0
                    DAS0L = x;

                    push16(aa);

                    // A1T0 points to the end of the row
                    A1T0 = aa = *(&A1T0 as *u16) - tilemapStride;
                    MDMAEN = x = MDMAEN_DMA0;

                    aa = pop16();
                }

                aa += tilemapStride;
                if aa >= _endAddr {
                    aa -= tilemapSize;
                }

                y--;
            } while !zero;
        }
        p = pop8();
    }
}


// REQUIRES: VBlank or Force-Blank
// Uses DMA channel 0
//
// DB = 0x80
#[mem8, idx16]
inline func transfer_buffers__vblank() {
    // MUST NOT modify zpTmp variables

    a = bufferState;
    if !zero {
        if negative {
            VMAIN = a = VMAIN_INCREMENT_HIGH | VMAIN_INCREMENT_32;
            VMADD = xx = vertical_buffer.vramWordAddr;

            dma.set_dmap0_and_bbad0__yy(DMAP_TO_PPU | DMAP_TRANSFER_TWO, <:&VMDATA);

            A1T0 = xx = &vertical_buffer.buffer as u16;
            A1B0 = a = #:far &vertical_buffer.buffer;

            DAS0 = xx = sizeof(typeof(vertical_buffer.buffer));

            MDMAEN = a = MDMAEN_DMA0;
        }

        if bufferState $ BUFFER_STATE__HORIZONTAL_BIT {
            VMAIN = a = VMAIN_INCREMENT_HIGH | VMAIN_INCREMENT_1;

            // Transfer the first half of the buffer to the left nametable
            VMADD = xx = horizontal_buffer.vramWordAddr1;

            dma.set_dmap0_and_bbad0__yy(DMAP_TO_PPU | DMAP_TRANSFER_TWO, <:&VMDATA);

            A1T0 = xx = &horizontal_buffer.buffer as u16;
            A1B0 = a = #:far &horizontal_buffer.buffer;

            DAS0 = xx = sizeof(typeof(horizontal_buffer.buffer)) / 2;

            MDMAEN = a = MDMAEN_DMA0;

            // Transfer the second half of the buffer to the right nametable
            VMADD = yy = horizontal_buffer.vramWordAddr2;

            DAS0 = xx;
            MDMAEN = a;
        }

        bufferState = 0;
    }
}


// Returns true if the second layer is not part of the room.
//
// DB = 0x7e
#[mem8]
inline func is_not_part_of_room() : bool in zero{
    a = sl_header.partOfRoom;
    return zero;
}



// Execute the second-layer callback function.
//
// NOTE: This function will not directly call `scroll_tilemap()`.
//       The `scroll_tilemap()` call must be preformed in the callback function.
//
//       This will allow the callback function to access the scroll shadow variables
//       (ie, for HDMA effects) after `scroll_tilemap()` has modified them.
#[mem8, idx8]
inline func process__inline() {
    x = sl_header.callback_index;
    sl_callbacks.process_function_table[unaligned x]();
}



// Scroll the second-layer to `sl_callbacks.xPos_px`/`sl_callbacks.yPos_px`, updating the tilemap as required.
//
// This function will update `sl_callbacks.xPos_px` and `sl_callbacks.yPos_px` to ensure it is within the bounds of the
// sl_tilemap (in Work-RAM).
//   * If the position is negative, it will be wrapped to the bottom and/or right side of the sl_tilemap.
//   * The second-layer can be scrolled a maximum of 8-pixels per frame.
//     If this limit is exceeded, the position will be clipped.
//
// This function MUST only be called once per frame.
//
// DB = 0x7e
#[mem8, idx8]
func scroll_tilemap() {
    // Forbid `scroll_tilemap()` if either:
    //  * partOfRoom is set
    //  * the buffers are populated
    a = sl_header.partOfRoom | bufferState;
    if !zero {
        return;
    }

    mem16_idx16();
    #[mem16, idx16] {
        // assumes SKIP_FLAGS__VERTICAL_BIT == 7
        bit((&skipFlags as *u16)[unaligned -1]);
        if negative {
            aa = sl_callbacks.xPos_px;
            ^goto _EndIf_Vertical;
        }
        // ^else
        {
            vertical_buffer.update__inline();

            // Can use |, `viewportXOffset` is tile aligned
            aa = (sl_callbacks.xPos_px & TILE_PX_MASK) | vertical_buffer.viewportXOffset;
        }
    _EndIf_Vertical:
        xScrollShadow = aa;


        // assumes SKIP_FLAGS__HORIZONTAL_BIT == 6
        bit((&skipFlags as *u16)[unaligned -1]);
        if overflow {
            aa = sl_callbacks.yPos_px;
            aa--;
            ^goto _EndIf_Horizontal;
        }
        // ^else
        {
            horizontal_buffer.update__inline();

            // Must use + here, `viewportYOffset` is not tile aligned
            aa = (sl_callbacks.yPos_px & TILE_PX_MASK) + horizontal_buffer.viewportYOffset;
        }
    _EndIf_Horizontal:
        yScrollShadow = aa;
    }
    mem8_idx8();
}



namespace vertical_buffer {

    // Process any changes to `sl_callbacks.xPos_px` and populate the `vertical_buffer` as required.
    //
    // DB = 0x7e
    #[mem16, idx16]
    inline func update__inline() {
        aa = sl_callbacks.xPos_px - maskedPrevXPos;
        yy = aa;
        if negative {
            viewportXOffset = aa = viewportXOffset - TILE_PX;

            aa = maskedPrevXPos - TILE_PX;
            if negative {
                sl_callbacks.xPos_px = aa = (sl_callbacks.xPos_px & TILE_PX_MASK) + right - TILE_PX;
                aa &= POSITION_TILE_MASK;
            }
            maskedPrevXPos = aa;

            if yy < -TILE_PX as u16 {
                // Clamp xPos if xPos has moved more than 1 tile
                sl_callbacks.xPos_px = aa;
            }

            // Assumes `tilemapSeam_x` is even
            aa = tilemapSeam_x;
            aa--;
            if negative {
                aa = tilemapStride;
                aa--;
            }
            aa--;
            tilemapSeam_x = aa;

            // Move `xx` leftwards.
            // As the tilemap has infinite scrolling, wrap if `aa is negative
            // since tilemapStride (min 32) might be < VRAM_TILEMAP_TILE_WIDTH (64), do it twice.
            aa -= (VRAM_TILEMAP_TILE_WIDTH - 1) * 2;
            if negative {
                aa += tilemapStride;
                if negative {
                    aa += tilemapStride;
                }
            }
            xx = aa;

            aa = horizontal_buffer.pre_decrement_cursor__inline__keep_xx();

            populate_buffer(xx, aa);
        }
        else if aa >= TILE_PX {
            // yy = aa

            viewportXOffset = aa = viewportXOffset + TILE_PX;

            aa = maskedPrevXPos + TILE_PX;
            if aa >= right {
                sl_callbacks.xPos_px = aa = sl_callbacks.xPos_px & TILE_PX_MASK;
                aa = 0;
            }
            maskedPrevXPos = aa;

            if yy >= TILE_PX * 2 {
                // Clamp xPos if xPos has moved too much
                sl_callbacks.xPos_px = aa = aa | TILE_PX_MASK;
            }

            xx = tilemapSeam_x;
            xx++;
            xx++;
            if xx >= tilemapStride {
                xx = 0;
            }
            tilemapSeam_x = xx;

            aa = yy = horizontal_buffer.post_increment_cursor__inline__keep_xx();

            populate_buffer(xx, aa);
        }
    }


    // IN: xx = x-component of sl_tilemap index
    // IN: aa = horizontal cursor byte index
    //
    // DB = 0x7e
    #[mem16, idx16]
    func populate_buffer(sl_tilemap_xComponent : u16 in xx, horizontalCursorIndex : u16 in aa) {
        var _endIndex : u16 in zpTmp_word_0;

        aa >>>= 1;
        if aa & 32 != 0 {
            aa ^= 32 | NAMETABLE_WORD_SIZE;
        }
        vramWordAddr = aa = aa | VRAM_BG2_MAP_WADDR;

        xx = aa = xx + tilemapSeam_y;

        yy = cursorIndex;
        _endIndex = yy;
        do {
            yy--;
            yy--;
            if negative {
                yy = sizeof(typeof(buffer)) - 2;
            }

            buffer[unaligned yy] = aa = sl_tilemap[unaligned xx];

            aa = xx - tilemapStride;
            if !carry {
                // carry clear
                aa +#= tilemapSize;
            }
            xx = aa;
        } while yy != _endIndex;

        aa = 1 << BUFFER_STATE__VERTICAL_BIT;
        test_and_set(*(&bufferState as *u16), aa);
    }


    // KEEP: xx
    // DB = 0x7e
    #[mem16, idx16]
    inline func pre_decrement_cursor__inline__keep_xx() : u16 in aa {
        aa = cursorIndex;
        aa--;
        aa--;
        aa &= CURSOR_INDEX_MASK;
        cursorIndex = aa;

        return aa;
    }


    // KEEP: xx
    // DB = 0x7e
    #[mem16, idx16]
    inline func post_increment_cursor__inline__keep_xx() : u16 in yy {
        aa = cursorIndex;
        yy = aa;

        aa++;
        aa++;
        aa &= CURSOR_INDEX_MASK;
        cursorIndex = aa;

        return yy;
    }
}



namespace horizontal_buffer {
    // Process any changes to `sl_callbacks.yPos_px` and populate the `horizontal_buffer` as required.
    //
    // DB = 0x7e
    #[mem16, idx16]
    inline func update__inline() {
        aa = sl_callbacks.yPos_px - maskedPrevYPos;
        yy = aa;
        if negative {
            viewportYOffset = aa = viewportYOffset - TILE_PX;

            aa = maskedPrevYPos - TILE_PX;
            if negative {
                sl_callbacks.yPos_px = aa = (sl_callbacks.yPos_px & TILE_PX_MASK) + bottom - TILE_PX;
                aa &= POSITION_TILE_MASK;
            }
            maskedPrevYPos = aa;

            if yy < -TILE_PX as u16 {
                // Clamp yPos if yPos has moved more than 1 tile
                sl_callbacks.yPos_px = aa;
            }

            // Assumes tilemapSeam_y is always valid
            aa = tilemapSeam_y;
            if zero {
                aa = tilemapSize;
            }
            aa -= tilemapStride;
            tilemapSeam_y = aa;

            // Move `xx` upwards
            aa = aa - tilemapAboveViewportOffset;
            if negative {
                aa += tilemapSize;
            }
            xx = aa;

            aa = vertical_buffer.pre_decrement_cursor__inline__keep_xx();

            populate_buffer(xx, aa);
        }
        else if aa >= TILE_PX {
            // yy = aa

            viewportYOffset = aa = viewportYOffset + TILE_PX;

            aa = maskedPrevYPos + TILE_PX;
            if aa >= bottom {
                sl_callbacks.yPos_px = aa = sl_callbacks.yPos_px & TILE_PX_MASK;
                aa = 0;
            }
            maskedPrevYPos = aa;

            if yy >= TILE_PX * 2 {
                // Clamp yPos if yPos has moved too more than 1 tile
                sl_callbacks.yPos_px = aa = aa | TILE_PX_MASK;
            }

            aa = tilemapSeam_y + tilemapStride;
            if carry || aa >= tilemapSize {
                aa = 0;
            }
            tilemapSeam_y = aa;
            xx = aa;

            aa = yy = vertical_buffer.post_increment_cursor__inline__keep_xx();

            populate_buffer(xx, aa);
        }
    }


    // IN: xx = y-component of sl_tilemap index
    // IN: aa = vertical cursor byte index
    //
    // DB = 0x7e
    #[mem16, idx16]
    func populate_buffer(sl_tilemap_yComponent: u16 in xx, verticalCursorIndex : u16 in aa) {
        var _rowStartIndex : u16 in zpTmp_word_0;
        var _endIndex      : u16 in zpTmp_word_1;

        // Assumes VRAM_BG2_MAP_WADDR is a multiple of 0x800.
        vramWordAddr1 = aa = (aa <<< 4) | VRAM_BG2_MAP_WADDR;
        vramWordAddr2 = aa = aa | NAMETABLE_WORD_SIZE;

        _rowStartIndex = xx;
        xx = aa = xx + tilemapSeam_x;

        yy = cursorIndex;
        _endIndex = yy;
        do {
            yy--;
            yy--;
            if negative {
                yy = sizeof(typeof(buffer)) - 2;
            }

            buffer[unaligned yy] = aa = sl_tilemap[unaligned xx];

            xx--;
            xx--;
            // cmp works since _rowStartIndex is never negative
            // Required as `xx` might be negative
            cmp(xx, _rowStartIndex);
            if negative {
                xx = aa = xx + tilemapStride;
            }
        } while yy != _endIndex;

        aa = 1 << BUFFER_STATE__HORIZONTAL_BIT;
        test_and_set(*(&bufferState as *u16), aa);
    }


    // KEEP: xx
    // DB = 0x7e
    #[mem16, idx16]
    inline func pre_decrement_cursor__inline__keep_xx() : u16 in aa {
        aa = cursorIndex;
        aa--;
        aa--;
        aa &= CURSOR_INDEX_MASK;
        cursorIndex = aa;

        return aa;
    }


    // KEEP: xx
    // DB = 0x7e
    #[mem16, idx16]
    inline func post_increment_cursor__inline__keep_xx() : u16 in yy {
        aa = cursorIndex;
        yy = aa;

        aa++;
        aa++;
        aa &= CURSOR_INDEX_MASK;
        cursorIndex = aa;

        return yy;
    }
}


namespace part_of_room {
    // ASSUMES: metatiles.transitions.TRANSITION_SPEED == TILE_PX
    let TRANSITION_SPEED = TILE_PX;


    // Calculates the new tilemapSeam for the room and scrollDirection.
    //
    // MUST ONLY be called if `sl_header.partOfRoom` is set.
    //
    // ASSUMES: Room is loaded into memory.
    //
    // DB = 0x7e
    #[mem8, idx8]
    func start_room_transition(scrollDirection : room_transitions.ScrollDirection in x) {
        // ::TODO get x position from room::
        a = 0x50;
        if a >= sl_header.width {
            a = 0;
        }

        // Fixes an off-by-one error
        // (done here to avoid signed numbers in `ScrollDirectionTileSeamOffsets_y`)
        if a == 0 {
            a = sl_header.width;
        }
        a--;

        a += ScrollDirectionTileSeamOffsets_x[x];
        if carry || a >= sl_header.width {
            a -= sl_header.width;
            // wrap a second time as max(ScrollDirectionTileSeamOffsets_x) is 64 and min(sl_header.width) is 32
            if a >= sl_header.width {
                a -= sl_header.width;
            }
        }
        y = a;


        // ::TODO get y position from room::
        a = 0x30;
        if a >= sl_header.height {
            a = 0;
        }

        // Fixes an off-by-one error
        // (done here to avoid signed numbers in `ScrollDirectionTileSeamOffsets_y`)
        if a == 0 {
            a = sl_header.height;
        }
        a--;

        a += ScrollDirectionTileSeamOffsets_y[x];
        if carry || a >= sl_header.height {
            a -= sl_header.height;
        }
        // y = xTilePos
        // a = yTilePos


        *(far &WRMPYA) = a;
        *(far &WRMPYB) = a = sl_header.width;
        // Must wait 8 CPU cycles before reading RDMPY

        mem16();
        #[mem16, idx8] {
            // high byte of yy clear
            tilemapSeam_x = aa = yy <<< 1;
            tilemapSeam_y = aa = *(far &RDMPY) <<< 1;
        }
        mem8_idx8();
    }

    in rodata0 {
        let _N_SCROLL_DIRECTIONS = 8;

        let _HB_WIDTH  = sizeof(typeof(horizontal_buffer.buffer)) / 2;
        let _VB_HEIGHT = sizeof(typeof(vertical_buffer.buffer)) / 2;

        let _DISPLAY_TW = DISPLAY_WIDTH / TILE_PX;
        let _DISPLAY_TH = DISPLAY_HEIGHT / TILE_PX;

        // Tiles before rollback
        let _TBR = room_transitions.N_TRANSITION_FRAMES_BEFORE_SOLID_CHECK;

        // Offset between the room tile position and the tilemap seam tile position.
        //
        // NOTE: tilemapSeam is at the bottom.
        //
        // Order MUST match `room_transitions.ScrollDirection`
        const _ScrollDirectionTileSeamOffsets : [u8 ; _N_SCROLL_DIRECTIONS * 2] = [
            _HB_WIDTH,                          _DISPLAY_TH + 1,    // UP
            _HB_WIDTH,                          0,                  // DOWN
            _HB_WIDTH - _DISPLAY_TW + 1,        _VB_HEIGHT,         // LEFT
            0,                                  _VB_HEIGHT,         // RIGHT

            _HB_WIDTH,                          _TBR + 1,           // ROLLBACK_UP
            _HB_WIDTH,                          _DISPLAY_TH - _TBR, // ROLLBACK_DOWN
            _HB_WIDTH - _DISPLAY_TW - _TBR + 1, _VB_HEIGHT,         // ROLLBACK_LEFT
            _TBR,                               _VB_HEIGHT,         // ROLLBACK_RIGHT
        ];

        let ScrollDirectionTileSeamOffsets_x = ((far &_ScrollDirectionTileSeamOffsets as u24 + 0) as far *u8);
        let ScrollDirectionTileSeamOffsets_y = ((far &_ScrollDirectionTileSeamOffsets as u24 + 1) as far *u8);
    }


    #[mem16, idx16]
    func _update_scroll_shadows() {
        xScrollShadow = aa = vertical_buffer.viewportXOffset;
        yScrollShadow = aa = horizontal_buffer.viewportYOffset;
    }


    // DB = 0x7e
    #[mem16, idx16]
    func scroll_up__process__mem16_idx16() {
        horizontal_buffer.viewportYOffset = aa = horizontal_buffer.viewportYOffset - TILE_PX;
        _update_scroll_shadows();

        aa = tilemapSeam_y - tilemapStride;
        if !carry {
            aa = tilemapSize - tilemapStride;
        }
        tilemapSeam_y = aa;
        xx = aa;

        aa = vertical_buffer.pre_decrement_cursor__inline__keep_xx();

        horizontal_buffer.populate_buffer(xx, aa);
    }


    // DB = 0x7e
    #[mem16, idx16]
    func scroll_down__process__mem16_idx16() {
        horizontal_buffer.viewportYOffset = aa = horizontal_buffer.viewportYOffset + TILE_PX;
        _update_scroll_shadows();

        aa = tilemapSeam_y + tilemapStride;
        if aa >= tilemapSize {
            aa = 0;
        }
        tilemapSeam_y = aa;
        xx = aa;

        aa = yy = vertical_buffer.post_increment_cursor__inline__keep_xx();

        aa = (aa + DISPLAY_HEIGHT / TILE_PX * 2) & vertical_buffer.CURSOR_INDEX_MASK;

        horizontal_buffer.populate_buffer(xx, aa);
    }


    // DB = 0x7e
    #[mem16, idx16]
    func scroll_left__process__mem16_idx16() {
        vertical_buffer.viewportXOffset = aa = vertical_buffer.viewportXOffset - TILE_PX;
        _update_scroll_shadows();

        xx = tilemapSeam_x;
        xx--;
        if negative {
            xx = tilemapStride;
            xx--;
        }
        xx--;
        tilemapSeam_x = xx;

        aa = horizontal_buffer.pre_decrement_cursor__inline__keep_xx();

        vertical_buffer.populate_buffer(xx, aa);
    }


    // DB = 0x7e
    #[mem16, idx16]
    func scroll_right__process__mem16_idx16() {
        vertical_buffer.viewportXOffset = aa = vertical_buffer.viewportXOffset + TILE_PX;
        _update_scroll_shadows();

        xx = tilemapSeam_x;
        xx++;
        xx++;
        if xx >= tilemapStride {
            xx = 0;
        }
        tilemapSeam_x = xx;

        aa = yy = horizontal_buffer.post_increment_cursor__inline__keep_xx();

        // Advance aa to the other nametable.
        aa = aa ^ (DISPLAY_WIDTH / TILE_PX * 2);

        vertical_buffer.populate_buffer(xx, aa);
    }



    let scroll_up__rollback__mem16_idx16    = scroll_down__process__mem16_idx16;
    let scroll_down__rollback__mem16_idx16  = scroll_up__process__mem16_idx16;
    let scroll_left__rollback__mem16_idx16  = scroll_right__process__mem16_idx16;
    let scroll_right__rollback__mem16_idx16 = scroll_left__process__mem16_idx16;
}


}

}

import "../sl-callback-api";
import "gen/function-tables";

