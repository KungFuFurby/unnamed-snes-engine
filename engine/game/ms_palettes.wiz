// Copyright (c) 2024, Marcus Rowe <undisbeliever@gmail.com>.
// Distributed under The MIT License, see the LICENSE file for more details.

import "src/memmap";
import "../registers";

import "../resources/resources";
import "../resources/dma";

import "gen/enums";


namespace ms_palettes {

let MAX_PALETTE_SIZE = 128 * 2;

// Number of MetaSprite Palettes that can be loaded at once
let N_SLOTS = 3;


// MetaSprite Palette data stored in RAM
//
// NOTE: data MUST NOT be modified after the data is loaded into RAM.
struct _RamDataFormat {
    // Number of color used by the MetaSprite Palette
    colorsPerFrame: u8,

    // The CGRAM address (palette index) to store the data to
    cgramAddr: u8,

    // Integer id of the parent `ms_palette` to load after this one
    // CAUTION: A maximum of `N_SLOTS` nested `ms_palette`s are allowed at once
    parent: u8,

    // Palette data
    // NOTE: palette_data may be smaller then `MAX_PALETTE_SIZE`
    colors: [u16 ; MAX_PALETTE_SIZE],
}


in lowram {
    let __STATE_START_ADDR = &lastSlotIndex as u16;

    // The index of the last slot
    // MUST BE < (N_SLOTS - 1) * 2.
    // MUST BE even
    // (using u16 so it can be read in Vblank routine)
    var lastSlotIndex: u16;


    namespace PaletteSoA {
        let BA_SIZE = N_SLOTS * 2 - 1;

        var _dirtyFlagAndBlank : [u16 ; N_SLOTS];
            var dirtyFlag @ &<:_dirtyFlagAndBlank[0] : [u8 ; BA_SIZE];

        var _colorsPerFrameAndCgramAddr : [u16 ; N_SLOTS];
            var colorsPerFrame @ &<:_colorsPerFrameAndCgramAddr[0] : [u8 ; BA_SIZE];
            var cgramAddr      @ &>:_colorsPerFrameAndCgramAddr[0] : [u8 ; BA_SIZE];

        var colorData : [u16 ; N_SLOTS];

        var transferSize : [u16 ; N_SLOTS];
    }

    var padding : u8;
    let __STATE_SIZE = (&padding as u16) - __STATE_START_ADDR;
}

in rodata0 {
    namespace PaletteSoA {
        const __PalDataIndex : [u16 ; N_SLOTS] = [
            sizeof(_RamDataFormat) * i
            for let i in 0..(N_SLOTS - 1)
        ];
        let PalDataIndex = far &__PalDataIndex as far *u16;

        const __ColorDataAddr : [u16 ; N_SLOTS] = [
            &pal_data as u16 + sizeof(_RamDataFormat) * i + offsetof(_RamDataFormat, colors)
            for let i in 0..(N_SLOTS - 1)
        ];
        let ColorDataAddr = far &__ColorDataAddr as far *u16;
    }
}


in wram7e {
    var __far_pal_data : [_RamDataFormat; N_SLOTS];
        // second-layer data is constant after it has been loaded and initialised
        const pal_data @ &__far_pal_data : [_RamDataFormat ; N_SLOTS];
}


in code {


// REQUIRES: VBlank or Force-Blank
// Uses DMA channel 0
//
// DB = 0x80
#[mem8, idx16]
inline func update_cgram__vblank() {
    xx = lastSlotIndex;

    dma.set_dmap0_and_bbad0__yy(DMAP_TO_PPU | DMAP_TRANSFER_ONE, <:&CGDATA);
    A1B0 = a = 0x7e;

    do {
        a = PaletteSoA.dirtyFlag[unaligned xx];
        if !zero {
            PaletteSoA.dirtyFlag[xx] = 0;

            CGADD = a = PaletteSoA.cgramAddr[unaligned xx];

            A1T0 = yy = PaletteSoA.colorData[unaligned xx];
            DAS0 = yy = PaletteSoA.transferSize[unaligned xx];

            MDMAEN = a = MDMAEN_DMA0;
        }
        xx--;
        xx--;
    } while !negative;
}


// REQUIRES: Force-Blank
// Uses DMA Channel 0
// DB = 0x80
#[mem8, idx16]
func load_ms_palette(palette_id: u8 in a) {
    dma.clear_wram7e__forceblank(__STATE_START_ADDR, __STATE_SIZE);

    __load_ms_palette_data(a);

    push16(0x807e);
    data_bank = pop8();
// DB = 0x7e

    push8(p);
    mem16();
    #[mem16]
    {
        xx = aa = *(&lastSlotIndex as *u16) & 0xff;

        do {
            yy = aa = PaletteSoA.PalDataIndex[unaligned xx];

            aa = (&pal_data[0].colorsPerFrame as *u16)[unaligned yy];
            push16(aa);

            PaletteSoA._colorsPerFrameAndCgramAddr[unaligned xx] = aa = aa | 0x8000;

            aa = pop16();
            PaletteSoA.transferSize[unaligned xx] = aa = (aa & 0xff) <<< 1;

            PaletteSoA.colorData[unaligned xx] = aa = PaletteSoA.ColorDataAddr[unaligned xx];

            PaletteSoA._dirtyFlagAndBlank[unaligned xx] = aa = 0xffff;

            // CGRAM data is transferred during VBlank

            xx--;
            xx--;
        } while !negative;
    }
    p = pop8();

    data_bank = pop8();
// DB = 0x80
}


// Load a MetaSprite Palette into memory
//
// REQUIRES: Force-Blank
// Uses DMA Channel 0
// DB = 0x80
#[mem8, idx16]
func __load_ms_palette_data(palette_id : u8 in a) {
    *(&lastSlotIndex as *u8) = 0;

    resources.load_resource__dynamic_ram_no_ppu_data__forceblank_inline(
        resources.ResourceType.ms_palette, a, &pal_data[0] as *u8, sizeof(_RamDataFormat));

    inline for let i in 1..(N_SLOTS - 1) {
        // ::HACK to read `pal_data[i-1].parent` with long addressing::
        a = *((far &__far_pal_data as u24 + sizeof(_RamDataFormat) * (i - 1) + offsetof(_RamDataFormat, parent)) as far *u8);
        goto Return if a == 0xff;

        (*(&lastSlotIndex as *u8))++;

        resources.load_resource__dynamic_ram_no_ppu_data__forceblank_inline(
            resources.ResourceType.ms_palette, a, &pal_data[i] as *u8, sizeof(_RamDataFormat));
    }

Return:

    *(&lastSlotIndex as *u8) <<<= 1;
}

}

}

