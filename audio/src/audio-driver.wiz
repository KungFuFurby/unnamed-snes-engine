// Copyright (c) 2023, Marcus Rowe <undisbeliever@gmail.com>.
// Distributed under The MIT License, see the LICENSE file for more details.


import "registers";


// Memory Map
// ==========

config {
    trim = true
}

bank zeropage       @ 0x0000 : [vardata;     0x00f0];
// addresses 0x00f0 - 0x00ff contain registers
bank stack          @ 0x0100 : [vardata;     0x0100];
bank code           @ 0x0200 : [constdata;   0x0400];

let EXTERNAL_DATA_ADDR = 0x600;


// Data Structures
// ===============


let TIMER_DIVIDER = 16;
let TICKS_PER_SECOND = 8000 / TIMER_DIVIDER;


let N_CHANNELS = 8;
let N_MUSIC_CHANNELS = 6;
let N_SFX_CHANNELS = N_CHANNELS = N_MUSIC_CHANNELS;

let N_BRR_SAMPLES   = 64;
let N_INSTRUMENTS   = 64;
let N_SOUND_EFFECTS = 128;


let INSTRUMENT_MASK = N_INSTRUMENTS - 1;


// Number of clock ticks after a KOFF event before the bytecode is processed.
//
// This delay MUST be > 64 8Khz timer ticks to ensure the Key-Off event completely silences
// the sample before the next note plays.
//
// ::TODO somehow confirm this value is large enough to ensure all KOFF events always occur 256 samples before KON events::
let KEY_OFF_DELAY = (64 + 48) / TIMER_DIVIDER;


let STARTING_OCTAVE = 3;
let STARTING_DEFAULT_NOTE_LENGTH = 64 / 4;


struct DirItem {
    start : *const u8,
    loop  : *const u8
};

struct InstrumentsSoA {
    scrn            : [u8 ; N_INSTRUMENTS],
    adsr1           : [u8 ; N_INSTRUMENTS],
    adsr2           : [u8 ; N_INSTRUMENTS],
    gain            : [u8 ; N_INSTRUMENTS],

    // offset between note c0 and `ExternalData.pitchTable[0]`
    // (pitchOffset + note is allowed to overflow and underflow)
    pitchOffset    : [u8 ; N_INSTRUMENTS],
};

struct ExternalData {
    brrDirectory   : [DirItem ; N_BRR_SAMPLES],

    pitchTable_l   : [u8; 256],
    pitchTable_h   : [u8; 256],

    instruments    : InstrumentsSoA,
};


struct MusicChannelHeader {
    // The starting offset of the channel bytecode (relative to the start of the song data).
    //
    // If `starting+SongData` overflows (ie, starting >= 0xff00), then the channel is disabled.
    starting : u16,

    // The loop point in the channel bytecode (relative to the start of the song data).
    //
    // If `loop+SongData` overflows (ie, loop >= 0xff00), then the channel will not loop.
    loop: u16,
};

struct SongHeader {
    channels : [MusicChannelHeader ; N_MUSIC_CHANNELS],

    // Starting tempo.
    // (Q8.8)
    tempo   : u16,

    // Number of subroutines
    // NOTE: This variable has a maximum value of 128
    nSubroutines : u8,

    // Immediately after this header is an array, [u16 ; nSubroutines], containing the location of each subroutine
    // (relative to the start of the song data).
    // The audio-engine will convert the locations into addresses before starting the event-loop.
};

extern const external_data @ EXTERNAL_DATA_ADDR : ExternalData;


bank data @ EXTERNAL_DATA_ADDR : [constdata; 0x8000];

in data {
    const __external_data = embed "../gen/common_data.bin";
}



// Variables
// =========


in zeropage {
    // Temporary variables
    var zpTmp : u8;
    var zpTmpPtr : *u8;

    // The table of subroutine addresses
    var subroutineTable : **const u8;


    // Incremented once every tick (1/8000 seconds)
    var tickClock : u16;

    // Maximum value of the timer counter0 register.
    var maxTimerCounter : u8;


    // Shadow variables for KON and KOFF DSP registers
    var keyOffShadow : u8;
    var keyOnShadow : u8;


    // Only valid inside bytecode instructions
    var instructionPtr : *const u8;

    // Index into channelSoA for the current channel.
    // Used to restore X index inside bytecode instructions.
    // Only valid inside bytecode instructions
    // MUST ONLY be set by `process_bytecode__inline()`.
    var currentChannelIndex : u8;


    namespace channelSoA {
        // The time of the next event
        // (Q16.8 fixed point)
        var nextEvent_f : [u8 ; N_CHANNELS];
        var nextEvent_l : [u8 ; N_CHANNELS];
        var nextEvent_h : [u8 ; N_CHANNELS];

        // Number of ticks (1/8000 seconds) per 1/64 beat.
        // (Q8.8 fixed point)
        var tempo_f : [u8 ; N_CHANNELS];
        var tempo_l : [u8 ; N_CHANNELS];

        // Default note length (in 64ths)
        var defaultNoteLength : [u8 ; N_CHANNELS];

        // if non-zero: The next play_note is a slur
        // ::BUGFIX have to use a byte-flag for each channel as `test_and_set()` and `test_and_clear()` cause a segmentation fault in wiz::
        var slurNextNote : [u8 ; N_CHANNELS];

        // If non-zero, the next event is a key-off event
        // If zero, the next event will process bytecode
        var nextEventIsKeyOff : [u8 ; N_CHANNELS];


        // The address of the next bytecode to execute
        var instructionPtr_l : [u8 ; N_CHANNELS];
        var instructionPtr_h : [u8 ; N_CHANNELS];

        // Bytecode address to loop to when the channel encounters and `end` instruction.
        // If `instructionPtrAfterEnd_h` is 0, the channel does not loop and will instead stop.
        var instructionPtrAfterEnd_l : [u8 ; N_CHANNELS];
        var instructionPtrAfterEnd_h : [u8 ; N_CHANNELS];


        // Address to return to in a `return_from_subroutine` bytecode
        var returnInstPtr_l : [u8 ; N_CHANNELS];
        var returnInstPtr_h : [u8 ; N_CHANNELS];


        struct LoopState {
            counter : [u8 ; N_CHANNELS],

            // Instruction pointer at the start of the loop.
            loopPoint_l : [u8 ; N_CHANNELS],
            loopPoint_h : [u8 ; N_CHANNELS],
        };
        var loopState : [LoopState ; 2];


        // NOTE: Pitch table variable MUST NOT be modified directly.
        // Use the `__set_pt_offset()` and `__add_to_pt_offset()` to edit the offset variables.

        // Offset between the `u4` note to play and the pitch table.
        //
        // Equal to `instPitchOffset + octaveOffset + transposeOffset` (wrapping on overflow).
        //
        // NOTE: Adding `pitchTableOffset` to the note to play is allowed to an can overflow.
        var pitchTableOffset : [u8 ; N_CHANNELS];

        // Offset between the note to play and the pitch table.
        //
        // NOTE: Adding `instPitchOffset` to the note to play is allowed to an can overflow.
        var instPitchOffset : [u8 ; N_CHANNELS];

        // Offset (in semitones) between the note to play and the current octave.
        //
        // Equal to `octave * 12`
        var octaveOffset : [u8 ; N_CHANNELS];

        // Offset (in semitones) to add to the current note.
        //
        // NOTE: This is a `i8` variable.
        // Using u8 here so I can use this variable with `__set_pt_offset()` and `__add_to_pt_offset().
        var semitoneOffset : [u8 ; N_CHANNELS];
    }
}



// Macros
// ======

// KEEP: a, x, y
inline func write_dsp(addr : GlobalDspAddr in a, data : u8 in y) {
    smp.dsp_addr_and_data = ya;
}



// Set a semitone offset variable and update the pitchTableOffset.
//
// KEEP: X
//
// MUST NOT USE `zpTmp` or `zpTmpPtr`
inline func __set_pt_offset(channelIndex : u8 in x, st_offset : u8 in a, let SOA_VAR : [u8 ; N_CHANNELS]) {
    y = a;

    channelSoA.pitchTableOffset[x] = a = a + channelSoA.pitchTableOffset[x] - SOA_VAR[x];
    SOA_VAR[x] = y;
}



// Add an `i8` semitone offset to an offset variable and the pitchTableOffset.
//
// KEEP: X
inline func __add_to_pt_offset(channelIndex : u8 in x, st_offset : i8 in a, let SOA_VAR : [u8 ; N_CHANNELS]) {
    y = a;

    channelSoA.pitchTableOffset[x] = a = a + channelSoA.pitchTableOffset[x];

    SOA_VAR[x] = a = y + SOA_VAR[x];
}



// Code
// ====

in code {

// MUST be the first thing in the `code` bank (so the starting address is consistent across builds).
func main() {
var _songPtr : *const u8 in zpTmpPtr;
var _loopEnd : u8 in zpTmp;


    sp = x = 0xff;

    // Reset the DSP
    write_dsp(GlobalDspAddr.FLG,    dsp.FLG__SOFT_RESET | dsp.FLG__MUTE_ALL | dsp.FLG__ECHO_DISABLE);

    write_dsp(GlobalDspAddr.KOFF,   0xff);  // all keys off

    y = 0;
    write_dsp(GlobalDspAddr.EFB,    y);     // No echo feedback
    write_dsp(GlobalDspAddr.PMON,   y);     // No pitch modulation
    write_dsp(GlobalDspAddr.NON,    y);     // No noise
    write_dsp(GlobalDspAddr.EON,    y);     // No echo


    // Set main volume to full volume
    y = 0x7f;
    write_dsp(GlobalDspAddr.MVOL_L, y);
    write_dsp(GlobalDspAddr.MVOL_R, y);

    y = 0;
    write_dsp(GlobalDspAddr.EVOL_L, y);
    write_dsp(GlobalDspAddr.EVOL_R, y);



    // Set directory table
    write_dsp(GlobalDspAddr.DIR, >:&external_data.brrDirectory[0]);


    // Unmute the audio (keep echo disabled)
    write_dsp(GlobalDspAddr.FLG,    dsp.FLG__ECHO_DISABLE);


    // Clear zero-page variables
    a = 0;
    x = 0xf0;
    do {
        x--;
        (0 as *u8)[x] = a;
    } while !zero;


    // Disable SFX channels
    a = <:&ChannelDisabledBytecode;
    y = >:&ChannelDisabledBytecode;
    inline for let i in N_MUSIC_CHANNELS..7 {
        channelSoA.instructionPtr_l[i] = a;
        channelSoA.instructionPtr_h[i] = y;
    }


    // Retrieve the address of the song header
    a = <:&SongData;
    y = >:&SongData;
    _songPtr = ya as *u8;


    // Calculate the subroutineTable address.
    a = sizeof(SongHeader);
    y = 0;
    ya += _songPtr as u16;
    subroutineTable = ya as **const u8;

    // Add _songPtr to each element in the subroutine table, turning an offset into an address.
    y = offsetof(SongHeader, nSubroutines);
    a = _songPtr[y];
    if !zero {
        _loopEnd = a = a << 1;
        y = 0;
        do {
            (subroutineTable as *u8)[y] = a = (subroutineTable as *u8)[y] + <:_songPtr;
            y++;
            (subroutineTable as *u8)[y] = a = (subroutineTable as *u8)[y] +# >:_songPtr;
            y++;
        } while y != _loopEnd;
    }


    // Reset all music channels
    x = N_MUSIC_CHANNELS - 1;
    do {
        // These variables MUST be set before set_instrument
        a = STARTING_OCTAVE * 12;
        channelSoA.octaveOffset[x] = a;
        channelSoA.pitchTableOffset[x] = a;

        bytecode.set_channel_volume(x, 96);
        bytecode.set_instrument(x, 0);

        channelSoA.defaultNoteLength[x] = a = STARTING_DEFAULT_NOTE_LENGTH;

        y = offsetof(SongHeader, tempo);
        channelSoA.tempo_f[x] = a = _songPtr[y];
        y++;
        channelSoA.tempo_l[x] = a = _songPtr[y];


        // ASSUMES offsetof(SongHeader, channels) == 0
        // ASSUMES sizeof(MusicChannelHeader) == 4
        y = a = x <<< 2;

        // Calculate instructionPtr (and setting it to `ChannelDisabledBytecode` if the addition overflows)
        channelSoA.instructionPtr_l[x] = a = _songPtr[y] + <:_songPtr;
        y++;
        a = _songPtr[y] +# >:_songPtr;
        if carry {
            channelSoA.instructionPtr_l[x] = a = <:&ChannelDisabledBytecode;
            a = >:&ChannelDisabledBytecode;
        }
        channelSoA.instructionPtr_h[x] = a;
        y++;

        // Calculate endInstPtr (and set the high byte to 0 (no looping) if the addition overflows)
        channelSoA.instructionPtrAfterEnd_l[x] = a = _songPtr[y] + <:_songPtr;
        y++;
        a = _songPtr[y] +# >:_songPtr;
        if carry {
            a = 0;
        }
        channelSoA.instructionPtrAfterEnd_h[x] = a;


        // Set nextEvent to 0x8080 to test `__rewind_tick_clock()`
        a = 0x80;
        channelSoA.nextEvent_l[x] = a;
        channelSoA.nextEvent_h[x] = a;

        x--;
    } while !negative;


    // Set nextEvent to 0x8080 to test `__rewind_tick_clock()`
    a = 0x80;
    <:tickClock = a;
    >:tickClock = a;


    // Setup and enable the timer
    smp.timer_0 = a = TIMER_DIVIDER;
    smp.control = a = smp.CONTROL__ENABLE_TIMER_0;
    a = smp.counter_0;

    return process_event_loop();
}



#[fallthrough]
func process_event_loop() {
    ^while true {
        write_dsp(GlobalDspAddr.KOFF,   keyOffShadow);
        write_dsp(GlobalDspAddr.KON,    keyOnShadow);

        a = 0;
        keyOffShadow = a;
        keyOnShadow = a;


        x = N_CHANNELS - 1;
        do {
            process_channel__inline(x);

            x--;
        } while !negative;


        // Wait until the timer counter has incremented
        // ::TODO confirm `counter_0` with never overflow
        do {
            a = smp.counter_0;
        } while zero;

        if a >= maxTimerCounter {
            maxTimerCounter = a;
        }

        <:tickClock = a = a + <:tickClock;
        if carry {
            (>:tickClock)++;
            goto __rewind_tick_clock if negative;
        }
    }
}



// To prevent the tick clock from overflowing it needs to be rewound regularly.
//
// This function will rewind the clock and all events by 0x7f00 ticks.
//
// MUST be called when `tickClock >= 0x8000`
#[fallthrough]
func __rewind_tick_clock() {
    >:tickClock = a = >:tickClock - 0x7f;
    x = N_CHANNELS - 1;
    do {
        channelSoA.nextEvent_h[x] = a = channelSoA.nextEvent_h[x] - 0x7f;
        x--;
    } while !negative;

    ^goto process_event_loop;
}


func delay() {
    y = 0;
    do {
        y--;
    } while !zero;
}


// KEEP: X
inline func process_channel__inline(channelIndex : u8 in x) {
    a = channelSoA.nextEvent_l[x];
    y = channelSoA.nextEvent_h[x];

    if ya < tickClock {
        // Check if a KEY_OFF is required
        a = channelSoA.nextEventIsKeyOff[x];
        if !zero {
            // ::BUGFIX `test_and_set(a, keyOffShadow);` causes a wiz Segmentation fault::
            keyOffShadow = a = keyOffShadow | ChannelVoiceBit[x];

            // schedule a bytecode event
            channelSoA.nextEventIsKeyOff[x] = a = 0;
            increment_next_event__fixed_u8__inline(x, KEY_OFF_DELAY);
        }
        else {
            process_bytecode__inline(x);
        }
    }
}



// KEEP: X
inline func process_bytecode__inline(channelIndex : u8 in x) {

    currentChannelIndex = x;

    a = channelSoA.instructionPtr_l[x];
    y = channelSoA.instructionPtr_h[x];
    instructionPtr = ya as *const u8;

    do {
        y = 0;
        a = instructionPtr[y];
        instructionPtr++;

        if a < sizeof(typeof(bytecode.ByteInstructions_l)) {
            y = a;
            // Set address of the instruction using self-modifying code
            // (If I used the `JMP [!abs+X]` it would have clobbered `X` and cost be ~80 bytes to do a `x = _currentChannelIndex` on every instruction).
            (&CallInstruction as *u8)[1] = a = bytecode.ByteInstructions_l[y];
            (&CallInstruction as *u8)[2] = a = bytecode.ByteInstructions_h[y];

            if y < bytecode.N_SINGLE_ARGUMENT_INSTRUCTIONS {
                // Instruction has a parameter
                y = 0;
                a = instructionPtr[y];
                instructionPtr++;
            }
        }
        else {
            x = a;

            a &= 0b11100000;
            swap_digits(a);
            y = a;

            // Y = instruction_index * 2

            // Set address of the instruction using self-modifying code
            (&CallInstruction as *u8)[1] = a = (&<:bytecode.InlineArgumentInstructions[0] as *const u8)[unaligned y];
            (&CallInstruction as *u8)[2] = a = (&>:bytecode.InlineArgumentInstructions[0] as *const u8)[unaligned y];

            a = x & bytecode.INLINE_ARGUMENT_MASK;
            x = currentChannelIndex;
        }

    CallInstruction:
        carry = bytecode.null_instruction(x, a);
        // carry set if there are more instructions to process
    } while !carry;

    x = currentChannelIndex;

    ya = instructionPtr as u16;
    channelSoA.instructionPtr_l[x] = a;
    channelSoA.instructionPtr_h[x] = y;
}



// KEEP: X
inline func increment_next_event__fixed_u8__inline(channelIndex : u8 in x, let TICKS : u8) {
    // Do not update fractional bits

    channelSoA.nextEvent_l[x] = a = channelSoA.nextEvent_l[x] + TICKS;
    if carry {
        channelSoA.nextEvent_h[x]++;
    }
}



// NOTE: BYTECODE INSTRUCTIONS MUST KEEP X
namespace bytecode {

const ByteInstructions_l : [ u8 ; 1 << 5 ] = [ <:&f for let f in SINGLE_ARGUMENT_INSTRUCTIONS ]
                                           ~ [ <:&f for let f in NO_PARAMETER_INSTRUCTIONS ];

const ByteInstructions_h : [ u8 ; 1 << 5 ] = [ >:&f for let f in SINGLE_ARGUMENT_INSTRUCTIONS ]
                                           ~ [ >:&f for let f in NO_PARAMETER_INSTRUCTIONS ];

const InlineArgumentInstructions : [ func(u8 in x, u8 in y) : bool in carry ; 1 << 3 ] = INLINE_ARGUMENT_INSTRUCTIONS;



func null_instruction(channelIndex : u8 in x, note : u8 in a) : bool in carry {
    return disable_channel(x);
}



// KEEP: X
func disable_channel(channelIndex : u8 in x) : bool in carry {
    // Set the nextEvent clock to the highest it can go
    a = 0xff;
    channelSoA.nextEvent_l[x] = a;
    channelSoA.nextEvent_h[x] = a;

    a = <:&ChannelDisabledBytecode;
    y = >:&ChannelDisabledBytecode;
    instructionPtr = ya as *const u8;

    // return true (do not execute the next bytecode and sleep)
    return true;
}


// KEEP: X
func end(channelIndex : u8 in x) : bool in carry {
    y = channelSoA.instructionPtrAfterEnd_h[x];
    goto disable_channel if zero;

    a = channelSoA.instructionPtrAfterEnd_l[x];

    instructionPtr = ya as *const u8;

    return false;
}


// KEEP: X
func call_subroutine(channelIndex : u8 in x, subroutineId : u8 in a) : bool in carry {
var _subroutineId : u8 in zpTmp;

    _subroutineId = a;

    // Save return address
    ya = instructionPtr as u16;
    channelSoA.returnInstPtr_l[x] = a;
    channelSoA.returnInstPtr_h[x] = y;

    y = a = _subroutineId <<< 1;

    <:instructionPtr = a = (subroutineTable as *u8)[y];
    y++;
    >:instructionPtr = a = (subroutineTable as *u8)[y];

    return false;
}


// KEEP: X
func return_from_subroutine(channelIndex : u8 in x) : bool in carry {
    a = channelSoA.returnInstPtr_l[x];
    y = channelSoA.returnInstPtr_h[x];
    instructionPtr = ya as *const u8;

    return false;
}


// KEEP: X
inline func __start_loop(channelIndex : u8 in x, let LOOP_ID : u8) : bool in carry {
    ya = instructionPtr as u16;

    channelSoA.loopState[LOOP_ID].loopPoint_l[x] = a;
    channelSoA.loopState[LOOP_ID].loopPoint_h[x] = y;

    channelSoA.loopState[LOOP_ID].counter[x] = a = 0;

    return false;
}


// KEEP: X
inline func __end_loop(channelIndex : u8 in x, loopCount : u8 in a, let LOOP_ID : u8) : bool in carry {
    if a >= channelSoA.loopState[LOOP_ID].counter[x] {
        channelSoA.loopState[LOOP_ID].counter[x]++;

        a = channelSoA.loopState[LOOP_ID].loopPoint_l[x];
        y = channelSoA.loopState[LOOP_ID].loopPoint_h[x];
        instructionPtr = ya as *const u8;

        carry = false;
    }
    // carry false if `a < loopState`
    // return false
    return carry;
}


// KEEP: X
func start_loop_0(channelIndex : u8 in x) : bool in carry {
    return __start_loop(x, 0);
}

// KEEP: X
func start_loop_1(channelIndex : u8 in x) : bool in carry {
    return __start_loop(x, 1);
}


// KEEP: X
func end_loop_0(channelIndex : u8 in x, loopCount : u8 in a) : bool in carry {
    return __end_loop(x, a, 0);
}

// KEEP: X
func end_loop_1(channelIndex : u8 in x, loopCount : u8 in a) : bool in carry {
    return __end_loop(x, a, 1);
}



// KEEP: X
// MUST NOT USE `currentChannelIndex`
// MUST NOT USE `zpTmp` or `zpTmpPtr`
func set_instrument(channelIndex : u8 in x, instrumentId : u8 in a) : bool in carry {
    // Using addr,y addressing mode for `channels`, 1 cycle faster then transferring y to x.

    y = a = a & INSTRUMENT_MASK;

    smp.dsp_addr = a = ChannelVoiceOffset[x] | VoiceDspAddr.SCRN as u8;
    smp.dsp_data = a = external_data.instruments.scrn[y];

    smp.dsp_addr++;
    smp.dsp_data = a = external_data.instruments.adsr1[y];

    smp.dsp_addr++;
    smp.dsp_data = a = external_data.instruments.adsr2[y];

    smp.dsp_addr++;
    smp.dsp_data = a = external_data.instruments.gain[y];

    a = external_data.instruments.pitchOffset[y];
    __set_pt_offset(x, a, channelSoA.instPitchOffset);

    return false;
}



// ASSUMES: parameter is 5 bits
// KEEP: X
func change_octave(channelIndex : u8 in x, parameter : u8 in a) : bool in carry {
    y = a = a >>>= 1;
    if carry {
        // relative octave change

        a = OctaveTable[y] as u8;
        __add_to_pt_offset(x, a as i8, channelSoA.octaveOffset);

        return false;
    }
    else {
        // Set octave

        a = OctaveTable[y] as u8;
        __set_pt_offset(x, a, channelSoA.octaveOffset);

        return false;
    }
}

const OctaveTable : [i8 ; 16] = [i * 12 for let i in -6..9];



// KEEP: X
func set_semitone_offset(channelIndex : u8 in x, parameter : i8 in a) : bool in carry {
    __set_pt_offset(x, a, channelSoA.semitoneOffset);

    return false;
}



// KEEP: X
func relative_semitone_offset(channelIndex : u8 in x, parameter : i8 in a) : bool in carry {
    __add_to_pt_offset(x, a as i8, channelSoA.semitoneOffset);

    return false;
}



// KEEP: X
// MUST NOT USE `currentChannelIndex`
// MUST NOT USE `zpTmp` or `zpTmpPtr`
func set_channel_volume(channelIndex : u8 in x, volume : u8 in a) : bool in carry {
    y = a;

    // ASSUMES VoiceDspAddr.VOL_L == 0
    smp.dsp_addr = a = ChannelVoiceOffset[x];
    smp.dsp_data = y;

    smp.dsp_addr++;
    smp.dsp_data = y;

    return false;
}



// KEEP: x
func play_note(channelIndex : u8 in x, note : u8 in a) : bool in carry {
    zpTmp = a;

    // Set note pitch
    a &= 0xf;
    y = a = a + channelSoA.pitchTableOffset[x];

    smp.dsp_addr = a = ChannelVoiceOffset[x] | VoiceDspAddr.PITCH_L as u8;
    smp.dsp_data = a = external_data.pitchTable_l[y];

    smp.dsp_addr++;
    smp.dsp_data = a = external_data.pitchTable_h[y];


    // Only set `KON` if `slurNextNote` is false.
    y = channelSoA.slurNextNote[x];
    if zero {
        // queue KON
        // ::BUGFIX `test_and_set(a, keyOnShadow);` causes a wiz Segmentation fault::
        keyOnShadow = a = keyOnShadow | ChannelVoiceBit[x];
    }
    else {
        // No not slur the next note
        channelSoA.slurNextNote[x] = a = 0;
    }


    carry = zpTmp $ 4;
    if !carry {
        a = channelSoA.defaultNoteLength[x];
    }
    else {
        // Get note length from the next byte in the instructionPtr
        y = 0;
        a = instructionPtr[y];
        instructionPtr++;
    }

    return _rest_with_keyoff__inline(x, a);
}



// KEEP: x
func play_note_slur_next(channelIndex : u8 in x, note : u8 in a) : bool in carry {
    zpTmp = a;

    // Set note pitch
    a &= 0xf;
    y = a = a + channelSoA.pitchTableOffset[x];

    smp.dsp_addr = a = ChannelVoiceOffset[x] | VoiceDspAddr.PITCH_L as u8;
    smp.dsp_data = a = external_data.pitchTable_l[y];

    smp.dsp_addr++;
    smp.dsp_data = a = external_data.pitchTable_h[y];


    // Only set `KON` if `slurNextNote` is false.
    y = channelSoA.slurNextNote[x];
    if zero {
        // queue KON
        // ::BUGFIX `test_and_set(a, keyOnShadow);` causes a wiz Segmentation fault::
        keyOnShadow = a = keyOnShadow | ChannelVoiceBit[x];

        // Slur the next note
        // A is non-zero
        channelSoA.slurNextNote[x] = a;
    }


    carry = zpTmp $ 4;
    if !carry {
        a = channelSoA.defaultNoteLength[x];

        return rest(x, a);
    }
    else {
        // Get note length from the next byte in the instructionPtr
        y = 0;
        a = instructionPtr[y];
        instructionPtr++;

        return rest(x, a);
    }
}



// NOTE: Always returns true
// KEEP: x
func rest(channelIndex : u8 in x, length: u8 in a) : bool in carry {
var _tmp : u8 in zpTmp;

    // No need to zero `nextEventIsKeyOff` it is cleared by `process_bytecode__inline()`.

    // Calculate number of ticks to sleep
    // (Q16.8)nextEvent += (Q8.8)tempo * (Q8.0)note

    _tmp = a;

    y = channelSoA.tempo_f[x];
    ya = __multiply(y, a);

    channelSoA.nextEvent_f[x] = a = a + channelSoA.nextEvent_f[x];
    channelSoA.nextEvent_l[x] = a = y +# channelSoA.nextEvent_l[x];
    if carry {
        channelSoA.nextEvent_h[x]++;
    }

    a = _tmp;
    y = channelSoA.tempo_l[x];
    ya = __multiply(y, a);

    channelSoA.nextEvent_l[x] = a = a + channelSoA.nextEvent_l[x];
    channelSoA.nextEvent_h[x] = a = y +# channelSoA.nextEvent_h[x];

    // return true (do not execute the next bytecode and sleep)
    return true;
}



// NOTE: Always returns true
// KEEP: x
inline func _rest_with_keyoff__inline(channelIndex : u8 in x, length: u8 in a) : bool in carry {
var _tmp : u8 in zpTmp;

    _tmp = a;

    channelSoA.nextEventIsKeyOff[x] = y = 1;

    // Calculate number of ticks to sleep
    // (Q16.8)nextEvent += (Q8.8)tempo * (Q8.0)note - KEY_OFF_DELAY

    y = channelSoA.tempo_f[x];
    ya = __multiply(y, a);

    channelSoA.nextEvent_f[x] = a = a + channelSoA.nextEvent_f[x];
    channelSoA.nextEvent_l[x] = a = y +# channelSoA.nextEvent_l[x];
    if carry {
        channelSoA.nextEvent_h[x]++;
    }

    a = _tmp;
    y = channelSoA.tempo_l[x];
    ya = __multiply(y, a);

    // Subtract `KEY_OFF_DELAY`
    a -= KEY_OFF_DELAY;
    if !carry {
        y--;
    }

    channelSoA.nextEvent_l[x] = a = a + channelSoA.nextEvent_l[x];
    channelSoA.nextEvent_h[x] = a = y +# channelSoA.nextEvent_h[x];

    // return true (do not execute the next bytecode and sleep)
    return true;
}



// ::BUGFIX wiz cannot compile `ya = y * a`::
// ::: wiz outputs error: left-hand side of type `u16` cannot be assigned `u8` expression ::
//
// KEEP: x
inline func __multiply(v1 : u8 in y, v2 : u8 in a) : u16 in ya {
    return y * a;
}

}

}



// Data Tables
// ===========

// Using the `code` bank so the data is included in `audio-driver.bin`
in code {
    // The bit used for global DSP registers (KON, KOFF, NON, EON, etc)
    const ChannelVoiceBit : [u8; 8] = [1 << i for let i in 0..7];

    // The offset into the Voice DSP registers
    const ChannelVoiceOffset : [u8; 8] = [i * 0x10 for let i in 0..7];


    // This is the bytecode used by a disabled channel.
    const ChannelDisabledBytecode : [ u8; 1 ] = [ bytecode.DISABLE_CHANNEL_BYTECODE ];
}


in data {
    let UNUSED_CHANNEL = MusicChannelHeader{starting=0xffff, loop=0xffff};
    let STARTING_BPM = 120;

    const SongData = SongHeader{
        channels = [
            UNUSED_CHANNEL,
            UNUSED_CHANNEL,
            UNUSED_CHANNEL,
            MusicChannelHeader{
                starting = EXAMPLE_SONG_OFFSET,
                loop = EXAMPLE_SONG_OFFSET,
            },
            UNUSED_CHANNEL,
            UNUSED_CHANNEL,
        ],

        tempo = (TICKS_PER_SECOND * 60 * 0x100) / (STARTING_BPM * 64),
        nSubroutines = 1,
    };

    const SongSubroutineTable : [ u16 ; 1] = [ &ExampleSubroutine as u16 - &SongData as u16 ];


    let EXAMPLE_SONG_OFFSET = sizeof(SongHeader) + sizeof(typeof(SongSubroutineTable));


    let _REST = 2;
    let _CALL = _REST + 1;
    let _END_LOOP_0 = _CALL + 1;
    let _END_LOOP_1 = _END_LOOP_0 + 1;

    let _SET_SEMITONE_OFFSET =  _END_LOOP_1 + 1;
    let _RELATIVE_SEMITONE_OFFSET = _SET_SEMITONE_OFFSET + 1;


    let _DISABLE_CHANNEL = bytecode.N_SINGLE_ARGUMENT_INSTRUCTIONS;
    let _END = _DISABLE_CHANNEL + 1;
    let _RTS = _END + 1;
    let _START_LOOP_0 = _RTS + 1;
    let _START_LOOP_1 = _START_LOOP_0 + 1;


    let _SET_INSTRUMENT = 0;

    let _PLAY_NOTE = 1 << 5;
    let _PLAY_NOTE_LENGTH = _PLAY_NOTE | (0x10);

    let _PLAY_NOTE_SLUR_NEXT = 2 << 5;
    let _PLAY_NOTE_SLUR_NEXT_LENGTH = _PLAY_NOTE_SLUR_NEXT | (0x10);

    let _CHANGE_OCTAVE = 3 << 5;

    let __L2 = 64 / 2;
    let __L8 = 64 / 8;


    // MUST BE immediately after SongSubroutineTable
    const ExampleSongChannel : [u8] = [
        _REST as u8, 192,

        _SET_INSTRUMENT, 1,

        _START_LOOP_0,
            _CHANGE_OCTAVE | (((5+6) & 0xf) << 1),     // set octave to 5
            _CALL, 0,

            _CHANGE_OCTAVE | (((-2+6) & 0xf) << 1) | 1, // lower by 2 octaves
            _CALL, 0,

            _CHANGE_OCTAVE | ((( 1+6) & 0xf) << 1) | 1, // increase by 1 octave
            _CALL, 0,

            _REST as u8, 64,

            _SET_INSTRUMENT, 2,
        _END_LOOP_0, 0,

        _END,
    ];


    const ExampleSubroutine : [u8] = [
        _SET_SEMITONE_OFFSET as u8, 0 as u8,
        _PLAY_NOTE | 2,

        _SET_SEMITONE_OFFSET, -3 as u8,
        _PLAY_NOTE | 2,

        _RELATIVE_SEMITONE_OFFSET, 2,
        _PLAY_NOTE | 2,

        _RELATIVE_SEMITONE_OFFSET, -4 as u8,
        _PLAY_NOTE | 2,

        _REST as u8, 64,

        _RTS,
    ];
}


import "bytecode";

