// Copyright (c) 2023, Marcus Rowe <undisbeliever@gmail.com>.
// Distributed under The MIT License, see the LICENSE file for more details.


import "registers";


// Memory Map
// ==========

config {
    trim = true
}

bank zeropage       @ 0x0000 : [vardata;     0x00f0];
// addresses 0x00f0 - 0x00ff contain registers
bank stack          @ 0x0100 : [vardata;     0x0100];
bank code           @ 0x0200 : [varinitdata; 0x0200];

let EXTERNAL_DATA_ADDR = 0x400;


// Data Structures
// ===============

let N_BRR_SAMPLES   = 64;
let N_INSTRUMENTS   = 64;
let N_SOUND_EFFECTS = 128;


let INSTRUMENT_MASK = N_INSTRUMENTS - 1;


struct DirItem {
    start : *const u8,
    loop  : *const u8
};

struct InstrumentsSoA {
    scrn            : [u8 ; N_INSTRUMENTS],
    adsr1           : [u8 ; N_INSTRUMENTS],
    adsr2           : [u8 ; N_INSTRUMENTS],
    gain            : [u8 ; N_INSTRUMENTS],

    // offset between note c0 and `ExternalData.pitchTable[0]`
    // (pitch_offset + pitch is allowed to overflow and underflow)
    pitchOffset    : [u8 ; N_INSTRUMENTS],
};

struct ExternalData {
    brrDirectory   : [DirItem ; N_BRR_SAMPLES],

    pitchTable_l   : [u8; 256],
    pitchTable_h   : [u8; 256],

    instruments    : InstrumentsSoA,
};

extern const external_data @ EXTERNAL_DATA_ADDR : ExternalData;


bank data @ EXTERNAL_DATA_ADDR : [constdata; 0x8000];

in data {
    const __external_data = embed "../gen/common_data.bin";
}



// Variables
// =========

let N_CHANNELS = 8;

let CHANNEL_INDEX_INCREMENT = 16;
let MAX_CHANNEL_INDEX = (N_CHANNELS - 1) * CHANNEL_INDEX_INCREMENT;


in zeropage {
    // MUST be 16 bytes in size
    struct ChannelState {
        pitchOffset : u8,

        padding : [u8 ; 15],
    };

    var channels : [ChannelState ; N_CHANNELS];


    // Also doubles as an offset into VoiceDspAddr
    var currentChannelIndex : u8;

    // Used for the DSP enable-flags
    var currentChannelBit : u8;


    // Used by the octave playing loop.
    var __instrumentCounter : u8;
    var __noteCounter : u8;
}



// Macros
// ======

// KEEP: a, x, y
inline func write_dsp(addr : GlobalDspAddr in a, data : u8 in y) {
    smp.dsp_addr_and_data = ya;
}



// Code
// ====

in code {

// MUST be the first thing in the `code` bank (so the starting address is consistent across builds).
#[fallthrough]
func main() {
    sp = x = 0xff;

    // Reset the DSP
    write_dsp(GlobalDspAddr.FLG,    dsp.FLG__SOFT_RESET | dsp.FLG__MUTE_ALL | dsp.FLG__ECHO_DISABLE);

    write_dsp(GlobalDspAddr.KOFF,   0xff);  // all keys off

    y = 0;
    write_dsp(GlobalDspAddr.EFB,    y);     // No echo feedback
    write_dsp(GlobalDspAddr.PMON,   y);     // No pitch modulation
    write_dsp(GlobalDspAddr.NON,    y);     // No noise
    write_dsp(GlobalDspAddr.EON,    y);     // No echo


    // Set main volume to full volume
    y = 0x7f;
    write_dsp(GlobalDspAddr.MVOL_L, y);
    write_dsp(GlobalDspAddr.MVOL_R, y);

    y = 0;
    write_dsp(GlobalDspAddr.EVOL_L, y);
    write_dsp(GlobalDspAddr.EVOL_R, y);



    // Set directory table
    write_dsp(GlobalDspAddr.DIR, >:&external_data.brrDirectory[0]);


    // Unmute the audio (keep echo disabled)
    write_dsp(GlobalDspAddr.FLG,    dsp.FLG__ECHO_DISABLE);
    write_dsp(GlobalDspAddr.KOFF,   0);


    // Reset volume of all channels
    y = 0;
    do {
        set_channel_volume(y, 96);
        set_instrument(y, 0);

        y = a = y + CHANNEL_INDEX_INCREMENT;
    } while y < MAX_CHANNEL_INDEX + 1;


    currentChannelIndex = a = 0;
    currentChannelBit   = a = 1 << 0;

    while true {
        a = 0;
        do {
            __instrumentCounter = a;
            set_instrument(currentChannelIndex, a);

            a = 4 * 12;
            do {
                __noteCounter = a;

                play_note(currentChannelIndex, a);

                delay();

                // Required to prevent popping
                key_off(currentChannelIndex);

                a = __noteCounter;
                a++;
            } while a < 5 * 12;

            delay();
            delay();

            a = __instrumentCounter;
            a++;
        } while a < 4;
    }
}


func delay() {
    x = 0x80;
    do {
        y = 0;
        do {
            y--;
        } while !zero;

        x--;
    } while !zero;
}


// KEEP: Y
func set_instrument(channelIndex : u8 in y, instrumentId : u8 in a) {
    // Using addr,y addressing mode for `channels`, 1 cycle faster then transferring y to x.

    x = a = a & INSTRUMENT_MASK;

    (&channels[0].pitchOffset)[unaligned y] = a = external_data.instruments.pitchOffset[x];

    smp.dsp_addr = a = y + VoiceDspAddr.SCRN as u8;
    smp.dsp_data = a = external_data.instruments.scrn[x];

    smp.dsp_addr++;
    smp.dsp_data = a = external_data.instruments.adsr1[x];

    smp.dsp_addr++;
    smp.dsp_data = a = external_data.instruments.adsr2[x];

    smp.dsp_addr++;
    smp.dsp_data = a = external_data.instruments.gain[x];
}


// KEEP: Y
func set_channel_volume(channelIndex : u8 in y, volume : u8 in a) {
    smp.dsp_addr = y + VoiceDspAddr.VOL_L as u8;
    smp.dsp_data = a;

    smp.dsp_addr++;
    smp.dsp_data = a;
}


func key_off(channelIndex : u8 in y) {
    write_dsp(GlobalDspAddr.KOFF, currentChannelBit);

    // This delay is required to prevent popping
    a = 0;
    do {
        nop();
        nop();
        nop();
        nop();
        a--;
    } while !zero;

    // Must clear the KOFF register or else the notes will not play
    write_dsp(GlobalDspAddr.KOFF, 0);
}


// ASSUMES: y == currentChannelIndex
func play_note(channelIndex : u8 in y, note : u8 in a) {
    x = currentChannelIndex;
    x = a = a + (&channels[0].pitchOffset)[unaligned x];

    smp.dsp_addr = a = currentChannelIndex + VoiceDspAddr.PITCH_L as u8;
    smp.dsp_data = a = external_data.pitchTable_l[x];

    smp.dsp_addr++;
    smp.dsp_data = a = external_data.pitchTable_h[x];

    write_dsp(GlobalDspAddr.KON, currentChannelBit);
}

}

