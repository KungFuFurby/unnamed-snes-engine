// Copyright (c) 2023, Marcus Rowe <undisbeliever@gmail.com>.
// Distributed under The MIT License, see the LICENSE file for more details.


import "registers";


// Memory Map
// ==========

config {
    trim = true
}

bank zeropage       @ 0x0000 : [vardata;     0x00f0];
// addresses 0x00f0 - 0x00ff contain registers
bank stack          @ 0x0100 : [vardata;     0x0100];
bank code           @ 0x0200 : [varinitdata; 0x0200];

let EXTERNAL_DATA_ADDR = 0x400;


// Data Structures
// ===============

let N_BRR_SAMPLES   = 64;
let N_INSTRUMENTS   = 64;
let N_SOUND_EFFECTS = 128;


let INSTRUMENT_MASK = N_INSTRUMENTS - 1;


struct DirItem {
    start : *const u8,
    loop  : *const u8
};

struct InstrumentsSoA {
    scrn            : [u8 ; N_INSTRUMENTS],
    adsr1           : [u8 ; N_INSTRUMENTS],
    adsr2           : [u8 ; N_INSTRUMENTS],
    gain            : [u8 ; N_INSTRUMENTS],

    // offset between note c0 and `ExternalData.pitchTable[0]`
    // (pitch_offset + pitch is allowed to overflow and underflow)
    pitchOffset    : [u8 ; N_INSTRUMENTS],
};

struct ExternalData {
    brrDirectory   : [DirItem ; N_BRR_SAMPLES],

    pitchTable_l   : [u8; 256],
    pitchTable_h   : [u8; 256],

    instruments    : InstrumentsSoA,
};

extern const external_data @ EXTERNAL_DATA_ADDR : ExternalData;


bank data @ EXTERNAL_DATA_ADDR : [constdata; 0x8000];

in data {
    const __external_data = embed "../gen/common_data.bin";
}



// Variables
// =========

let N_CHANNELS = 8;

in zeropage {
    namespace channelSoA {
        var pitchOffset : [u8 ; N_CHANNELS];

    }

    // Index into channelSoA
    // Index into ChannelVoiceOffset
    // Index into ChannelVoiceBit
    // (byte index < N_CHANNELS)
    var currentChannelIndex : u8;


    // Used by the octave playing loop.
    var __instrumentCounter : u8;
    var __noteCounter : u8;
}



// Macros
// ======

// KEEP: a, x, y
inline func write_dsp(addr : GlobalDspAddr in a, data : u8 in y) {
    smp.dsp_addr_and_data = ya;
}



// Code
// ====

in code {

// MUST be the first thing in the `code` bank (so the starting address is consistent across builds).
#[fallthrough]
func main() {
    sp = x = 0xff;

    // Reset the DSP
    write_dsp(GlobalDspAddr.FLG,    dsp.FLG__SOFT_RESET | dsp.FLG__MUTE_ALL | dsp.FLG__ECHO_DISABLE);

    write_dsp(GlobalDspAddr.KOFF,   0xff);  // all keys off

    y = 0;
    write_dsp(GlobalDspAddr.EFB,    y);     // No echo feedback
    write_dsp(GlobalDspAddr.PMON,   y);     // No pitch modulation
    write_dsp(GlobalDspAddr.NON,    y);     // No noise
    write_dsp(GlobalDspAddr.EON,    y);     // No echo


    // Set main volume to full volume
    y = 0x7f;
    write_dsp(GlobalDspAddr.MVOL_L, y);
    write_dsp(GlobalDspAddr.MVOL_R, y);

    y = 0;
    write_dsp(GlobalDspAddr.EVOL_L, y);
    write_dsp(GlobalDspAddr.EVOL_R, y);



    // Set directory table
    write_dsp(GlobalDspAddr.DIR, >:&external_data.brrDirectory[0]);


    // Unmute the audio (keep echo disabled)
    write_dsp(GlobalDspAddr.FLG,    dsp.FLG__ECHO_DISABLE);
    write_dsp(GlobalDspAddr.KOFF,   0);


    // Reset all channels
    x = N_CHANNELS - 1;
    do {
        set_channel_volume(x, 96);
        set_instrument(x, 0);

        x--;
    } while !negative;


    currentChannelIndex = a = 0;

    while true {
        a = 0;
        do {
            __instrumentCounter = a;
            set_instrument(currentChannelIndex, a);

            a = 4 * 12;
            do {
                __noteCounter = a;

                play_note(currentChannelIndex, a);

                delay();

                // Required to prevent popping
                key_off(currentChannelIndex);

                a = __noteCounter;
                a++;
            } while a < 5 * 12;

            delay();
            delay();

            a = __instrumentCounter;
            a++;
        } while a < 4;
    }
}


func delay() {
    x = 0x80;
    do {
        y = 0;
        do {
            y--;
        } while !zero;

        x--;
    } while !zero;
}


// KEEP: X
func set_instrument(channelIndex : u8 in x, instrumentId : u8 in a) {
    // Using addr,y addressing mode for `channels`, 1 cycle faster then transferring y to x.

    y = a = a & INSTRUMENT_MASK;

    channelSoA.pitchOffset[x] = a = external_data.instruments.pitchOffset[y];

    smp.dsp_addr = a = ChannelVoiceOffset[x] | VoiceDspAddr.SCRN as u8;
    smp.dsp_data = a = external_data.instruments.scrn[y];

    smp.dsp_addr++;
    smp.dsp_data = a = external_data.instruments.adsr1[y];

    smp.dsp_addr++;
    smp.dsp_data = a = external_data.instruments.adsr2[y];

    smp.dsp_addr++;
    smp.dsp_data = a = external_data.instruments.gain[y];
}


// KEEP: X
func set_channel_volume(channelIndex : u8 in x, volume : u8 in a) {
    y = a;

    // ASSUMES VoiceDspAddr.VOL_L == 0
    smp.dsp_addr = a = ChannelVoiceOffset[x];
    smp.dsp_data = y;

    smp.dsp_addr++;
    smp.dsp_data = y;
}


// KEEP: X
func key_off(channelIndex : u8 in x) {
    smp.dsp_addr = a = GlobalDspAddr.KOFF as u8;
    smp.dsp_data = a = ChannelVoiceBit[x];

    // This delay is required to prevent popping
    a = 0;
    do {
        nop();
        nop();
        nop();
        nop();
        a--;
    } while !zero;
}


// KEEP: x
func play_note(channelIndex : u8 in x, note : u8 in a) {

    y = a = a + channelSoA.pitchOffset[x];

    smp.dsp_addr = a = ChannelVoiceOffset[x] | VoiceDspAddr.PITCH_L as u8;
    smp.dsp_data = a = external_data.pitchTable_l[y];

    smp.dsp_addr++;
    smp.dsp_data = a = external_data.pitchTable_h[y];

    // Must clear the KOFF register or else the notes will not play
    smp.dsp_addr = a = GlobalDspAddr.KOFF as u8;
    smp.dsp_data = a = 0;

    // Send KON command
    smp.dsp_addr = a = GlobalDspAddr.KON as u8;
    smp.dsp_data = a = ChannelVoiceBit[x];
}

}


// Data Tables
// ===========

// Using the `code` bank so the data is included in `audio-driver.bin`
in code {
    // The bit used for global DSP registers (KON, KOFF, NON, EON, etc)
    const ChannelVoiceBit : [u8; 8] = [1 << i for let i in 0..7];

    // The offset into the Voice DSP registers
    const ChannelVoiceOffset : [u8; 8] = [i * 0x10 for let i in 0..7];
}

