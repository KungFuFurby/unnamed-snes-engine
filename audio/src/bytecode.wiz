// Copyright (c) 2023, Marcus Rowe <undisbeliever@gmail.com>.
// Distributed under The MIT License, see the LICENSE file for more details.


import "audio-driver";


namespace bytecode {

let DISABLE_CHANNEL_BYTECODE = N_SINGLE_ARGUMENT_INSTRUCTIONS;

let INLINE_ARGUMENT_MASK = 0x1f;

let N_SINGLE_ARGUMENT_INSTRUCTIONS = sizeof(typeof(SINGLE_ARGUMENT_INSTRUCTIONS)) / sizeof(typeof(SINGLE_ARGUMENT_INSTRUCTIONS[0]));
let N_NO_ARGUMENT_INSTRUCTIONS = sizeof(typeof(NO_ARGUMENT_INSTRUCTIONS)) / sizeof(typeof(NO_ARGUMENT_INSTRUCTIONS[0]));


// These bytecodes do have parameters
let SINGLE_ARGUMENT_INSTRUCTIONS = [
    set_instrument,

    set_channel_volume,

    // parameter = number of 1/64 beats to pause
    // NOTE: Does not send a keyoff event after.
    rest,

    // U16 WORD parameter = address to jump to
    jump,

    // U16 WORD parameter = subroutine address
    //
    // The `call` bytecode CANNOT be called inside a subroutine.
    call_subroutine,

    // parameter = number of times to loop - 2
    end_loop_0,

    // parameter = number of times to loop - 2
    end_loop_1,
];

// These bytecodes do not have parameters
let NO_PARAMETER_INSTRUCTIONS = [
    disable_channel,

    // Return from a call instruction
    return_from_subroutine,

    start_loop_0,
    start_loop_1,

    // padding
    disable_channel,
    disable_channel,
    disable_channel,
    disable_channel,
    disable_channel,
    disable_channel,
    disable_channel,
    disable_channel,
    disable_channel,
    disable_channel,
    disable_channel,
    disable_channel,
    disable_channel,
    disable_channel,
    disable_channel,
    disable_channel,
    disable_channel,
    disable_channel,
    disable_channel,
    disable_channel,
    disable_channel,
];


// These bytecode combine instruction and parameter in a single byte
// byte value = `bbbppppp`
let INLINE_ARGUMENT_INSTRUCTIONS = [
    null_instruction,

    // parameter: lnnnn
    //      l    = next byte contains length of the note
    //      nnnn = note to play
    play_note,

    // Does not send a KOFF after the note ends.
    //
    // The next `play_note*` command will not send a KON event.
    //
    // parameter: lnnnn
    //      l    = next byte contains length of the note
    //      nnnn = note to play
    play_note_slur_next,

    // padding
    null_instruction,
    null_instruction,
    null_instruction,
    null_instruction,
    null_instruction,
];

}


